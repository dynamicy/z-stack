###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                09/Aug/2013  16:01:15 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\CC2530_ZStack0801\Sensor Network                #
#                          Example\Components\hal\target\CC2530EB\hal_adc.c   #
#    Command line       =  -f "D:\CC2530_ZStack0801\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.c #
#                          fg" (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS)   #
#                          -f "D:\CC2530_ZStack0801\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig. #
#                          cfg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0             #
#                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800          #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440)   #
#                          -f "D:\CC2530_ZStack0801\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg #
#                          " (-DZCL_READ -DZCL_WRITE -DZCL_BASIC              #
#                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH    #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING) -DZCL_MESSAGE                       #
#                          "D:\CC2530_ZStack0801\Sensor Network               #
#                          Example\Components\hal\target\CC2530EB\hal_adc.c"  #
#                          -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D         #
#                          MT_APP_FUNC -D MT_SYS_FUNC -D MT_ZDO_FUNC -D       #
#                          LCD_SUPPORTED=DEBUG -D xPOWER_SAVING -D            #
#                          End_Device -D HAL_KEYPAD -D M110 -D xPA2591 -lC    #
#                          "D:\CC2530_ZStack0801\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\List\" -lA        #
#                          "D:\CC2530_ZStack0801\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\List\"            #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          "D:\CC2530_ZStack0801\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\Obj\" -e          #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\CC2530_ZStack0801\Sens #
#                          or Network Example\Projects\zstack\Sensor Network  #
#                          Application\ZIGBEE Endpoint & Device\CC2530DB\"    #
#                          -I "D:\CC2530_ZStack0801\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\SOURCE\" -I                     #
#                          "D:\CC2530_ZStack0801\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\SOURCE\" -I                  #
#                          "D:\CC2530_ZStack0801\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I       #
#                          "D:\CC2530_ZStack0801\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I  #
#                          "D:\CC2530_ZStack0801\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCL #
#                          UDE\" -I "D:\CC2530_ZStack0801\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\MODU #
#                          LE\" -I "D:\CC2530_ZStack0801\Sensor Network       #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARG #
#                          ET\CC2530EB\" -I "D:\CC2530_ZStack0801\Sensor      #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU #
#                          \CCSOC\" -I "D:\CC2530_ZStack0801\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INC #
#                          LUDE\" -I "D:\CC2530_ZStack0801\Sensor Network     #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF #
#                          \" -I "D:\CC2530_ZStack0801\Sensor Network         #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NW #
#                          K\" -I "D:\CC2530_ZStack0801\Sensor Network        #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SE #
#                          C\" -I "D:\CC2530_ZStack0801\Sensor Network        #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SA #
#                          PI\" -I "D:\CC2530_ZStack0801\Sensor Network       #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SY #
#                          S\" -I "D:\CC2530_ZStack0801\Sensor Network        #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZC #
#                          L\" -I "D:\CC2530_ZStack0801\Sensor Network        #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZD #
#                          O\" -I "D:\CC2530_ZStack0801\Sensor Network        #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W #
#                          \" -I "D:\CC2530_ZStack0801\Sensor Network         #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\"   #
#                          -I "D:\CC2530_ZStack0801\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SADDR\" -I "D:\CC2530_ZStack0801\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SDATA\" -I "D:\CC2530_ZStack0801\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCL #
#                          UDE\" -I "D:\CC2530_ZStack0801\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH #
#                          _LEVEL\" -I "D:\CC2530_ZStack0801\Sensor Network   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\" -I "D:\CC2530_ZStack0801\Sensor      #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\SINGLE_CHIP\" -I "C:\Program Files     #
#                          (x86)\IAR Systems\Embedded Workbench               #
#                          5.3\8051\INC\" -I "C:\Program Files (x86)\IAR      #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  D:\CC2530_ZStack0801\Sensor Network                #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\List\hal_adc.lst  #
#    Object file        =  D:\CC2530_ZStack0801\Sensor Network                #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceEB_M160\Obj\hal_adc.r51   #
#                                                                             #
#                                                                             #
###############################################################################

D:\CC2530_ZStack0801\Sensor Network Example\Components\hal\target\CC2530EB\hal_adc.c
      1          /**************************************************************************************************
      2            Filename:       hal_adc.c
      3            Revised:        $Date: 2009-12-17 13:13:47 -0800 (Thu, 17 Dec 2009) $
      4            Revision:       $Revision: 21356 $
      5          
      6            Description:    This file contains the interface to the HAL ADC.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41           *                                           INCLUDES
     42           **************************************************************************************************/
     43          #include  "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x88
   \   union <unnamed> volatile __sfr _A_TCON
   \                     _A_TCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb5
   \   unsigned char volatile __sfr ADCCON2
   \                     ADCCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb6
   \   unsigned char volatile __sfr ADCCON3
   \                     ADCCON3:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xba
   \   unsigned char volatile __sfr ADCL
   \                     ADCL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr ADCH
   \                     ADCH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf2
   \   unsigned char volatile __sfr ADCCFG
   \                     ADCCFG:
   \   000000                DS 1
     44          #include  "hal_defs.h"
     45          #include  "hal_types.h"
     46          #include  "hal_adc.h"
     47          
     48          #if defined(M170)  // SensorApp example include header file
     49            #include  "M170.h"
     50          #endif
     51          
     52          /**************************************************************************************************
     53           *                                            CONSTANTS
     54           **************************************************************************************************/
     55          #define HAL_ADC_EOC         0x80    /* End of Conversion bit */
     56          #define HAL_ADC_START       0x40    /* Starts Conversion */
     57          
     58          #define HAL_ADC_STSEL_EXT   0x00    /* External Trigger */
     59          #define HAL_ADC_STSEL_FULL  0x10    /* Full Speed, No Trigger */
     60          #define HAL_ADC_STSEL_T1C0  0x20    /* Timer1, Channel 0 Compare Event Trigger */
     61          #define HAL_ADC_STSEL_ST    0x30    /* ADCCON1.ST =1 Trigger */
     62          
     63          #define HAL_ADC_RAND_NORM   0x00    /* Normal Operation */
     64          #define HAL_ADC_RAND_LFSR   0x04    /* Clock LFSR */
     65          #define HAL_ADC_RAND_SEED   0x08    /* Seed Modulator */
     66          #define HAL_ADC_RAND_STOP   0x0c    /* Stop Random Generator */
     67          #define HAL_ADC_RAND_BITS   0x0c    /* Bits [3:2] */
     68          
     69          #define HAL_ADC_DEC_064     0x00    /* Decimate by 64 : 8-bit resolution */
     70          #define HAL_ADC_DEC_128     0x10    /* Decimate by 128 : 10-bit resolution */
     71          #define HAL_ADC_DEC_256     0x20    /* Decimate by 256 : 12-bit resolution */
     72          #define HAL_ADC_DEC_512     0x30    /* Decimate by 512 : 14-bit resolution */
     73          #define HAL_ADC_DEC_BITS    0x30    /* Bits [5:4] */
     74          
     75          #define HAL_ADC_STSEL       HAL_ADC_STSEL_ST
     76          #define HAL_ADC_RAND_GEN    HAL_ADC_RAND_STOP
     77          #define HAL_ADC_REF_VOLT    HAL_ADC_REF_AVDD
     78          #define HAL_ADC_DEC_RATE    HAL_ADC_DEC_064
     79          #define HAL_ADC_SCHN        HAL_ADC_CHN_VDD3
     80          #define HAL_ADC_ECHN        HAL_ADC_CHN_GND
     81          
     82          /* Vdd limit values */

   \                                 In  segment CODE_C, align 1
     83          static __code const uint16 HalAdcVddLimit[] =
   \                     HalAdcVddLimit:
   \   000000   9C36063A     DW 13980, 14854, 15728, 16601, 17475, 18349, 19223, 20097, 20970
   \            703DD940
   \            4344AD47
   \            174B814E
   \            EA51    
     84          {
     85            0x369C,       /*  VDD Limit - 1.6v  */
     86            0x3A06,       /*  VDD Limit - 1.7v  */
     87            0x3D70,       /*  VDD Limit - 1.8v  */
     88            0x40D9,       /*  VDD Limit - 1.9v  */
     89            0x4443,       /*  VDD Limit - 2.0v  */
     90            0x47AD,       /*  VDD Limit - 2.1v  */
     91            0x4B17,       /*  VDD Limit - 2.2v  */
     92            0x4E81,       /*  VDD Limit - 2.3v  */
     93            0x51EA,       /*  VDD Limit - 2.4v  */
     94          };
     95          
     96          /**************************************************************************************************
     97           *                                              MACROS
     98           **************************************************************************************************/
     99          #define HAL_ADC_CLR_EOC()   asm("PUSH A"); asm("MOV A,ADCL"); asm("MOV A,ADCH"); asm("POP A");
    100          
    101          /**************************************************************************************************
    102           *                                            TYPEDEFS
    103           **************************************************************************************************/
    104          
    105          /**************************************************************************************************
    106           *                                         GLOBAL VARIABLES
    107           **************************************************************************************************/
    108          
    109          /**************************************************************************************************
    110           *                                          FUNCTIONS - API
    111           **************************************************************************************************/
    112          extern bool HalAdcCheckVdd (uint8 limit);
    113          
    114          /**************************************************************************************************
    115           * @fn      HalAdcInit
    116           *
    117           * @brief   Initialize ADC Service
    118           *
    119           * @param   None
    120           *
    121           * @return  None
    122           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    123          void HalAdcInit (void)
   \                     HalAdcInit:
    124          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    125          #if (HAL_ADC == TRUE)
    126            volatile uint8  tmp;
    127          
    128            ADCCON1 = HAL_ADC_STSEL | HAL_ADC_RAND_GEN | 0x03;
   \   000009   75B43F       MOV     0xb4,#0x3f
    129            ADCCON2 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_SCHN;
   \   00000C   75B58F       MOV     0xb5,#-0x71
    130            /*
    131            *  After reset, the first ADC reading of the extra conversion always reads GND level.
    132            *  We will do a few dummy conversions to bypass this bug.
    133            */
    134            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   00000F   12....       LCALL   ?Subroutine0 & 0xFFFF
    135            tmp = ADCH;
    136            ADCCON3 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \                     ??CrossCallReturnLabel_0:
   \   000012   75B68C       MOV     0xb6,#-0x74
    137            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcInit_0:
   \   000015   E5B4         MOV     A,0xb4
   \   000017   A2E7         MOV     C,0xE0 /* A   */.7
   \   000019   50FA         JNC     ??HalAdcInit_0
    138            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   00001B   E5BA         MOV     A,0xba
   \   00001D   12....       LCALL   ??Subroutine2_0 & 0xFFFF
    139            tmp = ADCH;
    140            ADCCON3 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \                     ??CrossCallReturnLabel_3:
   \   000020   75B68C       MOV     0xb6,#-0x74
    141            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcInit_1:
   \   000023   E5B4         MOV     A,0xb4
   \   000025   A2E7         MOV     C,0xE0 /* A   */.7
   \   000027   50FA         JNC     ??HalAdcInit_1
    142            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   000029                REQUIRE ?Subroutine1
   \   000029                REQUIRE ADCCON1
   \   000029                REQUIRE ADCCON2
   \   000029                REQUIRE ADCCON3
   \   000029                REQUIRE ADCH
   \   000029                REQUIRE ADCL
   \   000029                ; // Fall through to label ?Subroutine1
    143            tmp = ADCH;
    144          #endif
    145          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E5BA         MOV     A,0xba
   \   000002   12....       LCALL   ??Subroutine2_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000005   7401         MOV     A,#0x1
   \   000007   12....       LCALL   ?DEALLOC_XSTACK8
   \   00000A   D083         POP     DPH
   \   00000C   D082         POP     DPL
   \   00000E   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E5BA         MOV     A,0xba
   \   000002   85..82       MOV     DPL,?XSP + 0
   \   000005   85..83       MOV     DPH,?XSP + 1
   \   000008                REQUIRE ??Subroutine2_0
   \   000008                ; // Fall through to label ??Subroutine2_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine2_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   E5BB         MOV     A,0xbb
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET
    146          
    147          /**************************************************************************************************
    148           * @fn      HalAdcRead
    149           *
    150           * @brief   Read the ADC based on given channel and resolution
    151           *
    152           * @param   channel - channel where ADC will be read
    153           * @param   resolution - the resolution of the value
    154           *
    155           * @return  16 bit value of the ADC in offset binary format.
    156           *
    157           *          Note that the ADC is "bipolar", which means the GND (0V) level is mid-scale.
    158           *          Note2: This function assumes that ADCCON3 contains the voltage reference.
    159           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    160          uint16 HalAdcRead (uint8 channel, uint8 resolution)
   \                     HalAdcRead:
    161          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    162            int16  reading = 0;
    163          
    164          #if (HAL_ADC == TRUE)
    165          
    166            uint8   i, resbits;
    167            uint8   adctemp;
    168            volatile  uint8 tmp;
    169            uint8  adcChannel = 1;
   \   00000A   7D01         MOV     R5,#0x1
    170            uint8  reference;
    171          
    172            /* store the previously set reference voltage selection */
    173            reference = ADCCON3 & HAL_ADC_REF_BITS;
   \   00000C   74C0         MOV     A,#-0x40
   \   00000E   55B6         ANL     A,0xb6
   \   000010   FE           MOV     R6,A
    174          
    175            /*
    176            * If Analog input channel is AIN0..AIN7, make sure corresponing P0 I/O pin is enabled.  The code
    177            * does NOT disable the pin at the end of this function.  I think it is better to leave the pin
    178            * enabled because the results will be more accurate.  Because of the inherent capacitance on the
    179            * pin, it takes time for the voltage on the pin to charge up to its steady-state level.  If
    180            * HalAdcRead() has to turn on the pin for every conversion, the results may show a lower voltage
    181            * than actuality because the pin did not have time to fully charge.
    182            */
    183            if (channel < 8)
   \   000011   E9           MOV     A,R1
   \   000012   C3           CLR     C
   \   000013   9408         SUBB    A,#0x8
   \   000015   500E         JNC     ??HalAdcRead_0
    184            {
    185              for (i=0; i < channel; i++)
   \   000017   7B00         MOV     R3,#0x0
   \   000019   8005         SJMP    ??HalAdcRead_1
    186              {
    187                adcChannel <<= 1;
   \                     ??HalAdcRead_2:
   \   00001B   ED           MOV     A,R5
   \   00001C   C3           CLR     C
   \   00001D   33           RLC     A
   \   00001E   FD           MOV     R5,A
    188              }
   \   00001F   0B           INC     R3
   \                     ??HalAdcRead_1:
   \   000020   EB           MOV     A,R3
   \   000021   C3           CLR     C
   \   000022   99           SUBB    A,R1
   \   000023   40F6         JC      ??HalAdcRead_2
    189            }
    190          
    191            /* Enable channel */
    192            ADCCFG |= adcChannel;
   \                     ??HalAdcRead_0:
   \   000025   ED           MOV     A,R5
   \   000026   45F2         ORL     A,0xf2
   \   000028   F5F2         MOV     0xf2,A
    193          
    194            /* Convert resolution to decimation rate */
    195            switch (resolution)
   \   00002A   EA           MOV     A,R2
   \   00002B   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for HalAdcRead>_0`:
   \   00002E   01           DB        1
   \   00002F   03           DB        3
   \   000030   ....         DW        ??HalAdcRead_3
   \   000032   ....         DW        ??HalAdcRead_4
   \   000034   ....         DW        ??HalAdcRead_5
   \   000036   ....         DW        ??HalAdcRead_6
   \   000038   ....         DW        ??HalAdcRead_7
    196            {
    197              case HAL_ADC_RESOLUTION_8:
    198                resbits = HAL_ADC_DEC_064;
   \                     ??HalAdcRead_4:
   \   00003A   7C00         MOV     R4,#0x0
   \   00003C   800A         SJMP    ??HalAdcRead_3
    199                break;
    200              case HAL_ADC_RESOLUTION_10:
    201                resbits = HAL_ADC_DEC_128;
   \                     ??HalAdcRead_5:
   \   00003E   7C10         MOV     R4,#0x10
   \   000040   8006         SJMP    ??HalAdcRead_3
    202                break;
    203              case HAL_ADC_RESOLUTION_12:
    204                resbits = HAL_ADC_DEC_256;
   \                     ??HalAdcRead_6:
   \   000042   7C20         MOV     R4,#0x20
   \   000044   8002         SJMP    ??HalAdcRead_3
    205                break;
    206              case HAL_ADC_RESOLUTION_14:
    207                resbits = HAL_ADC_DEC_512;
   \                     ??HalAdcRead_7:
   \   000046   7C30         MOV     R4,#0x30
    208                break;
    209              default:
    210          //      resbits = HAL_ADC_DEC_512;
    211                break;
    212            }
    213          
    214            /* read ADCL,ADCH to clear EOC */
    215            tmp = ADCL;
   \                     ??HalAdcRead_3:
   \   000048   12....       LCALL   ?Subroutine0 & 0xFFFF
    216            tmp = ADCH;
    217          
    218            /* Setup Sample */
    219            adctemp = ADCCON3;
   \                     ??CrossCallReturnLabel_1:
   \   00004B   E5B6         MOV     A,0xb6
    220            adctemp &= ~(HAL_ADC_CHN_BITS | HAL_ADC_DEC_BITS | HAL_ADC_REF_BITS);
    221            adctemp |= channel | resbits | (reference);
    222          
    223            /* writing to this register starts the extra conversion */
    224            ADCCON3 = adctemp;
   \   00004D   EC           MOV     A,R4
   \   00004E   49           ORL     A,R1
   \   00004F   4E           ORL     A,R6
   \   000050   F5B6         MOV     0xb6,A
    225          
    226            /* Wait for the conversion to be done */
    227            while (!(ADCCON1 & HAL_ADC_EOC));
   \                     ??HalAdcRead_8:
   \   000052   E5B4         MOV     A,0xb4
   \   000054   A2E7         MOV     C,0xE0 /* A   */.7
   \   000056   50FA         JNC     ??HalAdcRead_8
    228          
    229            /* Disable channel after done conversion */
    230            ADCCFG &= (adcChannel ^ 0xFF);
   \   000058   74FF         MOV     A,#-0x1
   \   00005A   6D           XRL     A,R5
   \   00005B   55F2         ANL     A,0xf2
   \   00005D   F5F2         MOV     0xf2,A
    231          
    232            /* Read the result */
    233            reading = (int16) (ADCL);
   \   00005F   ABBA         MOV     R3,0xba
   \   000061   8B82         MOV     DPL,R3
   \   000063   A882         MOV     R0,DPL
    234            reading |= (int16) (ADCH << 8);
   \   000065   E5BB         MOV     A,0xbb
   \   000067   F9           MOV     R1,A
    235          
    236            /* Treat small negative as 0 */
    237            if (reading < 0)
   \   000068   C3           CLR     C
   \   000069   9400         SUBB    A,#0x0
   \   00006B   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00006D   65D0         XRL     A,PSW
   \   00006F   33           RLC     A
   \   000070   5004         JNC     ??HalAdcRead_9
    238              reading = 0;
   \   000072   7800         MOV     R0,#0x0
   \   000074   7900         MOV     R1,#0x0
    239          
    240            switch (resolution)
   \                     ??HalAdcRead_9:
   \   000076   EA           MOV     A,R2
   \   000077   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for HalAdcRead>_1`:
   \   00007A   01           DB        1
   \   00007B   02           DB        2
   \   00007C   ....         DW        ??HalAdcRead_10
   \   00007E   ....         DW        ??HalAdcRead_11
   \   000080   ....         DW        ??HalAdcRead_12
   \   000082   ....         DW        ??HalAdcRead_13
    241            {
    242              case HAL_ADC_RESOLUTION_8:
    243                reading >>= 8;
   \                     ??HalAdcRead_11:
   \   000084   88..         MOV     ?V0 + 0,R0
   \   000086   89..         MOV     ?V0 + 1,R1
   \   000088   7408         MOV     A,#0x8
   \   00008A   8016         SJMP    ??HalAdcRead_14
    244                break;
    245              case HAL_ADC_RESOLUTION_10:
    246                reading >>= 6;
   \                     ??HalAdcRead_12:
   \   00008C   88..         MOV     ?V0 + 0,R0
   \   00008E   89..         MOV     ?V0 + 1,R1
   \   000090   7406         MOV     A,#0x6
   \   000092   800E         SJMP    ??HalAdcRead_14
    247                break;
    248              case HAL_ADC_RESOLUTION_12:
    249                reading >>= 4;
   \                     ??HalAdcRead_13:
   \   000094   88..         MOV     ?V0 + 0,R0
   \   000096   89..         MOV     ?V0 + 1,R1
   \   000098   7404         MOV     A,#0x4
   \   00009A   8006         SJMP    ??HalAdcRead_14
    250                break;
    251              case HAL_ADC_RESOLUTION_14:
    252              default:
    253                reading >>= 2;
   \                     ??HalAdcRead_10:
   \   00009C   88..         MOV     ?V0 + 0,R0
   \   00009E   89..         MOV     ?V0 + 1,R1
   \   0000A0   7402         MOV     A,#0x2
   \                     ??HalAdcRead_14:
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   12....       LCALL   ?SS_SHR
   \   0000A7   A8..         MOV     R0,?V0 + 0
   \   0000A9   A9..         MOV     R1,?V0 + 1
    254              break;
    255            }
    256          #else
    257            // unused arguments
    258            (void) channel;
    259            (void) resolution;
    260          #endif
    261          
    262            return ((uint16)reading);
   \   0000AB   E8           MOV     A,R0
   \   0000AC   FA           MOV     R2,A
   \   0000AD   E9           MOV     A,R1
   \   0000AE   FB           MOV     R3,A
   \   0000AF   7401         MOV     A,#0x1
   \   0000B1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B4   7F02         MOV     R7,#0x2
   \   0000B6   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   0000B9                REQUIRE ADCCON1
   \   0000B9                REQUIRE ADCCON3
   \   0000B9                REQUIRE ADCH
   \   0000B9                REQUIRE ADCL
   \   0000B9                REQUIRE ADCCFG
    263          }
    264          
    265          /**************************************************************************************************
    266           * @fn      HalAdcSetReference
    267           *
    268           * @brief   Sets the reference voltage for the ADC and initializes the service
    269           *
    270           * @param   reference - the reference voltage to be used by the ADC
    271           *
    272           * @return  none
    273           *
    274           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    275          void HalAdcSetReference ( uint8 reference )
   \                     HalAdcSetReference:
    276          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    277          #if (HAL_ADC == TRUE)
    278            volatile uint8 tmp;
    279          
    280            ADCCON1 = HAL_ADC_STSEL | HAL_ADC_RAND_GEN | 0x03;
   \   000009   75B43F       MOV     0xb4,#0x3f
    281            ADCCON2 = (reference) | HAL_ADC_DEC_RATE | HAL_ADC_SCHN;
   \   00000C   740F         MOV     A,#0xf
   \   00000E   49           ORL     A,R1
   \   00000F   F5B5         MOV     0xb5,A
    282            /*
    283            *  After reset, the first ADC reading of the extra conversion always reads GND level.
    284            *  We will do a few dummy conversions to bypass this bug.
    285            */
    286            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   000011   12....       LCALL   ?Subroutine0 & 0xFFFF
    287            tmp = ADCH;
    288            ADCCON3 = (reference) | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \                     ??CrossCallReturnLabel_2:
   \   000014   740C         MOV     A,#0xc
   \   000016   49           ORL     A,R1
   \   000017   FA           MOV     R2,A
   \   000018   8AB6         MOV     0xb6,R2
    289            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcSetReference_0:
   \   00001A   E5B4         MOV     A,0xb4
   \   00001C   A2E7         MOV     C,0xE0 /* A   */.7
   \   00001E   50FA         JNC     ??HalAdcSetReference_0
    290            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   000020   E5BA         MOV     A,0xba
   \   000022   12....       LCALL   ??Subroutine2_0 & 0xFFFF
    291            tmp = ADCH;
    292            ADCCON3 = (reference) | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \                     ??CrossCallReturnLabel_5:
   \   000025   8AB6         MOV     0xb6,R2
    293            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcSetReference_1:
   \   000027   E5B4         MOV     A,0xb4
   \   000029   A2E7         MOV     C,0xE0 /* A   */.7
   \   00002B   50FA         JNC     ??HalAdcSetReference_1
    294            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   00002D   02....       LJMP    ?Subroutine1 & 0xFFFF
   \   000030                REQUIRE ADCCON1
   \   000030                REQUIRE ADCCON2
   \   000030                REQUIRE ADCCON3
   \   000030                REQUIRE ADCH
   \   000030                REQUIRE ADCL
    295            tmp = ADCH;
    296          #endif
    297          }
    298          
    299          /**************************************************************************************************
    300           * @fn      HalAdcCheckVdd
    301           *
    302           * @brief   Check the Vdd and return TRUE if it greater than or equal the limit
    303           *
    304           * @param   limit - limit that needs to be checked with the Vdd
    305           *
    306           * @return  TRUE if Vdd >= limit, FALSE otherwise
    307           *
    308           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    309          bool HalAdcCheckVdd (uint8 limit)
   \                     HalAdcCheckVdd:
    310          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    311            uint16 value;
    312            uint8 tmpADCCON3 = ADCCON3;  // Save ADCCON3 to restore later
   \   000005   E5B6         MOV     A,0xb6
   \   000007   FE           MOV     R6,A
    313          
    314            /* Clear ADC interrupt flag */
    315            ADCIF = 0;
   \   000008   C28D         CLR     0x88.5
    316          
    317            /* Setup the new value for conversion */
    318            ADCCON3 = (HAL_ADC_REF_125V | HAL_ADC_DEC_064 | HAL_ADC_CHN_VDD3);
   \   00000A   75B60F       MOV     0xb6,#0xf
    319          
    320            /* Wait for the conversion to finish */
    321            while ( !ADCIF );
   \                     ??HalAdcCheckVdd_0:
   \   00000D   A28D         MOV     C,0x88.5
   \   00000F   50FC         JNC     ??HalAdcCheckVdd_0
    322          
    323            /* Get the result */
    324            value = ADCL;
   \   000011   AABA         MOV     R2,0xba
    325            value |= ((uint16) ADCH) << 8;
   \   000013   E5BB         MOV     A,0xbb
   \   000015   FB           MOV     R3,A
    326          
    327            // Restore ADCCON3
    328            ADCCON3 = tmpADCCON3;
   \   000016   8EB6         MOV     0xb6,R6
    329            
    330            /* Check the limit and return */
    331            return ( value >= HalAdcVddLimit[limit] );
   \   000018   E9           MOV     A,R1
   \   000019   C3           CLR     C
   \   00001A   33           RLC     A
   \   00001B   F8           MOV     R0,A
   \   00001C   E4           CLR     A
   \   00001D   33           RLC     A
   \   00001E   F9           MOV     R1,A
   \   00001F   E8           MOV     A,R0
   \   000020   24..         ADD     A,#(HalAdcVddLimit & 0xff)
   \   000022   F582         MOV     DPL,A
   \   000024   E9           MOV     A,R1
   \   000025   34..         ADDC    A,#((HalAdcVddLimit >> 8) & 0xff)
   \   000027   F583         MOV     DPH,A
   \   000029   E4           CLR     A
   \   00002A   93           MOVC    A,@A+DPTR
   \   00002B   F8           MOV     R0,A
   \   00002C   7401         MOV     A,#0x1
   \   00002E   93           MOVC    A,@A+DPTR
   \   00002F   F9           MOV     R1,A
   \   000030   C3           CLR     C
   \   000031   EA           MOV     A,R2
   \   000032   98           SUBB    A,R0
   \   000033   EB           MOV     A,R3
   \   000034   99           SUBB    A,R1
   \   000035   4004         JC      ??HalAdcCheckVdd_1
   \   000037   7901         MOV     R1,#0x1
   \   000039   8002         SJMP    ??HalAdcCheckVdd_2
   \                     ??HalAdcCheckVdd_1:
   \   00003B   7900         MOV     R1,#0x0
   \                     ??HalAdcCheckVdd_2:
   \   00003D   7F01         MOV     R7,#0x1
   \   00003F   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000042                REQUIRE _A_TCON
   \   000042                REQUIRE ADCCON3
   \   000042                REQUIRE ADCH
   \   000042                REQUIRE ADCL
    332          }
    333          
    334          /**************************************************************************************************
    335          **************************************************************************************************/
    336          
    337          //-------------------------------------------------------------------
    338          // @fn  adcSampleSingle
    339          // @brief
    340          //     This function makes the adc sample the given channel at the given
    341          //     resolution with the given reference.
    342          // @param uint8 reference
    343          //         The reference to compare the channel to be sampled.
    344          //       uint8 resolution
    345          //         The resolution to use during the sample (8, 10, 12 or 14 bit)
    346          //       uint8 input
    347          //         The channel to be sampled.
    348          // @return int16
    349          //         The conversion result
    350          //-------------------------------------------------------------------

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    351          int16 adcSampleSingle(uint8 reference, uint8 resolution, uint8 channel)
   \                     adcSampleSingle:
    352          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   75..01       MOV     ?V0 + 0,#0x1
   \   000007   75..00       MOV     ?V0 + 1,#0x0
   \   00000A   EB           MOV     A,R3
   \   00000B   78..         MOV     R0,#?V0 + 0
   \   00000D   12....       LCALL   ?S_SHL
   \   000010   AC..         MOV     R4,?V0 + 0
   \   000012   EC           MOV     A,R4
   \   000013   45F2         ORL     A,0xf2
   \   000015   F5F2         MOV     0xf2,A
    353              int16 value;
    354          
    355              ADC_ENABLE_CHANNEL(channel);
    356          
    357              ADCIF = 0;
   \   000017   C28D         CLR     0x88.5
    358              ADC_SINGLE_CONVERSION(reference | resolution | channel);
   \   000019   EA           MOV     A,R2
   \   00001A   49           ORL     A,R1
   \   00001B   4B           ORL     A,R3
   \   00001C   F5B6         MOV     0xb6,A
    359              while (!ADCIF);
   \                     ??adcSampleSingle_0:
   \   00001E   A28D         MOV     C,0x88.5
   \   000020   50FC         JNC     ??adcSampleSingle_0
    360          
    361              value = (ADCH << 8) &0xff00; //ADC[13:6]°ª¦ì¤¸ªº¸ê®Æ
   \   000022   E5BB         MOV     A,0xbb
   \   000024   FB           MOV     R3,A
    362              value |= ADCL;               //ADC[5:0]§C¦ì¤¸ªº¸ê®Æ
   \   000025   E5BA         MOV     A,0xba
   \   000027   FA           MOV     R2,A
    363          
    364              ADC_DISABLE_CHANNEL(channel);
   \   000028   EC           MOV     A,R4
   \   000029   F4           CPL     A
   \   00002A   55F2         ANL     A,0xf2
   \   00002C   F5F2         MOV     0xf2,A
    365              //  The variable 'value' contains 16 bits where
    366              //     bit 15 is a sign bit
    367              //     bit [14 .. 0] contain the absolute sample value
    368              //     Only the r upper bits are significant, where r is the resolution
    369              //     Resolution:
    370              //        12   -> [14 .. 3] (bitmask 0x7FF8)
    371              //        10   -> [14 .. 5] (bitmask 0x7FE0)
    372              //         9   -> [14 .. 6] (bitmask 0x7FC0)
    373              //         7   -> [14 .. 8] (bitmask 0x7F00)
    374              return value;
   \   00002E   D0..         POP     ?V0 + 1
   \   000030   D0..         POP     ?V0 + 0
   \   000032   02....       LJMP    ?BRET
   \   000035                REQUIRE _A_TCON
   \   000035                REQUIRE ADCCON3
   \   000035                REQUIRE ADCH
   \   000035                REQUIRE ADCL
   \   000035                REQUIRE ADCCFG
    375          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcSetReference?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcSetReference

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcCheckVdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcCheckVdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??adcSampleSingle?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    adcSampleSingle

   Maximum stack usage in bytes:

     Function           ISTACK PSTACK XSTACK
     --------           ------ ------ ------
     HalAdcCheckVdd         0      0      9
     HalAdcInit             3      0      1
     HalAdcRead             1      0     11
     HalAdcSetReference     3      0      1
     adcSampleSingle        2      0      0


   Segment part sizes:

     Function/Label             Bytes
     --------------             -----
     _A_TCON                       1
     ADCCON1                       1
     ADCCON2                       1
     ADCCON3                       1
     ADCL                          1
     ADCH                          1
     ADCCFG                        1
     HalAdcVddLimit               18
     HalAdcInit                   41
     ?Subroutine1                 17
     ?Subroutine0                  8
     ??Subroutine2_0               5
     HalAdcRead                  185
     HalAdcSetReference           48
     HalAdcCheckVdd               66
     adcSampleSingle              53
     ??HalAdcInit?relay            6
     ??HalAdcRead?relay            6
     ??HalAdcSetReference?relay    6
     ??HalAdcCheckVdd?relay        6
     ??adcSampleSingle?relay       6

 
 423 bytes in segment BANKED_CODE
  30 bytes in segment BANK_RELAYS
  18 bytes in segment CODE_C
   7 bytes in segment SFR_AN
 
 471 bytes of CODE memory
   0 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none
