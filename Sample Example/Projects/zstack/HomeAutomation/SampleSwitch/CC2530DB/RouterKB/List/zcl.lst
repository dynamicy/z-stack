###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                08/Jun/2010  11:24:09 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3.0- #
#                          1.4.0\ZStack-CC2530-2.3.0-1.4.0\Components\stack\z #
#                          cl\zcl.c                                           #
#    Command line       =  -f "D:\µ{¦¡¶}µo\TI Zigbee                          #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\Tools\CC2530DB\f8wRouter.cfg #
#                          " (-DCPU32MHZ -DROOT=__near_func                   #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE -DRTR_NWK         #
#                          -DBLINK_LEDS) -f "D:\µ{¦¡¶}µo\TI Zigbee            #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg #
#                          " (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR    #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440)   #
#                          -f "D:\µ{¦¡¶}µo\TI Zigbee                          #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"   #
#                          (-DZCL_READ -DZCL_WRITE -DZCL_BASIC                #
#                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH    #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING) -DZCL_MESSAGE "D:\µ{¦¡¶}µo\TI       #
#                          Zigbee Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC #
#                          2530-2.3.0-1.4.0\Components\stack\zcl\zcl.c" -D    #
#                          ZTOOL_P1 -D MT_TASK -D MT_APP_FUNC -D MT_SYS_FUNC  #
#                          -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -lC          #
#                          "D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3.0 #
#                          -1.4.0\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\H #
#                          omeAutomation\SampleSwitch\CC2530DB\RouterKB\List\ #
#                          " -lA "D:\µ{¦¡¶}µo\TI Zigbee                       #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\RouterKB\List\" --diag_suppress       #
#                          Pe001,Pa010 -o "D:\µ{¦¡¶}µo\TI Zigbee              #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\RouterKB\Obj\" -e                     #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\µ{¦¡¶}µo\TI Zigbee     #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\" -I "D:\µ{¦¡¶}µo\TI Zigbee           #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\SOURCE\" -I "D:\µ{¦¡¶}µo\TI        #
#                          Zigbee Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC #
#                          2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\Sa #
#                          mpleSwitch\CC2530DB\..\..\SOURCE\" -I              #
#                          "D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3.0 #
#                          -1.4.0\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\H #
#                          omeAutomation\SampleSwitch\CC2530DB\..\..\..\ZMAIN #
#                          \TI2530DB\" -I "D:\µ{¦¡¶}µo\TI Zigbee              #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I     #
#                          "D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3.0 #
#                          -1.4.0\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\H #
#                          omeAutomation\SampleSwitch\CC2530DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\INCLUDE\" -I "D:\µ{¦¡¶}µo\TI       #
#                          Zigbee Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC #
#                          2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\Sa #
#                          mpleSwitch\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\ #
#                          TARGET\CC2530EB\" -I "D:\µ{¦¡¶}µo\TI Zigbee        #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CC #
#                          SOC\" -I "D:\µ{¦¡¶}µo\TI Zigbee                    #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUD #
#                          E\" -I "D:\µ{¦¡¶}µo\TI Zigbee                      #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\"  #
#                          -I "D:\µ{¦¡¶}µo\TI Zigbee                          #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\" #
#                           -I "D:\µ{¦¡¶}µo\TI Zigbee                         #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\" #
#                           -I "D:\µ{¦¡¶}µo\TI Zigbee                         #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\ #
#                          " -I "D:\µ{¦¡¶}µo\TI Zigbee                        #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\" #
#                           -I "D:\µ{¦¡¶}µo\TI Zigbee                         #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZCL\" #
#                           -I "D:\µ{¦¡¶}µo\TI Zigbee                         #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\" #
#                           -I "D:\µ{¦¡¶}µo\TI Zigbee                         #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\"  #
#                          -I "D:\µ{¦¡¶}µo\TI Zigbee                          #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\" -I   #
#                          "D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3.0 #
#                          -1.4.0\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\H #
#                          omeAutomation\SampleSwitch\CC2530DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SADDR\" -I "D:\µ{¦¡¶}µo\TI    #
#                          Zigbee Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC #
#                          2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\Sa #
#                          mpleSwitch\CC2530DB\..\..\..\..\..\COMPONENTS\SERV #
#                          ICES\SDATA\" -I "D:\µ{¦¡¶}µo\TI Zigbee             #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE #
#                          \" -I "D:\µ{¦¡¶}µo\TI Zigbee                       #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LE #
#                          VEL\" -I "D:\µ{¦¡¶}µo\TI Zigbee                    #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEV #
#                          EL\srf04\" -I "D:\µ{¦¡¶}µo\TI Zigbee               #
#                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\HomeAutomation\SampleSwi #
#                          tch\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEV #
#                          EL\srf04\SINGLE_CHIP\" -I "C:\IAR                  #
#                          Systems\Embedded Workbench 5.3\8051\INC\" -I       #
#                          "C:\IAR Systems\Embedded Workbench                 #
#                          5.3\8051\INC\CLIB\" -Ohz                           #
#    List file          =  D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3.0- #
#                          1.4.0\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Ho #
#                          meAutomation\SampleSwitch\CC2530DB\RouterKB\List\z #
#                          cl.lst                                             #
#    Object file        =  D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3.0- #
#                          1.4.0\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Ho #
#                          meAutomation\SampleSwitch\CC2530DB\RouterKB\Obj\zc #
#                          l.r51                                              #
#                                                                             #
#                                                                             #
###############################################################################

D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2.3.0-1.4.0\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2009-12-22 17:20:57 -0800 (Tue, 22 Dec 2009) $
      4            Revision:       $Revision: 21402 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "OSAL_Tasks.h"
     46          #include "AF.h"
     47          #include "ZDConfig.h"
     48          
     49          #include "zcl.h"
     50          #include "zcl_general.h"
     51          
     52          #if defined ( INTER_PAN )
     53            #include "stub_aps.h"
     54          #endif
     55          
     56          /*********************************************************************
     57           * MACROS
     58           */
     59          /*** Frame Control ***/
     60          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     61          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     62          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     63          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     64          
     65          /*** Attribute Access Control ***/
     66          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     67          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     68          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     69          
     70          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     71          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     72          
     73          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     74                                                  (zclHdr).fc.manuSpecific == 0          && \
     75                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     76          
     77          // Commands that have corresponding responses
     78          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ            || \
     79                                                  (cmd) == ZCL_CMD_WRITE           || \
     80                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED || \
     81                                                  (cmd) == ZCL_CMD_CONFIG_REPORT   || \
     82                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG || \
     83                                                  (cmd) == ZCL_CMD_DISCOVER        || \
     84                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     85          
     86          /*********************************************************************
     87           * CONSTANTS
     88           */
     89          
     90          /*********************************************************************
     91           * TYPEDEFS
     92           */
     93          typedef struct zclLibPlugin
     94          {
     95            struct zclLibPlugin *next;
     96            uint16              startClusterID;    // starting cluster ID
     97            uint16              endClusterID;      // ending cluster ID
     98            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
     99          } zclLibPlugin_t;
    100          
    101          // Attribute record list item
    102          typedef struct zclAttrRecsList
    103          {
    104            struct zclAttrRecsList *next;
    105            uint8                  endpoint;      // Used to link it into the endpoint descriptor
    106            uint8                  numAttributes; // Number of the following records
    107            CONST zclAttrRec_t     *attrs;        // attribute records
    108          } zclAttrRecsList;
    109          
    110          // Cluster option list item
    111          typedef struct zclClusterOptionList
    112          {
    113            struct zclClusterOptionList *next;
    114            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    115            uint8                       numOptions; // Number of the following records
    116            zclOptionRec_t              *options;   // option records
    117          } zclClusterOptionList;
    118          
    119          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    120          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    121          
    122          typedef struct
    123          {
    124            zclParseInProfileCmd_t   pfnParseInProfile;
    125            zclProcessInProfileCmd_t pfnProcessInProfile;
    126          } zclCmdItems_t;
    127          
    128          
    129          /*********************************************************************
    130           * GLOBAL VARIABLES
    131           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    132          uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    133          
    134          // The task Id of the Application where the unprocessed Foundation
    135          // Command/Response messages will be sent to.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    136          uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    137          
    138          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    139          zclValidateAttrData_t zcl_ValidateAttrDataCB = NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    140          
    141          // ZCL Sequence number

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    142          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    143             
    144          /*********************************************************************
    145           * EXTERNAL VARIABLES
    146           */
    147          
    148          /*********************************************************************
    149           * EXTERNAL FUNCTIONS
    150           */
    151          
    152          /*********************************************************************
    153           * LOCAL VARIABLES
    154           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    155          static zclLibPlugin_t *plugins;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    156          static zclAttrRecsList *attrList;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    157          static zclClusterOptionList *clusterOptionList;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    158          static uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    159          
    160          /*********************************************************************
    161           * LOCAL FUNCTIONS
    162           */
    163          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt );  // Not static for ZNP build.
    164          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    165          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    166          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    167          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    168          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    169          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    170          
    171          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    172          
    173          #if defined(ZCL_READ) || defined(ZCL_WRITE) || defined(ZCL_REPORT)
    174          static void zclSerializeData( uint8 dataType, void *attrData, uint8 *buf );
    175          #endif // ZCL_READ || ZCL_WRITE || ZCL_REPORT
    176          
    177          #ifdef ZCL_READ
    178          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    179          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    180          #endif // ZCL_READ
    181          
    182          #ifdef ZCL_WRITE
    183          static uint8 zclWriteAttrData( zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    184          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    185          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    186          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    187          #endif // ZCL_WRITE
    188          
    189          #ifdef ZCL_REPORT
    190          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    191          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    192          #endif // ZCL_REPORT
    193          
    194          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    195          
    196          #ifdef ZCL_DISCOVER
    197          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint16 *attrId, zclAttrRec_t *pAttr );
    198          static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd );
    199          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    200          #endif // ZCL_DISCOVER
    201          
    202          static uint8 zclSendMsg( zclIncoming_t *pInMsg );
    203          
    204          /*********************************************************************
    205           * Parse Profile Command Function Table
    206           */

   \                                 In  segment CODE_C, align 1
    207          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ........     DW ??zclParseInReadCmd?relay, ??zclProcessInReadCmd?relay
   \   000004   ........     DW ??zclParseInReadRspCmd?relay, ??zclSendMsg?relay
   \   000008   ........     DW ??zclParseInWriteCmd?relay, ??zclProcessInWriteCmd?relay
   \   00000C   ........     DW ??zclParseInWriteCmd?relay, ??zclProcessInWriteUndividedCmd?relay
   \   000010   ........     DW ??zclParseInWriteRspCmd?relay, ??zclSendMsg?relay
   \   000014   ........     DW ??zclParseInWriteCmd?relay, ??zclProcessInWriteCmd?relay, 0H, 0H, 0H
   \            00000000
   \            0000    
   \   00001E   00000000     DW 0H, 0H, 0H, 0H, 0H, 0H, 0H, ??zclParseInDefaultRspCmd?relay
   \            00000000
   \            00000000
   \            0000....
   \   00002E   ....0000     DW ??zclSendMsg?relay, 0H, 0H, 0H, 0H
   \            00000000
   \            0000    
    208          {
    209          #ifdef ZCL_READ
    210            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    211            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zclSendMsg                      },
    212          #else
    213            /* ZCL_CMD_READ */                { NULL,                          NULL                            },
    214            /* ZCL_CMD_READ_RSP */            { NULL,                          NULL                            },
    215          #endif // ZCL_READ
    216          
    217          #ifdef ZCL_WRITE
    218            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    219            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    220            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zclSendMsg                      },
    221            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    222          #else
    223            /* ZCL_CMD_WRITE */               { NULL,                          NULL                            },
    224            /* ZCL_CMD_WRITE_UNDIVIDED */     { NULL,                          NULL                            },
    225            /* ZCL_CMD_WRITE_RSP */           { NULL,                          NULL                            },
    226            /* ZCL_CMD_WRITE_NO_RSP */        { NULL,                          NULL                            },
    227          #endif // ZCL_WRITE
    228          
    229          #ifdef ZCL_REPORT
    230            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zclSendMsg                      },
    231            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zclSendMsg                      },
    232            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zclSendMsg                      },
    233            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zclSendMsg                      },
    234            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zclSendMsg                      },
    235          #else
    236            /* ZCL_CMD_CONFIG_REPORT */       { NULL,                          NULL                            },
    237            /* ZCL_CMD_CONFIG_REPORT_RSP */   { NULL,                          NULL                            },
    238            /* ZCL_CMD_READ_REPORT_CFG */     { NULL,                          NULL                            },
    239            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { NULL,                          NULL                            },
    240            /* ZCL_CMD_REPORT */              { NULL,                          NULL                            },
    241          #endif // ZCL_REPORT
    242          
    243            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zclSendMsg                      },
    244            
    245          #ifdef ZCL_DISCOVER  
    246            /* ZCL_CMD_DISCOVER */            { zclParseInDiscCmd,             zclProcessInDiscCmd             },
    247            /* ZCL_CMD_DISCOVER_RSP */        { zclParseInDiscRspCmd,          zclSendMsg                      }
    248          #else
    249            /* ZCL_CMD_DISCOVER */            { NULL,                          NULL                            },
    250            /* ZCL_CMD_DISCOVER_RSP */        { NULL,                          NULL                            }
    251          #endif // ZCL_DISCOVER
    252          };
    253          
    254          /*********************************************************************
    255           * PUBLIC FUNCTIONS
    256           *********************************************************************/
    257          
    258          /*********************************************************************
    259           * @fn          zcl_Init
    260           *
    261           * @brief       Initialization function for the zcl layer.
    262           *
    263           * @param       task_id - ZCL task id
    264           *
    265           * @return      none
    266           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    267          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    268          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    269            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    270          
    271            plugins = (zclLibPlugin_t  *)NULL;
   \   000009   90....       MOV     DPTR,#plugins
   \   00000C   E4           CLR     A
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   A3           INC     DPTR
   \   00000F   F0           MOVX    @DPTR,A
    272            attrList = (zclAttrRecsList *)NULL;
   \   000010   90....       MOV     DPTR,#attrList
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    273            clusterOptionList = (zclClusterOptionList *)NULL;
   \   000016   90....       MOV     DPTR,#clusterOptionList
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
    274          }
   \   00001C   02....       LJMP    ?Subroutine103 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    275          
    276          /*********************************************************************
    277           * @fn          zcl_event_loop
    278           *
    279           * @brief       Event Loop Processor for zcl.
    280           *
    281           * @param       task_id - task id
    282           * @param       events - event bitmap
    283           *
    284           * @return      unprocessed events
    285           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    286          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    287          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
    288            uint8 *msgPtr;
    289          
    290            (void)task_id;  // Intentionally unreferenced parameter
    291            
    292            if ( events & SYS_EVENT_MSG )
   \   000009   7480         MOV     A,#-0x80
   \   00000B   55..         ANL     A,?V0 + 1
   \   00000D   F9           MOV     R1,A
   \   00000E   E4           CLR     A
   \   00000F   7001         JNZ     ??zcl_event_loop_0
   \   000011   E9           MOV     A,R1
   \                     ??zcl_event_loop_0:
   \   000012   604B         JZ      ??zcl_event_loop_1
    293            {
    294              msgPtr = osal_msg_receive( zcl_TaskID );
   \   000014                ; Setup parameters for call to function osal_msg_receive
   \   000014   800E         SJMP    ??zcl_event_loop_2
    295              while ( msgPtr != NULL )
    296              {
    297                uint8 dealloc = TRUE;
    298                
    299                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    300                {
    301                  zclProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_3:
   \   000016                ; Setup parameters for call to function zclProcessMessageMSG
   \   000016   EE           MOV     A,R6
   \   000017   FA           MOV     R2,A
   \   000018   EF           MOV     A,R7
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   ??zclProcessMessageMSG?relay
    302                }
    303                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    304                {
    305                  // send it to another task to process.
    306                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
    307                  dealloc = FALSE;
    308                }
    309            
    310                // Release the memory
    311                if ( dealloc )
    312                {
    313                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_4:
   \   00001D                ; Setup parameters for call to function osal_msg_deallocate
   \   00001D   EE           MOV     A,R6
   \   00001E   FA           MOV     R2,A
   \   00001F   EF           MOV     A,R7
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   ??osal_msg_deallocate?relay
    314                }
    315          
    316                // Next
    317                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_2:
   \   000024                ; Setup parameters for call to function osal_msg_receive
   \   000024   90....       MOV     DPTR,#zcl_TaskID
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F9           MOV     R1,A
   \   000029   12....       LCALL   ??osal_msg_receive?relay
   \   00002C   8A..         MOV     ?V0 + 2,R2
   \   00002E   8B..         MOV     ?V0 + 3,R3
   \   000030   AE..         MOV     R6,?V0 + 2
   \   000032   AF..         MOV     R7,?V0 + 3
   \   000034   EE           MOV     A,R6
   \   000035   7001         JNZ     ??zcl_event_loop_5
   \   000037   EF           MOV     A,R7
   \                     ??zcl_event_loop_5:
   \   000038   601C         JZ      ??zcl_event_loop_6
   \   00003A   8E82         MOV     DPL,R6
   \   00003C   8F83         MOV     DPH,R7
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   641A         XRL     A,#0x1a
   \   000041   60D3         JZ      ??zcl_event_loop_3
   \   000043   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000046   E0           MOVX    A,@DPTR
   \   000047   64FF         XRL     A,#0xff
   \   000049   60D2         JZ      ??zcl_event_loop_4
   \   00004B                ; Setup parameters for call to function osal_msg_send
   \   00004B   EE           MOV     A,R6
   \   00004C   FA           MOV     R2,A
   \   00004D   EF           MOV     A,R7
   \   00004E   FB           MOV     R3,A
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   F9           MOV     R1,A
   \   000051   12....       LCALL   ??osal_msg_send?relay
   \   000054   80CE         SJMP    ??zcl_event_loop_2
    318              }
    319          
    320              // return unprocessed events
    321              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_6:
   \   000056   AA..         MOV     R2,?V0 + 0
   \   000058   7480         MOV     A,#-0x80
   \   00005A   65..         XRL     A,?V0 + 1
   \   00005C   FB           MOV     R3,A
   \   00005D   8004         SJMP    ??zcl_event_loop_7
    322            }
    323          
    324            // Discard unknown events
    325            return 0;
   \                     ??zcl_event_loop_1:
   \   00005F   7A00         MOV     R2,#0x0
   \   000061   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_7:
   \   000063   02....       LJMP    ?Subroutine104 & 0xFFFF
    326          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    327          
    328          /*********************************************************************
    329           * @fn          zcl_registerPlugin
    330           *
    331           * @brief       Add a Cluster Library handler
    332           *
    333           * @param       startClusterID - starting cluster ID
    334           * @param       endClusterID - ending cluster ID
    335           * @param       pfnHdlr - function pointer to incoming message handler
    336           *
    337           * @return      ZSuccess if OK
    338           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    339          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    340                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    341          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
   \   00000D   740E         MOV     A,#0xe
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   12....       LCALL   ?Subroutine39 & 0xFFFF
    342            zclLibPlugin_t *pNewItem;
    343            zclLibPlugin_t *pLoop;
    344          
    345            // Fill in the new profile list
    346            pNewItem = osal_mem_alloc( sizeof( zclLibPlugin_t ) );
   \                     ??CrossCallReturnLabel_46:
   \   000015                ; Setup parameters for call to function osal_mem_alloc
   \   000015   7A08         MOV     R2,#0x8
   \   000017   7B00         MOV     R3,#0x0
   \   000019   12....       LCALL   ??osal_mem_alloc?relay
   \   00001C   8A..         MOV     ?V0 + 4,R2
   \   00001E   8B..         MOV     ?V0 + 5,R3
   \   000020   A8..         MOV     R0,?V0 + 4
   \   000022   A9..         MOV     R1,?V0 + 5
    347            if ( pNewItem == NULL )
   \   000024   E8           MOV     A,R0
   \   000025   7001         JNZ     ??zcl_registerPlugin_0
   \   000027   E9           MOV     A,R1
   \                     ??zcl_registerPlugin_0:
   \   000028   7004         JNZ     ??zcl_registerPlugin_1
    348              return (ZMemError);
   \   00002A   7910         MOV     R1,#0x10
   \   00002C   8051         SJMP    ??CrossCallReturnLabel_14
    349          
    350            // Fill in the plugin record.
    351            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_1:
   \   00002E   8882         MOV     DPL,R0
   \   000030   8983         MOV     DPH,R1
   \   000032   E4           CLR     A
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   12....       LCALL   ?Subroutine14 & 0xFFFF
    352            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_19:
   \   000038   A3           INC     DPTR
   \   000039   E5..         MOV     A,?V0 + 0
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   E5..         MOV     A,?V0 + 1
   \   00003F   12....       LCALL   ?Subroutine14 & 0xFFFF
    353            pNewItem->endClusterID = endClusterID;
   \                     ??CrossCallReturnLabel_20:
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   E5..         MOV     A,?V0 + 2
   \   000047   F0           MOVX    @DPTR,A
   \   000048   A3           INC     DPTR
   \   000049   E5..         MOV     A,?V0 + 3
   \   00004B   F0           MOVX    @DPTR,A
    354            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \   00004C   EE           MOV     A,R6
   \   00004D   FA           MOV     R2,A
   \   00004E   EF           MOV     A,R7
   \   00004F   FB           MOV     R3,A
   \   000050   8882         MOV     DPL,R0
   \   000052   8983         MOV     DPH,R1
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   12....       LCALL   ?Subroutine17 & 0xFFFF
    355          
    356            // Find spot in list
    357            if (  plugins == NULL )
   \                     ??CrossCallReturnLabel_295:
   \   00005B   90....       MOV     DPTR,#plugins
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   7002         JNZ     ??zcl_registerPlugin_2
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \                     ??zcl_registerPlugin_2:
   \   000063   90....       MOV     DPTR,#plugins
   \   000066   6014         JZ      ??zcl_registerPlugin_3
    358            {
    359              plugins = pNewItem;
    360            }
    361            else
    362            {
    363              // Look for end of list
    364              pLoop = plugins;
   \   000068   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   00006B   8003         SJMP    ??zcl_registerPlugin_4
    365              while ( pLoop->next != NULL )
    366                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_5:
   \   00006D   EA           MOV     A,R2
   \   00006E   FC           MOV     R4,A
   \   00006F   EB           MOV     A,R3
   \                     ??zcl_registerPlugin_4:
   \   000070   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   000073   7001         JNZ     ??zcl_registerPlugin_6
   \   000075   EB           MOV     A,R3
   \                     ??zcl_registerPlugin_6:
   \   000076   70F5         JNZ     ??zcl_registerPlugin_5
    367          
    368              // Put new item at end of list
    369              pLoop->next = pNewItem;
   \   000078   8C82         MOV     DPL,R4
   \   00007A   8D83         MOV     DPH,R5
    370            }
   \                     ??zcl_registerPlugin_3:
   \   00007C   12....       LCALL   ?Subroutine11 & 0xFFFF
    371          
    372            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_14:
   \   00007F                REQUIRE ?Subroutine105
   \   00007F                ; // Fall through to label ?Subroutine105
    373          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   FD           MOV     R5,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005                REQUIRE ??Subroutine120_0
   \   000005                ; // Fall through to label ??Subroutine120_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine120_0:
   \   000000   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_269:
   \   000003   EA           MOV     A,R2
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine132_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine147_0
   \   000002                ; // Fall through to label ??Subroutine147_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine147_0:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    374          
    375          /*********************************************************************
    376           * @fn          zcl_registerAttrList
    377           *
    378           * @brief       Register an Attribute List with ZCL Foundation
    379           *
    380           * @param       endpoint - endpoint the attribute list belongs to
    381           * @param       numAttr - number of attributes in list
    382           * @param       newAttrList - array of Attribute records.
    383           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    384           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    385           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    386           *
    387           * @return      ZSuccess if OK
    388           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    389          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    390          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine62 & 0xFFFF
    391            zclAttrRecsList *pNewItem;
    392            zclAttrRecsList *pLoop;
    393          
    394            // Fill in the new profile list
    395            pNewItem = osal_mem_alloc( sizeof( zclAttrRecsList ) );
    396            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_83:
   \   000008   7001         JNZ     ??zcl_registerAttrList_0
   \   00000A   E9           MOV     A,R1
   \                     ??zcl_registerAttrList_0:
   \   00000B   7004         JNZ     ??zcl_registerAttrList_1
    397              return (ZMemError);
   \   00000D   7910         MOV     R1,#0x10
   \   00000F   8027         SJMP    ??CrossCallReturnLabel_15
    398          
    399            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_1:
   \   000011   12....       LCALL   ?Subroutine0 & 0xFFFF
    400            pNewItem->endpoint = endpoint;
    401            pNewItem->numAttributes = numAttr;
    402            pNewItem->attrs = newAttrList;
    403          
    404            // Find spot in list
    405            if ( attrList == NULL )
   \                     ??CrossCallReturnLabel_0:
   \   000014   90....       MOV     DPTR,#attrList
   \   000017   E0           MOVX    A,@DPTR
   \   000018   7002         JNZ     ??zcl_registerAttrList_2
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \                     ??zcl_registerAttrList_2:
   \   00001C   90....       MOV     DPTR,#attrList
   \   00001F   6014         JZ      ??zcl_registerAttrList_3
    406            {
    407              attrList = pNewItem;
    408            }
    409            else
    410            {
    411              // Look for end of list
    412              pLoop = attrList;
   \   000021   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   000024   8003         SJMP    ??zcl_registerAttrList_4
    413              while ( pLoop->next != NULL )
    414                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_5:
   \   000026   EA           MOV     A,R2
   \   000027   FC           MOV     R4,A
   \   000028   EB           MOV     A,R3
   \                     ??zcl_registerAttrList_4:
   \   000029   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   00002C   7001         JNZ     ??zcl_registerAttrList_6
   \   00002E   EB           MOV     A,R3
   \                     ??zcl_registerAttrList_6:
   \   00002F   70F5         JNZ     ??zcl_registerAttrList_5
    415          
    416              // Put new item at end of list
    417              pLoop->next = pNewItem;
   \   000031   8C82         MOV     DPL,R4
   \   000033   8D83         MOV     DPH,R5
    418            }
   \                     ??zcl_registerAttrList_3:
   \   000035   12....       LCALL   ?Subroutine11 & 0xFFFF
    419          
    420            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_15:
   \   000038   02....       LJMP    ?Subroutine104 & 0xFFFF
    421          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   89..         MOV     ?V0 + 0,R1
   \   000002   8A..         MOV     ?V0 + 1,R2
   \   000004   EC           MOV     A,R4
   \   000005   FE           MOV     R6,A
   \   000006   ED           MOV     A,R5
   \   000007   FF           MOV     R7,A
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   7A06         MOV     R2,#0x6
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   ??osal_mem_alloc?relay
   \   00000F   8A..         MOV     ?V0 + 2,R2
   \   000011   8B..         MOV     ?V0 + 3,R3
   \   000013   A8..         MOV     R0,?V0 + 2
   \   000015   A9..         MOV     R1,?V0 + 3
   \   000017   E8           MOV     A,R0
   \   000018   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   00000A   A3           INC     DPTR
   \   00000B   E5..         MOV     A,?V0 + 0
   \   00000D   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000010   E5..         MOV     A,?V0 + 1
   \   000012   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000015   A3           INC     DPTR
   \   000016   EE           MOV     A,R6
   \   000017   F0           MOVX    @DPTR,A
   \   000018   A3           INC     DPTR
   \   000019   EF           MOV     A,R7
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET
    422          
    423          /*********************************************************************
    424           * @fn          zcl_registerClusterOptionList
    425           *
    426           * @brief       Register a Cluster Option List with ZCL Foundation
    427           *
    428           * @param       endpoint - endpoint the option list belongs to
    429           * @param       numOption - number of options in list
    430           * @param       optionList - array of cluster option records.
    431           *                           
    432           *              NOTE: This API should be called to enable 'Application
    433           *                    Link Key' security and/or 'APS ACK' for a specific      
    434           *                    Cluster. The 'Application Link Key' is discarded
    435           *                    if security isn't enabled on the device.
    436           *                    The default behavior is 'Network Key' when security
    437           *                    is enabled and no 'APS ACK' for the ZCL messages.
    438           *
    439           * @return      ZSuccess if OK
    440           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    441          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    442          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine62 & 0xFFFF
    443            zclClusterOptionList *pNewItem;
    444            zclClusterOptionList *pLoop;
    445          
    446            // Fill in the new profile list
    447            pNewItem = osal_mem_alloc( sizeof( zclClusterOptionList ) );
    448            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_84:
   \   000008   7001         JNZ     ??zcl_registerClusterOptionList_0
   \   00000A   E9           MOV     A,R1
   \                     ??zcl_registerClusterOptionList_0:
   \   00000B   7004         JNZ     ??zcl_registerClusterOptionList_1
    449              return (ZMemError);
   \   00000D   7910         MOV     R1,#0x10
   \   00000F   8027         SJMP    ??CrossCallReturnLabel_16
    450          
    451            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_1:
   \   000011   12....       LCALL   ?Subroutine0 & 0xFFFF
    452            pNewItem->endpoint = endpoint;
    453            pNewItem->numOptions = numOption;
    454            pNewItem->options = optionList;
    455          
    456            // Find spot in list
    457            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_1:
   \   000014   90....       MOV     DPTR,#clusterOptionList
   \   000017   E0           MOVX    A,@DPTR
   \   000018   7002         JNZ     ??zcl_registerClusterOptionList_2
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \                     ??zcl_registerClusterOptionList_2:
   \   00001C   90....       MOV     DPTR,#clusterOptionList
   \   00001F   6014         JZ      ??zcl_registerClusterOptionList_3
    458            {
    459              clusterOptionList = pNewItem;
    460            }
    461            else
    462            {
    463              // Look for end of list
    464              pLoop = clusterOptionList;
   \   000021   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_261:
   \   000024   8003         SJMP    ??zcl_registerClusterOptionList_4
    465              while ( pLoop->next != NULL )
    466                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_5:
   \   000026   EA           MOV     A,R2
   \   000027   FC           MOV     R4,A
   \   000028   EB           MOV     A,R3
   \                     ??zcl_registerClusterOptionList_4:
   \   000029   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   00002C   7001         JNZ     ??zcl_registerClusterOptionList_6
   \   00002E   EB           MOV     A,R3
   \                     ??zcl_registerClusterOptionList_6:
   \   00002F   70F5         JNZ     ??zcl_registerClusterOptionList_5
    467          
    468              // Put new item at end of list
    469              pLoop->next = pNewItem;
   \   000031   8C82         MOV     DPL,R4
   \   000033   8D83         MOV     DPH,R5
    470            }
   \                     ??zcl_registerClusterOptionList_3:
   \   000035   12....       LCALL   ?Subroutine11 & 0xFFFF
    471          
    472            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_16:
   \   000038   02....       LJMP    ?Subroutine104 & 0xFFFF
    473          }
    474          
    475          /*********************************************************************
    476           * @fn          zcl_registerValidateAttrData
    477           *
    478           * @brief       Add a validation function for attribute data
    479           *
    480           * @param       pfnValidateAttrData - function pointer to validate routine
    481           *
    482           * @return      ZSuccess if OK
    483           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    484          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    485          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    486            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   12....       LCALL   ??Subroutine147_0 & 0xFFFF
    487            
    488            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_291:
   \   00000A   7900         MOV     R1,#0x0
   \   00000C   80..         SJMP    ?Subroutine103
    489          }
    490          
    491          /*********************************************************************
    492           * @fn      zcl_registerForMsg
    493           *
    494           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    495           *          messages that aren't processed to one task (if a task is
    496           *          registered).
    497           *
    498           * @param   taskId - task Id of the Application where commands will be sent to
    499           *
    500           * @return  TRUE if task registeration successful, FALSE otherwise
    501           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    502          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    503          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    504            // Allow only the first task
    505            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000004   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000007   E0           MOVX    A,@DPTR
   \   000008   64FF         XRL     A,#0xff
   \   00000A   7006         JNZ     ??zcl_registerForMsg_0
    506            {
    507              zcl_RegisteredMsgTaskID = taskId;
   \   00000C   E9           MOV     A,R1
   \   00000D   F0           MOVX    @DPTR,A
    508              
    509              return ( true );
   \   00000E   7901         MOV     R1,#0x1
   \   000010   8002         SJMP    ??zcl_registerForMsg_1
    510            }
    511            
    512            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   000012   7900         MOV     R1,#0x0
   \                     ??zcl_registerForMsg_1:
   \   000014                REQUIRE ?Subroutine103
   \   000014                ; // Fall through to label ?Subroutine103
    513          }
    514          
    515          /*********************************************************************
    516           * @fn      zcl_DeviceOperational
    517           *
    518           * @brief   Used to see whether or not the device can send or respond 
    519           *          to application level commands.
    520           *
    521           * @param   srcEP - source endpoint
    522           * @param   clusterID - cluster ID
    523           * @param   frameType - command type
    524           * @param   cmd - command ID
    525           *
    526           * @return  TRUE if device is operational, FALSE otherwise
    527           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    528          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, 
   \                     zcl_DeviceOperational:
    529                                              uint8 frameType, uint8 cmd, uint16 profileID )
    530          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    531            zclAttrRec_t attrRec;
    532            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000A   7401         MOV     A,#0x1
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   F0           MOVX    @DPTR,A
    533            
    534            (void)profileID;  // Intentionally unreferenced parameter
    535            
    536            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it 
    537            // cannot send or respond to application level commands, other than commands
    538            // to read or write attributes. Note that the Identify cluster cannot be 
    539            // disabled, and remains functional regardless of this setting.
    540            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000013   EC           MOV     A,R4
   \   000014   700A         JNZ     ??zcl_DeviceOperational_0
   \   000016   ED           MOV     A,R5
   \   000017   C3           CLR     C
   \   000018   9406         SUBB    A,#0x6
   \   00001A   5004         JNC     ??zcl_DeviceOperational_0
    541              return ( TRUE );
   \                     ??zcl_DeviceOperational_1:
   \   00001C   7901         MOV     R1,#0x1
   \   00001E   804E         SJMP    ??zcl_DeviceOperational_2
    542            
    543            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   000020   7403         MOV     A,#0x3
   \   000022   6A           XRL     A,R2
   \   000023   7001         JNZ     ??zcl_DeviceOperational_3
   \   000025   EB           MOV     A,R3
   \                     ??zcl_DeviceOperational_3:
   \   000026   60F4         JZ      ??zcl_DeviceOperational_1
    544              return ( TRUE );
    545            
    546            // Is device enabled?
    547            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC, ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000028                ; Setup parameters for call to function zclFindAttrRec
   \   000028   7401         MOV     A,#0x1
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   8582..       MOV     ?V0 + 0,DPL
   \   000030   8583..       MOV     ?V0 + 1,DPH
   \   000033   78..         MOV     R0,#?V0 + 0
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000038   7C12         MOV     R4,#0x12
   \   00003A   7D00         MOV     R5,#0x0
   \   00003C   7A00         MOV     R2,#0x0
   \   00003E   7B00         MOV     R3,#0x0
   \   000040   12....       LCALL   ??zclFindAttrRec?relay
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \   000048   E9           MOV     A,R1
   \   000049   6016         JZ      ??zcl_DeviceOperational_4
    548              zclReadAttrData( &deviceEnabled, &attrRec );
   \   00004B                ; Setup parameters for call to function zclReadAttrData
   \   00004B   7401         MOV     A,#0x1
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   AC82         MOV     R4,DPL
   \   000052   AD83         MOV     R5,DPH
   \   000054   85..82       MOV     DPL,?XSP + 0
   \   000057   85..83       MOV     DPH,?XSP + 1
   \   00005A   AA82         MOV     R2,DPL
   \   00005C   AB83         MOV     R3,DPH
   \   00005E   12....       LCALL   ??zclReadAttrData?relay
    549            
    550            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_4:
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   E0           MOVX    A,@DPTR
   \   000068   6401         XRL     A,#0x1
   \   00006A   60B0         JZ      ??zcl_DeviceOperational_1
   \   00006C   7900         MOV     R1,#0x0
   \                     ??zcl_DeviceOperational_2:
   \   00006E   7409         MOV     A,#0x9
   \   000070   12....       LCALL   ?DEALLOC_XSTACK8
   \   000073   02....       LJMP    ?Subroutine113 & 0xFFFF
    551          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine113:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    552          
    553          /*********************************************************************
    554           * @fn      zcl_SendCommand
    555           *
    556           * @brief   Used to send Profile and Cluster Specific Command messages.
    557           *
    558           *          NOTE: The calling application is responsible for incrementing 
    559           *                the Sequence Number.
    560           *
    561           * @param   srcEp - source endpoint
    562           * @param   destAddr - destination address 
    563           * @param   clusterID - cluster ID
    564           * @param   cmd - command ID
    565           * @param   specific - whether the command is Cluster Specific
    566           * @param   direction - client/server direction of the command
    567           * @param   disableDefaultRsp - disable Default Response command
    568           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    569           * @param   seqNumber - identification number for the transaction
    570           * @param   cmdFormatLen - length of the command to be sent
    571           * @param   cmdFormat - command to be sent
    572           *
    573           * @return  ZSuccess if OK
    574           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    575          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    576                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    577                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    578                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    579          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   \   00000C   8C..         MOV     ?V0 + 0,R4
   \   00000E   8D..         MOV     ?V0 + 1,R5
   \   000010   742A         MOV     A,#0x2a
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FE           MOV     R6,A
   \   000017   742B         MOV     A,#0x2b
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F5..         MOV     ?V0 + 3,A
   \   00001F   742C         MOV     A,#0x2c
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 9,A
   \   000027   742D         MOV     A,#0x2d
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V0 + 8,A
   \   00002F   742E         MOV     A,#0x2e
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F5..         MOV     ?V0 + 12,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0 + 13,A
   \   00003B   7430         MOV     A,#0x30
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   E0           MOVX    A,@DPTR
   \   000041   F5..         MOV     ?V0 + 7,A
   \   000043   7431         MOV     A,#0x31
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F5..         MOV     ?V0 + 14,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F5..         MOV     ?V0 + 15,A
    580            endPointDesc_t *epDesc;
    581            zclFrameHdr_t hdr;
    582            uint8 *msgBuf;
    583            uint16 msgLen;
    584            uint8 *pBuf;
    585            afAddrType_t dstAddr;
    586            uint8 options;
    587            ZStatus_t status;
    588          
    589            osal_memcpy( &dstAddr, destAddr, sizeof ( afAddrType_t ) );
   \   00004F                ; Setup parameters for call to function osal_memcpy
   \   00004F   8A..         MOV     ?V0 + 4,R2
   \   000051   8B..         MOV     ?V0 + 5,R3
   \   000053   75..00       MOV     ?V0 + 6,#0x0
   \   000056   78..         MOV     R0,#?V0 + 4
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00005B   7C0C         MOV     R4,#0xc
   \   00005D   7D00         MOV     R5,#0x0
   \   00005F   7409         MOV     A,#0x9
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   AA82         MOV     R2,DPL
   \   000066   AB83         MOV     R3,DPH
   \   000068   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   00006B   12....       LCALL   ?DEALLOC_XSTACK8
    590          
    591            epDesc = afFindEndPointDesc( srcEP );
   \   00006E                ; Setup parameters for call to function afFindEndPointDesc
   \   00006E   EF           MOV     A,R7
   \   00006F   F9           MOV     R1,A
   \   000070   12....       LCALL   ??afFindEndPointDesc?relay
   \   000073   8A..         MOV     ?V0 + 10,R2
   \   000075   8B..         MOV     ?V0 + 11,R3
    592            if ( epDesc == NULL )
   \   000077   EA           MOV     A,R2
   \   000078   7001         JNZ     ??zcl_SendCommand_0
   \   00007A   EB           MOV     A,R3
   \                     ??zcl_SendCommand_0:
   \   00007B   7005         JNZ     ??zcl_SendCommand_1
    593              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_2:
   \   00007D   7902         MOV     R1,#0x2
   \   00007F   02....       LJMP    ??zcl_SendCommand_3 & 0xFFFF
    594          
    595            if ( clusterID == ZCL_INVALID_CLUSTER_ID )
   \                     ??zcl_SendCommand_1:
   \   000082   74FF         MOV     A,#-0x1
   \   000084   65..         XRL     A,?V0 + 0
   \   000086   7004         JNZ     ??zcl_SendCommand_4
   \   000088   74FF         MOV     A,#-0x1
   \   00008A   65..         XRL     A,?V0 + 1
   \                     ??zcl_SendCommand_4:
   \   00008C   60EF         JZ      ??zcl_SendCommand_2
    596              return ( ZInvalidParameter ); // EMBEDDED RETURN
    597          
    598          #if defined ( INTER_PAN )
    599            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
    600              options = AF_TX_OPTIONS_NONE;
    601            else
    602          #endif
    603              options = zclGetClusterOption( srcEP, clusterID );
   \   00008E                ; Setup parameters for call to function zclGetClusterOption
   \   00008E   AA..         MOV     R2,?V0 + 0
   \   000090   AB..         MOV     R3,?V0 + 1
   \   000092   EF           MOV     A,R7
   \   000093   F9           MOV     R1,A
   \   000094   12....       LCALL   ??zclGetClusterOption?relay
   \   000097   E9           MOV     A,R1
   \   000098   F5..         MOV     ?V0 + 2,A
    604            
    605            osal_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \   00009A                ; Setup parameters for call to function osal_memset
   \   00009A   7C06         MOV     R4,#0x6
   \   00009C   7D00         MOV     R5,#0x0
   \   00009E   7900         MOV     R1,#0x0
   \   0000A0   85..82       MOV     DPL,?XSP + 0
   \   0000A3   85..83       MOV     DPH,?XSP + 1
   \   0000A6   AA82         MOV     R2,DPL
   \   0000A8   AB83         MOV     R3,DPH
   \   0000AA   12....       LCALL   ??osal_memset?relay
    606          
    607            // Not Profile wide command (like READ, WRITE)
    608            if ( specific )
   \   0000AD   E5..         MOV     A,?V0 + 3
   \   0000AF   85..82       MOV     DPL,?XSP + 0
   \   0000B2   85..83       MOV     DPH,?XSP + 1
   \   0000B5   6015         JZ      ??zcl_SendCommand_5
    609              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   54FC         ANL     A,#0xfc
   \   0000BA   F8           MOV     R0,A
   \   0000BB   A3           INC     DPTR
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   F9           MOV     R1,A
   \   0000BE   7401         MOV     A,#0x1
   \   0000C0   48           ORL     A,R0
   \   0000C1   85..82       MOV     DPL,?XSP + 0
   \   0000C4   85..83       MOV     DPH,?XSP + 1
   \   0000C7   F0           MOVX    @DPTR,A
   \   0000C8   A3           INC     DPTR
   \   0000C9   E9           MOV     A,R1
   \   0000CA   8006         SJMP    ??zcl_SendCommand_6
    610            else
    611              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_5:
   \   0000CC   E0           MOVX    A,@DPTR
   \   0000CD   54FC         ANL     A,#0xfc
   \   0000CF   F0           MOVX    @DPTR,A
   \   0000D0   A3           INC     DPTR
   \   0000D1   E0           MOVX    A,@DPTR
   \                     ??zcl_SendCommand_6:
   \   0000D2   F0           MOVX    @DPTR,A
    612          
    613            if ((epDesc->simpleDesc == NULL) ||
    614                (zcl_DeviceOperational(srcEP, clusterID, hdr.fc.type, cmd, epDesc->simpleDesc->AppProfId) == FALSE))
   \   0000D3   85..82       MOV     DPL,?V0 + 10
   \   0000D6   85..83       MOV     DPH,?V0 + 11
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   0000DF   7002         JNZ     ??zcl_SendCommand_7
   \   0000E1   E583         MOV     A,DPH
   \                     ??zcl_SendCommand_7:
   \   0000E3   6020         JZ      ??zcl_SendCommand_8
   \   0000E5                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000E5   A3           INC     DPTR
   \   0000E6   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000E9   EE           MOV     A,R6
   \   0000EA   FD           MOV     R5,A
   \   0000EB   7402         MOV     A,#0x2
   \   0000ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   5403         ANL     A,#0x3
   \   0000F3   FC           MOV     R4,A
   \   0000F4   AA..         MOV     R2,?V0 + 0
   \   0000F6   AB..         MOV     R3,?V0 + 1
   \   0000F8   EF           MOV     A,R7
   \   0000F9   F9           MOV     R1,A
   \   0000FA   12....       LCALL   ??zcl_DeviceOperational?relay
   \   0000FD   7402         MOV     A,#0x2
   \   0000FF   12....       LCALL   ?DEALLOC_XSTACK8
   \   000102   E9           MOV     A,R1
   \   000103   7005         JNZ     ??zcl_SendCommand_9
    615              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_8:
   \   000105   7901         MOV     R1,#0x1
   \   000107   02....       LJMP    ??zcl_SendCommand_3 & 0xFFFF
    616            
    617            // Fill in the Maufacturer Code
    618            if ( manuCode != 0 )
   \                     ??zcl_SendCommand_9:
   \   00010A   E5..         MOV     A,?V0 + 12
   \   00010C   7002         JNZ     ??zcl_SendCommand_10
   \   00010E   E5..         MOV     A,?V0 + 13
   \                     ??zcl_SendCommand_10:
   \   000110   6019         JZ      ??zcl_SendCommand_11
    619            {
    620              hdr.fc.manuSpecific = 1;
   \   000112   85..82       MOV     DPL,?XSP + 0
   \   000115   85..83       MOV     DPH,?XSP + 1
   \   000118   E0           MOVX    A,@DPTR
   \   000119   4404         ORL     A,#0x4
   \   00011B   F0           MOVX    @DPTR,A
   \   00011C   A3           INC     DPTR
   \   00011D   E0           MOVX    A,@DPTR
   \   00011E   F0           MOVX    @DPTR,A
    621              hdr.manuCode = manuCode;
   \   00011F   7402         MOV     A,#0x2
   \   000121   12....       LCALL   ?XSTACK_DISP0_8
   \   000124   E5..         MOV     A,?V0 + 12
   \   000126   F0           MOVX    @DPTR,A
   \   000127   A3           INC     DPTR
   \   000128   E5..         MOV     A,?V0 + 13
   \   00012A   F0           MOVX    @DPTR,A
    622            }
    623            
    624            // Set the Command Direction
    625            if ( direction )
   \                     ??zcl_SendCommand_11:
   \   00012B   E5..         MOV     A,?V0 + 9
   \   00012D   85..82       MOV     DPL,?XSP + 0
   \   000130   85..83       MOV     DPH,?XSP + 1
   \   000133   6005         JZ      ??zcl_SendCommand_12
    626              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000135   E0           MOVX    A,@DPTR
   \   000136   4408         ORL     A,#0x8
   \   000138   8003         SJMP    ??zcl_SendCommand_13
    627            else
    628              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_12:
   \   00013A   E0           MOVX    A,@DPTR
   \   00013B   54F7         ANL     A,#0xf7
   \                     ??zcl_SendCommand_13:
   \   00013D   F0           MOVX    @DPTR,A
   \   00013E   A3           INC     DPTR
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   F0           MOVX    @DPTR,A
    629          
    630            // Set the Disable Default Response field
    631            if ( disableDefaultRsp )
   \   000141   E5..         MOV     A,?V0 + 8
   \   000143   85..82       MOV     DPL,?XSP + 0
   \   000146   85..83       MOV     DPH,?XSP + 1
   \   000149   6005         JZ      ??zcl_SendCommand_14
    632              hdr.fc.disableDefaultRsp = 1;
   \   00014B   E0           MOVX    A,@DPTR
   \   00014C   4410         ORL     A,#0x10
   \   00014E   8003         SJMP    ??zcl_SendCommand_15
    633            else
    634              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_14:
   \   000150   E0           MOVX    A,@DPTR
   \   000151   54EF         ANL     A,#0xef
   \                     ??zcl_SendCommand_15:
   \   000153   F0           MOVX    @DPTR,A
   \   000154   A3           INC     DPTR
   \   000155   E0           MOVX    A,@DPTR
   \   000156   F0           MOVX    @DPTR,A
    635                               
    636            // Fill in the Transaction Sequence Number
    637            hdr.transSeqNum = seqNum;
   \   000157   7404         MOV     A,#0x4
   \   000159   12....       LCALL   ?XSTACK_DISP0_8
   \   00015C   E5..         MOV     A,?V0 + 7
   \   00015E   F0           MOVX    @DPTR,A
    638            
    639            // Fill in the command
    640            hdr.commandID = cmd;
   \   00015F   7405         MOV     A,#0x5
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   EE           MOV     A,R6
   \   000165   F0           MOVX    @DPTR,A
    641            
    642            // calculate the needed buffer size
    643            msgLen = zclCalcHdrSize( &hdr );
   \   000166   75..03       MOV     ?V0 + 4,#0x3
   \   000169   85..82       MOV     DPL,?XSP + 0
   \   00016C   85..83       MOV     DPH,?XSP + 1
   \   00016F   E0           MOVX    A,@DPTR
   \   000170   5404         ANL     A,#0x4
   \   000172   6003         JZ      ??zcl_SendCommand_16
   \   000174   75..05       MOV     ?V0 + 4,#0x5
    644            msgLen += cmdFormatLen;
   \                     ??zcl_SendCommand_16:
   \   000177   E5..         MOV     A,?V0 + 14
   \   000179   25..         ADD     A,?V0 + 4
   \   00017B   F5..         MOV     ?V0 + 12,A
   \   00017D   E5..         MOV     A,?V0 + 15
   \   00017F   3400         ADDC    A,#0x0
   \   000181   F5..         MOV     ?V0 + 13,A
    645          
    646            // Allocate the buffer needed
    647            msgBuf = osal_mem_alloc( msgLen );
   \   000183                ; Setup parameters for call to function osal_mem_alloc
   \   000183   AA..         MOV     R2,?V0 + 12
   \   000185   FB           MOV     R3,A
   \   000186   12....       LCALL   ??osal_mem_alloc?relay
   \   000189   8A..         MOV     ?V0 + 8,R2
   \   00018B   8B..         MOV     ?V0 + 9,R3
    648            if ( msgBuf != NULL )
   \   00018D   EA           MOV     A,R2
   \   00018E   7001         JNZ     ??zcl_SendCommand_17
   \   000190   EB           MOV     A,R3
   \                     ??zcl_SendCommand_17:
   \   000191   606B         JZ      ??zcl_SendCommand_18
    649            {
    650              // Fill in the ZCL Header
    651              pBuf = zclBuildHdr( &hdr, msgBuf );
    652          
    653              // Fill in the command frame
    654              osal_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   000193                ; Setup parameters for call to function osal_memcpy
   \   000193   7433         MOV     A,#0x33
   \   000195   12....       LCALL   ?XSTACK_DISP0_8
   \   000198   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   00019B   78..         MOV     R0,#?V0 + 4
   \   00019D   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001A0                ; Setup parameters for call to function zclBuildHdr
   \   0001A0   AC..         MOV     R4,?V0 + 8
   \   0001A2   AD..         MOV     R5,?V0 + 9
   \   0001A4   7403         MOV     A,#0x3
   \   0001A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A9   AA82         MOV     R2,DPL
   \   0001AB   AB83         MOV     R3,DPH
   \   0001AD   12....       LCALL   ??zclBuildHdr?relay
   \   0001B0   AC..         MOV     R4,?V0 + 14
   \   0001B2   AD..         MOV     R5,?V0 + 15
   \   0001B4   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   0001B7   12....       LCALL   ?DEALLOC_XSTACK8
    655          
    656              status = AF_DataRequest( &dstAddr, epDesc, clusterID, msgLen, msgBuf, 
    657                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );  
   \   0001BA                ; Setup parameters for call to function AF_DataRequest
   \   0001BA   75..1E       MOV     ?V0 + 3,#0x1e
   \   0001BD   78..         MOV     R0,#?V0 + 3
   \   0001BF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001C2   75....       MOV     ?V0 + 4,#(zcl_TransID & 0xff)
   \   0001C5   75....       MOV     ?V0 + 5,#((zcl_TransID >> 8) & 0xff)
   \   0001C8   78..         MOV     R0,#?V0 + 4
   \   0001CA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001CD   78..         MOV     R0,#?V0 + 8
   \   0001CF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001D2   78..         MOV     R0,#?V0 + 12
   \   0001D4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001D7   78..         MOV     R0,#?V0 + 0
   \   0001D9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DC   A9..         MOV     R1,?V0 + 2
   \   0001DE   AC..         MOV     R4,?V0 + 10
   \   0001E0   AD..         MOV     R5,?V0 + 11
   \   0001E2   740F         MOV     A,#0xf
   \   0001E4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E7   AA82         MOV     R2,DPL
   \   0001E9   AB83         MOV     R3,DPH
   \   0001EB   12....       LCALL   ??AF_DataRequest?relay
   \   0001EE   7409         MOV     A,#0x9
   \   0001F0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001F3   E9           MOV     A,R1
   \   0001F4   FE           MOV     R6,A
    658              osal_mem_free ( msgBuf );
   \   0001F5                ; Setup parameters for call to function osal_mem_free
   \   0001F5   AA..         MOV     R2,?V0 + 8
   \   0001F7   AB..         MOV     R3,?V0 + 9
   \   0001F9   12....       LCALL   ??osal_mem_free?relay
   \   0001FC   8002         SJMP    ??zcl_SendCommand_19
    659            }
    660            else
    661              status = ZMemError;
   \                     ??zcl_SendCommand_18:
   \   0001FE   7E10         MOV     R6,#0x10
    662          
    663            return ( status );
   \                     ??zcl_SendCommand_19:
   \   000200   EE           MOV     A,R6
   \   000201   F9           MOV     R1,A
   \                     ??zcl_SendCommand_3:
   \   000202                REQUIRE ?Subroutine119
   \   000202                ; // Fall through to label ?Subroutine119
    664          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine119:
   \   000000   7412         MOV     A,#0x12
   \   000002   80..         SJMP    ??Subroutine121_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine121_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F10         MOV     R7,#0x10
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   E582         MOV     A,DPL
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine107:
   \   000000   12....       LCALL   ??osal_memcpy?relay
   \   000003   7403         MOV     A,#0x3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   22           RET
    665          
    666          #ifdef ZCL_READ
    667          /*********************************************************************
    668           * @fn      zcl_SendRead
    669           *
    670           * @brief   Send a Read command
    671           *
    672           * @param   srcEP - Application's endpoint
    673           * @param   dstAddr - destination address
    674           * @param   clusterID - cluster ID
    675           * @param   readCmd - read command to be sent
    676           * @param   direction - direction of the command
    677           * @param   seqNum - transaction sequence number
    678           *
    679           * @return  ZSuccess if OK
    680           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    681          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
    682                                  uint16 clusterID, zclReadCmd_t *readCmd,
    683                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    684          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 8,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   8C..         MOV     ?V0 + 0,R4
   \   00000D   8D..         MOV     ?V0 + 1,R5
   \   00000F   7416         MOV     A,#0x16
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F5..         MOV     ?V0 + 9,A
   \   00001D   7419         MOV     A,#0x19
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 12,A
   \   000025   741A         MOV     A,#0x1a
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 13,A
    685            uint8 dataLen;
    686            uint8 *buf;
    687            uint8 *pBuf;
    688            ZStatus_t status;
    689          
    690            dataLen = readCmd->numAttr * 2; // Attribute ID
   \   00002D   85..82       MOV     DPL,?V0 + 4
   \   000030   85..83       MOV     DPH,?V0 + 5
   \   000033   E0           MOVX    A,@DPTR
   \   000034   C3           CLR     C
   \   000035   33           RLC     A
   \   000036   FA           MOV     R2,A
    691          
    692            buf = osal_mem_alloc( dataLen );
   \   000037   8A82         MOV     DPL,R2
   \   000039   8582..       MOV     ?V0 + 6,DPL
   \   00003C   75..00       MOV     ?V0 + 7,#0x0
   \   00003F                ; Setup parameters for call to function osal_mem_alloc
   \   00003F   12....       LCALL   ?Subroutine63 & 0xFFFF
    693            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_85:
   \   000042   7001         JNZ     ??zcl_SendRead_0
   \   000044   EB           MOV     A,R3
   \                     ??zcl_SendRead_0:
   \   000045   7003         JNZ     $+5
   \   000047   02....       LJMP    ??zcl_SendRead_1 & 0xFFFF
    694            {
    695              uint8 i;
    696          
    697              // Load the buffer - serially
    698              pBuf = buf;   
   \   00004A   A8..         MOV     R0,?V0 + 2
   \   00004C   A9..         MOV     R1,?V0 + 3
    699              for (i = 0; i < readCmd->numAttr; i++)
   \   00004E   75..00       MOV     ?V0 + 10,#0x0
   \   000051   801F         SJMP    ??zcl_SendRead_2
    700              {
    701                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_3:
   \   000053   E5..         MOV     A,?V0 + 10
   \   000055   C3           CLR     C
   \   000056   33           RLC     A
   \   000057   FA           MOV     R2,A
   \   000058   E4           CLR     A
   \   000059   33           RLC     A
   \   00005A   FB           MOV     R3,A
   \   00005B   E5..         MOV     A,?V0 + 4
   \   00005D   2A           ADD     A,R2
   \   00005E   F582         MOV     DPL,A
   \   000060   E5..         MOV     A,?V0 + 5
   \   000062   3B           ADDC    A,R3
   \   000063   F583         MOV     DPH,A
   \   000065   A3           INC     DPTR
   \   000066   AA82         MOV     R2,DPL
   \   000068   AB83         MOV     R3,DPH
   \   00006A   12....       LCALL   ?Subroutine41 & 0xFFFF
    702                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   \                     ??CrossCallReturnLabel_158:
   \   00006D   12....       LCALL   ?Subroutine28 & 0xFFFF
    703              }
   \                     ??CrossCallReturnLabel_167:
   \   000070   05..         INC     ?V0 + 10
   \                     ??zcl_SendRead_2:
   \   000072   85..82       MOV     DPL,?V0 + 4
   \   000075   85..83       MOV     DPH,?V0 + 5
   \   000078   E0           MOVX    A,@DPTR
   \   000079   FA           MOV     R2,A
   \   00007A   E5..         MOV     A,?V0 + 10
   \   00007C   C3           CLR     C
   \   00007D   9A           SUBB    A,R2
   \   00007E   40D3         JC      ??zcl_SendRead_3
    704            
    705              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    706                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );  
   \   000080                ; Setup parameters for call to function zcl_SendCommand
   \   000080   78..         MOV     R0,#?V0 + 2
   \   000082   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000085   78..         MOV     R0,#?V0 + 6
   \   000087   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008A   E5..         MOV     A,?V0 + 13
   \   00008C   F5..         MOV     ?V0 + 4,A
   \   00008E   78..         MOV     R0,#?V0 + 4
   \   000090   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000093   75..00       MOV     ?V0 + 4,#0x0
   \   000096   75..00       MOV     ?V0 + 5,#0x0
   \   000099   78..         MOV     R0,#?V0 + 4
   \   00009B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009E   E5..         MOV     A,?V0 + 12
   \   0000A0   F5..         MOV     ?V0 + 4,A
   \   0000A2   78..         MOV     R0,#?V0 + 4
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A7   E5..         MOV     A,?V0 + 9
   \   0000A9   F5..         MOV     ?V0 + 4,A
   \   0000AB   78..         MOV     R0,#?V0 + 4
   \   0000AD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B0   75..00       MOV     ?V0 + 4,#0x0
   \   0000B3   78..         MOV     R0,#?V0 + 4
   \   0000B5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B8   78..         MOV     R0,#?V0 + 4
   \   0000BA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BD   AC..         MOV     R4,?V0 + 0
   \   0000BF   AD..         MOV     R5,?V0 + 1
   \   0000C1   EE           MOV     A,R6
   \   0000C2   FA           MOV     R2,A
   \   0000C3   EF           MOV     A,R7
   \   0000C4   FB           MOV     R3,A
   \   0000C5   A9..         MOV     R1,?V0 + 8
   \   0000C7   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   0000CA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CD   E9           MOV     A,R1
   \   0000CE   FE           MOV     R6,A
    707              osal_mem_free( buf );
   \   0000CF                ; Setup parameters for call to function osal_mem_free
   \   0000CF   AA..         MOV     R2,?V0 + 2
   \   0000D1   AB..         MOV     R3,?V0 + 3
   \   0000D3   12....       LCALL   ??osal_mem_free?relay
   \   0000D6   8002         SJMP    ??zcl_SendRead_4
    708            }
    709            else
    710              status = ZMemError;
   \                     ??zcl_SendRead_1:
   \   0000D8   7E10         MOV     R6,#0x10
    711          
    712            return ( status );
   \                     ??zcl_SendRead_4:
   \   0000DA                REQUIRE ?Subroutine115
   \   0000DA                ; // Fall through to label ?Subroutine115
    713          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine115:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002                REQUIRE ??Subroutine122_0
   \   000002                ; // Fall through to label ??Subroutine122_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine122_0:
   \   000000   7F0E         MOV     R7,#0xe
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005                REQUIRE ??Subroutine123_0
   \   000005                ; // Fall through to label ??Subroutine123_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine123_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   08           INC     R0
   \   000008   A983         MOV     R1,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine110:
   \   000000   A882         MOV     R0,DPL
   \   000002   A983         MOV     R1,DPH
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   12....       LCALL   ??zcl_SendCommand?relay
   \   000003   740B         MOV     A,#0xb
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   12....       LCALL   ??osal_mem_alloc?relay
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   \   000009   EA           MOV     A,R2
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000003   7418         MOV     A,#0x18
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   02....       LJMP    ?Subroutine110 & 0xFFFF
    714          
    715          /*********************************************************************
    716           * @fn      zcl_SendReadRsp
    717           *
    718           * @brief   Send a Read Response command.
    719           *
    720           * @param   srcEP - Application's endpoint
    721           * @param   dstAddr - destination address
    722           * @param   clusterID - cluster ID
    723           * @param   readRspCmd - read response command to be sent
    724           * @param   direction - direction of the command
    725           * @param   seqNum - transaction sequence number
    726           *
    727           * @return  ZSuccess if OK
    728           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine114:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   7404         MOV     A,#0x4
   \   000004                REQUIRE ??Subroutine121_0
   \   000004                ; // Fall through to label ??Subroutine121_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    729          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
    730                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
    731                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    732          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 10,A
   \   00001E   741F         MOV     A,#0x1f
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 9,A
   \   000026   7420         MOV     A,#0x20
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F5..         MOV     ?V0 + 8,A
    733            uint8 *buf;
    734            uint8 *pBuf;
    735            zclReadRspStatus_t *statusRec;
    736            uint8 len = 0;
   \   00002E   7E00         MOV     R6,#0x0
    737            uint8 i;
    738            ZStatus_t status;
    739            
    740            // calculate the size of the command
    741            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000030   8E..         MOV     ?V0 + 5,R6
   \   000032   8021         SJMP    ??zcl_SendReadRsp_0
    742            {
    743              statusRec = &(readRspCmd->attrList[i]);
   \                     ??zcl_SendReadRsp_1:
   \   000034   E5..         MOV     A,?V0 + 5
   \   000036   75F006       MOV     B,#0x6
   \   000039   12....       LCALL   ?Subroutine72 & 0xFFFF
    744              
    745              len += 2 + 1; // Attribute ID + Status
   \                     ??CrossCallReturnLabel_95:
   \   00003C   0E           INC     R6
   \   00003D   0E           INC     R6
   \   00003E   0E           INC     R6
    746          
    747              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   700F         JNZ     ??zcl_SendReadRsp_2
    748              {
    749                len++; // Attribute Data Type
    750                len += zclGetAttrDataLength( statusRec->dataType, statusRec->data); // Attribute Data
   \   000044                ; Setup parameters for call to function zclGetAttrDataLength
   \   000044   8882         MOV     DPL,R0
   \   000046   8983         MOV     DPH,R1
   \   000048   A3           INC     DPTR
   \   000049   12....       LCALL   ?Subroutine42 & 0xFFFF
    751              }
    752            }
   \                     ??CrossCallReturnLabel_53:
   \   00004C   A3           INC     DPTR
   \   00004D   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   000050   04           INC     A
   \   000051   2E           ADD     A,R6
   \   000052   FE           MOV     R6,A
   \                     ??zcl_SendReadRsp_2:
   \   000053   05..         INC     ?V0 + 5
   \                     ??zcl_SendReadRsp_0:
   \   000055   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000058   40DA         JC      ??zcl_SendReadRsp_1
    753          
    754            buf = osal_mem_alloc( len );
   \   00005A   12....       LCALL   ?Subroutine64 & 0xFFFF
    755            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_87:
   \   00005D   7001         JNZ     ??zcl_SendReadRsp_3
   \   00005F   EB           MOV     A,R3
   \                     ??zcl_SendReadRsp_3:
   \   000060   7003         JNZ     $+5
   \   000062   02....       LJMP    ??zcl_SendReadRsp_4 & 0xFFFF
    756            {
    757              // Load the buffer - serially
    758              pBuf = buf;
   \   000065   AE..         MOV     R6,?V0 + 6
   \   000067   AF..         MOV     R7,?V0 + 7
    759              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000069   75..00       MOV     ?V0 + 5,#0x0
   \   00006C   8028         SJMP    ??zcl_SendReadRsp_5
    760              {
    761                statusRec = &(readRspCmd->attrList[i]);
   \                     ??zcl_SendReadRsp_6:
   \   00006E   E5..         MOV     A,?V0 + 5
   \   000070   75F006       MOV     B,#0x6
   \   000073   12....       LCALL   ?Subroutine1 & 0xFFFF
    762                
    763                *pBuf++ = LO_UINT16( statusRec->attrID );
    764                *pBuf++ = HI_UINT16( statusRec->attrID );
    765                *pBuf++ = statusRec->status;
   \                     ??CrossCallReturnLabel_2:
   \   000076   FA           MOV     R2,A
   \   000077   E9           MOV     A,R1
   \   000078   3400         ADDC    A,#0x0
   \   00007A   FB           MOV     R3,A
   \   00007B   8A82         MOV     DPL,R2
   \   00007D   8B83         MOV     DPH,R3
   \   00007F   12....       LCALL   ?Subroutine98 & 0xFFFF
    766          
    767                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_131:
   \   000082   8A82         MOV     DPL,R2
   \   000084   8B83         MOV     DPH,R3
   \   000086   E0           MOVX    A,@DPTR
   \   000087   700B         JNZ     ??CrossCallReturnLabel_154
    768                {
    769                  *pBuf++ = statusRec->dataType;
   \   000089   E8           MOV     A,R0
   \   00008A   2403         ADD     A,#0x3
   \   00008C   12....       LCALL   ?Subroutine44 & 0xFFFF
    770                  zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
    771                  
    772                  // move pass attribute data
    773                  pBuf += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
    774                }
    775              } // for loop
   \                     ??CrossCallReturnLabel_57:
   \   00008F   2404         ADD     A,#0x4
   \   000091   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   000094   05..         INC     ?V0 + 5
   \                     ??zcl_SendReadRsp_5:
   \   000096   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000099   40D3         JC      ??zcl_SendReadRsp_6
    776          
    777              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE, 
    778                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \   00009B                ; Setup parameters for call to function zcl_SendCommand
   \   00009B   78..         MOV     R0,#?V0 + 6
   \   00009D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A0   78..         MOV     R0,#?V0 + 0
   \   0000A2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A5   E5..         MOV     A,?V0 + 8
   \   0000A7   F5..         MOV     ?V0 + 0,A
   \   0000A9   78..         MOV     R0,#?V0 + 0
   \   0000AB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AE   75..00       MOV     ?V0 + 0,#0x0
   \   0000B1   78..         MOV     R0,#?V0 + 0
   \   0000B3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B6   E5..         MOV     A,?V0 + 9
   \   0000B8   F5..         MOV     ?V0 + 0,A
   \   0000BA   78..         MOV     R0,#?V0 + 0
   \   0000BC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BF   E5..         MOV     A,?V0 + 10
   \   0000C1   F5..         MOV     ?V0 + 0,A
   \   0000C3   78..         MOV     R0,#?V0 + 0
   \   0000C5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C8   75..00       MOV     ?V0 + 0,#0x0
   \   0000CB   78..         MOV     R0,#?V0 + 0
   \   0000CD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D0   75..01       MOV     ?V0 + 0,#0x1
   \   0000D3   78..         MOV     R0,#?V0 + 0
   \   0000D5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D8   740B         MOV     A,#0xb
   \   0000DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DD   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   0000E0   740D         MOV     A,#0xd
   \   0000E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E5   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   0000E8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EB   E9           MOV     A,R1
   \   0000EC   FE           MOV     R6,A
    779              osal_mem_free( buf );
   \   0000ED                ; Setup parameters for call to function osal_mem_free
   \   0000ED   AA..         MOV     R2,?V0 + 6
   \   0000EF   AB..         MOV     R3,?V0 + 7
   \   0000F1   12....       LCALL   ??osal_mem_free?relay
   \   0000F4   8002         SJMP    ??zcl_SendReadRsp_7
    780            }
    781            else
    782              status = ZMemError;
   \                     ??zcl_SendReadRsp_4:
   \   0000F6   7E10         MOV     R6,#0x10
    783          
    784            return ( status );
   \                     ??zcl_SendReadRsp_7:
   \   0000F8   02....       LJMP    ?Subroutine114 & 0xFFFF
    785          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000005   E9           MOV     A,R1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000007                REQUIRE ?Subroutine110
   \   000007                ; // Fall through to label ?Subroutine110

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8582..       MOV     ?V0 + 0,DPL
   \   000005   75..00       MOV     ?V0 + 1,#0x0
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   AA..         MOV     R2,?V0 + 0
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   ??osal_mem_alloc?relay
   \   00000F   8A..         MOV     ?V0 + 6,R2
   \   000011   8B..         MOV     ?V0 + 7,R3
   \   000013   EA           MOV     A,R2
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 3,A
   \   000007   741E         MOV     A,#0x1e
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   F5..         MOV     ?V0 + 12,A
   \   000002   E9           MOV     A,R1
   \   000003   3400         ADDC    A,#0x0
   \   000005   F5..         MOV     ?V0 + 13,A
   \   000007   85..82       MOV     DPL,?V0 + 12
   \   00000A   F583         MOV     DPH,A
   \   00000C   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   0E           INC     R6
   \   000008   AF83         MOV     R7,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FA           MOV     R2,A
   \   000008   E5..         MOV     A,?V0 + 5
   \   00000A   C3           CLR     C
   \   00000B   9A           SUBB    A,R2
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000003   A9..         MOV     R1,?V0 + 4
   \   000005   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   F5..         MOV     ?V0 + 14,A
   \   000002   E9           MOV     A,R1
   \   000003   3400         ADDC    A,#0x0
   \   000005   F5..         MOV     ?V0 + 15,A
   \   000007                ; Setup parameters for call to function zclSerializeData
   \   000007                ; Setup parameters for call to function zclSerializeData
   \   000007   EE           MOV     A,R6
   \   000008   FC           MOV     R4,A
   \   000009   EF           MOV     A,R7
   \   00000A   FD           MOV     R5,A
   \   00000B   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   00000E   12....       LCALL   ??zclSerializeData?relay
   \   000011                ; Setup parameters for call to function zclGetAttrDataLength
   \   000011                ; Setup parameters for call to function zclGetAttrDataLength
   \   000011   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   000014   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000017   E9           MOV     A,R1
   \   000018   F8           MOV     R0,A
   \   000019   EE           MOV     A,R6
   \   00001A   28           ADD     A,R0
   \   00001B   FE           MOV     R6,A
   \   00001C                REQUIRE ?Subroutine109
   \   00001C                ; // Fall through to label ?Subroutine109

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine109:
   \   000000   EF           MOV     A,R7
   \   000001   3400         ADDC    A,#0x0
   \   000003   FF           MOV     R7,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   85..82       MOV     DPL,?V0 + 14
   \   000003   85..83       MOV     DPH,?V0 + 15
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FA           MOV     R2,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FB           MOV     R3,A
   \   00000B   85..82       MOV     DPL,?V0 + 12
   \   00000E   85..83       MOV     DPH,?V0 + 13
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   EC           MOV     A,R4
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   A3           INC     DPTR
   \   00000E   ED           MOV     A,R5
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   89..         MOV     ?V0 + 4,R1
   \   000012   741C         MOV     A,#0x1c
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   8E82         MOV     DPL,R6
   \   000006   8F83         MOV     DPH,R7
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   AE82         MOV     R6,DPL
   \   00000C   AF83         MOV     R7,DPH
   \   00000E   8882         MOV     DPL,R0
   \   000010   8983         MOV     DPH,R1
   \   000012   A3           INC     DPTR
   \   000013   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   000016   2402         ADD     A,#0x2
   \   000018   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine127_0:
   \   000000   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000003   FD           MOV     R5,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine132_0
   \   000003                ; // Fall through to label ??Subroutine132_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   E5..         MOV     A,?V0 + 2
   \   000002   28           ADD     A,R0
   \   000003   F582         MOV     DPL,A
   \   000005   E5..         MOV     A,?V0 + 3
   \   000007   39           ADDC    A,R1
   \   000008   F583         MOV     DPH,A
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET
    786          #endif // ZCL_READ
    787          
    788          #ifdef ZCL_WRITE
    789          /*********************************************************************
    790           * @fn      sendWriteRequest
    791           *
    792           * @brief   Send a Write command
    793           *
    794           * @param   dstAddr - destination address
    795           * @param   clusterID - cluster ID
    796           * @param   writeCmd - write command to be sent
    797           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
    798           * @param   direction - direction of the command
    799           * @param   seqNum - transaction sequence number
    800           *
    801           * @return  ZSuccess if OK
    802           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    803          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID, 
   \                     zcl_SendWriteRequest:
    804                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction, 
    805                                          uint8 disableDefaultRsp, uint8 seqNum )
    806          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 11,A
   \   00001E   741F         MOV     A,#0x1f
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 10,A
   \   000026   7420         MOV     A,#0x20
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F5..         MOV     ?V0 + 9,A
   \   00002E   7421         MOV     A,#0x21
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F5..         MOV     ?V0 + 8,A
    807            uint8 *buf;
    808            uint8 *pBuf;
    809            zclWriteRec_t *statusRec;
    810            uint8 attrDataLen;
    811            uint8 dataLen = 0;
   \   000036   7E00         MOV     R6,#0x0
    812            uint8 i;
    813            ZStatus_t status;
    814            
    815            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000038   8E..         MOV     ?V0 + 5,R6
   \   00003A   8014         SJMP    ??zcl_SendWriteRequest_0
    816            {
    817              statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_1:
   \   00003C   E5..         MOV     A,?V0 + 5
   \   00003E   75F005       MOV     B,#0x5
   \   000041   12....       LCALL   ?Subroutine72 & 0xFFFF
    818              
    819              attrDataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
    820              dataLen += 2 + 1 + attrDataLen; // Attribute ID + Attribute Type + Attribute Data
   \                     ??CrossCallReturnLabel_96:
   \   000044                ; Setup parameters for call to function zclGetAttrDataLength
   \   000044   12....       LCALL   ?Subroutine42 & 0xFFFF
    821            }
   \                     ??CrossCallReturnLabel_54:
   \   000047   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   00004A   2403         ADD     A,#0x3
   \   00004C   2E           ADD     A,R6
   \   00004D   FE           MOV     R6,A
   \   00004E   05..         INC     ?V0 + 5
   \                     ??zcl_SendWriteRequest_0:
   \   000050   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000053   40E7         JC      ??zcl_SendWriteRequest_1
    822          
    823            buf = osal_mem_alloc( dataLen );
   \   000055   12....       LCALL   ?Subroutine64 & 0xFFFF
    824            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_88:
   \   000058   7001         JNZ     ??zcl_SendWriteRequest_2
   \   00005A   EB           MOV     A,R3
   \                     ??zcl_SendWriteRequest_2:
   \   00005B   607C         JZ      ??zcl_SendWriteRequest_3
    825            {
    826              // Load the buffer - serially
    827              pBuf = buf;
   \   00005D   AE..         MOV     R6,?V0 + 6
   \   00005F   AF..         MOV     R7,?V0 + 7
    828              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000061   75..00       MOV     ?V0 + 5,#0x0
   \   000064   8012         SJMP    ??zcl_SendWriteRequest_4
    829              { 
    830                statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_5:
   \   000066   E5..         MOV     A,?V0 + 5
   \   000068   75F005       MOV     B,#0x5
   \   00006B   12....       LCALL   ?Subroutine1 & 0xFFFF
    831                
    832                *pBuf++ = LO_UINT16( statusRec->attrID );
    833                *pBuf++ = HI_UINT16( statusRec->attrID );
    834                *pBuf++ = statusRec->dataType;
    835                
    836                zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
    837                
    838                attrDataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
    839                pBuf += attrDataLen; // move pass attribute data
    840              }
   \                     ??CrossCallReturnLabel_3:
   \   00006E   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000071   2403         ADD     A,#0x3
   \   000073   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   000076   05..         INC     ?V0 + 5
   \                     ??zcl_SendWriteRequest_4:
   \   000078   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   00007B   40E9         JC      ??zcl_SendWriteRequest_5
    841          
    842              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE, 
    843                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00007D                ; Setup parameters for call to function zcl_SendCommand
   \   00007D   78..         MOV     R0,#?V0 + 6
   \   00007F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000082   78..         MOV     R0,#?V0 + 0
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000087   E5..         MOV     A,?V0 + 8
   \   000089   F5..         MOV     ?V0 + 0,A
   \   00008B   78..         MOV     R0,#?V0 + 0
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000090   75..00       MOV     ?V0 + 0,#0x0
   \   000093   78..         MOV     R0,#?V0 + 0
   \   000095   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000098   E5..         MOV     A,?V0 + 9
   \   00009A   F5..         MOV     ?V0 + 0,A
   \   00009C   78..         MOV     R0,#?V0 + 0
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A1   E5..         MOV     A,?V0 + 10
   \   0000A3   F5..         MOV     ?V0 + 0,A
   \   0000A5   78..         MOV     R0,#?V0 + 0
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AA   75..00       MOV     ?V0 + 0,#0x0
   \   0000AD   78..         MOV     R0,#?V0 + 0
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B2   E5..         MOV     A,?V0 + 11
   \   0000B4   F5..         MOV     ?V0 + 0,A
   \   0000B6   78..         MOV     R0,#?V0 + 0
   \   0000B8   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BB   740B         MOV     A,#0xb
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   0000C3   740D         MOV     A,#0xd
   \   0000C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C8   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   0000CB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CE   E9           MOV     A,R1
   \   0000CF   FE           MOV     R6,A
    844              osal_mem_free( buf );
   \   0000D0                ; Setup parameters for call to function osal_mem_free
   \   0000D0   AA..         MOV     R2,?V0 + 6
   \   0000D2   AB..         MOV     R3,?V0 + 7
   \   0000D4   12....       LCALL   ??osal_mem_free?relay
   \   0000D7   8002         SJMP    ??zcl_SendWriteRequest_6
    845            }
    846            else
    847              status = ZMemError;
   \                     ??zcl_SendWriteRequest_3:
   \   0000D9   7E10         MOV     R6,#0x10
    848          
    849            return ( status);
   \                     ??zcl_SendWriteRequest_6:
   \   0000DB   02....       LJMP    ?Subroutine114 & 0xFFFF
    850          }
    851          
    852          /*********************************************************************
    853           * @fn      zcl_SendWriteRsp
    854           *
    855           * @brief   Send a Write Response command
    856           *
    857           * @param   dstAddr - destination address
    858           * @param   clusterID - cluster ID
    859           * @param   wrtieRspCmd - write response command to be sent
    860           * @param   direction - direction of the command
    861           * @param   seqNum - transaction sequence number
    862           *
    863           * @return  ZSuccess if OK
    864           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    865          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
    866                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
    867                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    868          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 6,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   8C..         MOV     ?V0 + 0,R4
   \   00000D   8D..         MOV     ?V0 + 1,R5
   \   00000F   7416         MOV     A,#0x16
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F5..         MOV     ?V0 + 7,A
   \   00001D   7419         MOV     A,#0x19
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 10,A
   \   000025   741A         MOV     A,#0x1a
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 11,A
    869            uint8 dataLen;
    870            uint8 *buf;
    871            uint8 *pBuf;
    872            uint8 i;
    873            ZStatus_t status;
    874            
    875            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   \   00002D   75F003       MOV     B,#0x3
   \   000030   85..82       MOV     DPL,?V0 + 4
   \   000033   85..83       MOV     DPH,?V0 + 5
   \   000036   E0           MOVX    A,@DPTR
   \   000037   A4           MUL     AB
   \   000038   F5..         MOV     ?V0 + 12,A
    876          
    877            buf = osal_mem_alloc( dataLen );
   \   00003A                ; Setup parameters for call to function osal_mem_alloc
   \   00003A   FA           MOV     R2,A
   \   00003B   12....       LCALL   ?Subroutine63 & 0xFFFF
    878            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_86:
   \   00003E   7001         JNZ     ??zcl_SendWriteRsp_0
   \   000040   EB           MOV     A,R3
   \                     ??zcl_SendWriteRsp_0:
   \   000041   7003         JNZ     $+5
   \   000043   02....       LJMP    ??zcl_SendWriteRsp_1 & 0xFFFF
    879            {
    880              // Load the buffer - serially
    881              pBuf = buf;
   \   000046   A8..         MOV     R0,?V0 + 2
   \   000048   A9..         MOV     R1,?V0 + 3
    882              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   00004A   75..00       MOV     ?V0 + 8,#0x0
   \   00004D   802E         SJMP    ??zcl_SendWriteRsp_2
    883              { 
    884                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_3:
   \   00004F   E5..         MOV     A,?V0 + 8
   \   000051   75F003       MOV     B,#0x3
   \   000054   A4           MUL     AB
   \   000055   FA           MOV     R2,A
   \   000056   ABF0         MOV     R3,B
   \   000058   E5..         MOV     A,?V0 + 4
   \   00005A   2A           ADD     A,R2
   \   00005B   FA           MOV     R2,A
   \   00005C   E5..         MOV     A,?V0 + 5
   \   00005E   3B           ADDC    A,R3
   \   00005F   FB           MOV     R3,A
   \   000060   8A82         MOV     DPL,R2
   \   000062   8B83         MOV     DPH,R3
   \   000064   A3           INC     DPTR
   \   000065   12....       LCALL   ?Subroutine41 & 0xFFFF
    885                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_159:
   \   000068   EA           MOV     A,R2
   \   000069   2402         ADD     A,#0x2
   \   00006B   0A           INC     R2
   \   00006C   0A           INC     R2
   \   00006D   EB           MOV     A,R3
   \   00006E   3400         ADDC    A,#0x0
   \   000070   FB           MOV     R3,A
   \   000071   8A82         MOV     DPL,R2
   \   000073   8B83         MOV     DPH,R3
   \   000075   12....       LCALL   ??Subroutine123_0 & 0xFFFF
    886                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_166:
   \   000078   12....       LCALL   ?Subroutine28 & 0xFFFF
    887              }
   \                     ??CrossCallReturnLabel_168:
   \   00007B   05..         INC     ?V0 + 8
   \                     ??zcl_SendWriteRsp_2:
   \   00007D   85..82       MOV     DPL,?V0 + 4
   \   000080   85..83       MOV     DPH,?V0 + 5
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FA           MOV     R2,A
   \   000085   E5..         MOV     A,?V0 + 8
   \   000087   C3           CLR     C
   \   000088   9A           SUBB    A,R2
   \   000089   40C4         JC      ??zcl_SendWriteRsp_3
    888              
    889              // If there's only a single status record and its status field is set to 
    890              // SUCCESS then omit the attribute ID field.
    891              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   6401         XRL     A,#0x1
   \   00008E   7007         JNZ     ??zcl_SendWriteRsp_4
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   7003         JNZ     ??zcl_SendWriteRsp_4
    892                dataLen = 1;
   \   000094   75..01       MOV     ?V0 + 12,#0x1
    893                
    894              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
    895                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_4:
   \   000097                ; Setup parameters for call to function zcl_SendCommand
   \   000097   78..         MOV     R0,#?V0 + 2
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   75..00       MOV     ?V0 + 13,#0x0
   \   00009F   78..         MOV     R0,#?V0 + 12
   \   0000A1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A4   E5..         MOV     A,?V0 + 11
   \   0000A6   F5..         MOV     ?V0 + 4,A
   \   0000A8   78..         MOV     R0,#?V0 + 4
   \   0000AA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AD   75..00       MOV     ?V0 + 4,#0x0
   \   0000B0   75..00       MOV     ?V0 + 5,#0x0
   \   0000B3   78..         MOV     R0,#?V0 + 4
   \   0000B5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B8   E5..         MOV     A,?V0 + 10
   \   0000BA   F5..         MOV     ?V0 + 4,A
   \   0000BC   78..         MOV     R0,#?V0 + 4
   \   0000BE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C1   E5..         MOV     A,?V0 + 7
   \   0000C3   F5..         MOV     ?V0 + 4,A
   \   0000C5   78..         MOV     R0,#?V0 + 4
   \   0000C7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CA   75..00       MOV     ?V0 + 4,#0x0
   \   0000CD   78..         MOV     R0,#?V0 + 4
   \   0000CF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D2   75..04       MOV     ?V0 + 4,#0x4
   \   0000D5   78..         MOV     R0,#?V0 + 4
   \   0000D7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000DA   AC..         MOV     R4,?V0 + 0
   \   0000DC   AD..         MOV     R5,?V0 + 1
   \   0000DE   EE           MOV     A,R6
   \   0000DF   FA           MOV     R2,A
   \   0000E0   EF           MOV     A,R7
   \   0000E1   FB           MOV     R3,A
   \   0000E2   A9..         MOV     R1,?V0 + 6
   \   0000E4   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   0000E7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EA   E9           MOV     A,R1
   \   0000EB   FE           MOV     R6,A
    896              osal_mem_free( buf );
   \   0000EC                ; Setup parameters for call to function osal_mem_free
   \   0000EC   AA..         MOV     R2,?V0 + 2
   \   0000EE   AB..         MOV     R3,?V0 + 3
   \   0000F0   12....       LCALL   ??osal_mem_free?relay
   \   0000F3   8002         SJMP    ??zcl_SendWriteRsp_5
    897            }
    898            else
    899              status = ZMemError;
   \                     ??zcl_SendWriteRsp_1:
   \   0000F5   7E10         MOV     R6,#0x10
    900          
    901            return ( status );
   \                     ??zcl_SendWriteRsp_5:
   \   0000F7   02....       LJMP    ?Subroutine115 & 0xFFFF
    902          }
    903          #endif // ZCL_WRITE
    904          
    905          #ifdef ZCL_REPORT
    906          /*********************************************************************
    907           * @fn      zcl_SendConfigReportCmd
    908           *
    909           * @brief   Send a Configure Reporting command
    910           *
    911           * @param   dstAddr - destination address
    912           * @param   clusterID - cluster ID
    913           * @param   cfgReportCmd - configure reporting command to be sent
    914           * @param   direction - direction of the command
    915           * @param   seqNum - transaction sequence number
    916           *
    917           * @return  ZSuccess if OK
    918           */
    919          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
    920                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
    921                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    922          {
    923            uint8 *buf;
    924            uint8 *pBuf;
    925            uint8 dataLen = 0;
    926            zclCfgReportRec_t *reportRec;
    927            uint8 reportChangeLen; // length of Reportable Change field
    928            uint8 i;
    929            ZStatus_t status;
    930            
    931            // Find out the data length
    932            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
    933            {
    934              reportRec = &(cfgReportCmd->attrList[i]);
    935              
    936              dataLen += 1 + 2; // Direction + Attribute ID
    937              reportChangeLen = 0;
    938              
    939              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
    940              {
    941                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
    942                
    943                // Find out the size of the Reportable Change field (for Analog data types)
    944                if ( zclAnalogDataType( reportRec->dataType ) )
    945                {
    946                  reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
    947                  dataLen += reportChangeLen;
    948                }
    949              }
    950              else
    951              {
    952                dataLen += 2; // Timeout Period
    953              }
    954            }
    955            
    956            buf = osal_mem_alloc( dataLen );
    957            if ( buf != NULL )
    958            {
    959              // Load the buffer - serially
    960              pBuf = buf;
    961              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
    962              {
    963                reportRec = &(cfgReportCmd->attrList[i]);
    964                
    965                *pBuf++ = reportRec->direction;
    966                *pBuf++ = LO_UINT16( reportRec->attrID );
    967                *pBuf++ = HI_UINT16( reportRec->attrID );
    968                
    969                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
    970                {
    971                  *pBuf++ = reportRec->dataType;
    972                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
    973                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
    974                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
    975                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
    976          
    977                  if ( zclAnalogDataType( reportRec->dataType ) )
    978                  {
    979                    zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
    980                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
    981                    pBuf += reportChangeLen;
    982                  }
    983                }
    984                else
    985                {
    986                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
    987                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
    988                } 
    989              } // for loop
    990              
    991              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE, 
    992                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
    993              osal_mem_free( buf );
    994            }
    995            else
    996              status = ZMemError;
    997            
    998            return ( status );
    999          }
   1000          
   1001          /*********************************************************************
   1002           * @fn      zcl_SendConfigReportRspCmd
   1003           *
   1004           * @brief   Send a Configure Reporting Response command
   1005           *
   1006           * @param   dstAddr - destination address
   1007           * @param   clusterID - cluster ID
   1008           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1009           * @param   direction - direction of the command
   1010           * @param   seqNum - transaction sequence number
   1011           *
   1012           * @return  ZSuccess if OK
   1013           */
   1014          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1015                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1016                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1017          {
   1018            uint8 dataLen;
   1019            uint8 *buf;
   1020            uint8 *pBuf;
   1021            uint8 i;
   1022            ZStatus_t status;
   1023            
   1024            // Atrribute list (Status, Direction and Attribute ID)
   1025            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 ); 
   1026            
   1027            buf = osal_mem_alloc( dataLen );
   1028            if ( buf != NULL )
   1029            {
   1030              // Load the buffer - serially
   1031              pBuf = buf; 
   1032              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   1033              {
   1034                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   1035                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   1036                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1037                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1038              }
   1039              
   1040              // If there's only a single status record and its status field is set to 
   1041              // SUCCESS then omit the attribute ID field.
   1042              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   1043                dataLen = 1;
   1044              
   1045              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1046                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction, 
   1047                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   1048              osal_mem_free( buf );
   1049            }
   1050            else
   1051              status = ZMemError;
   1052            
   1053            return ( status );
   1054          }
   1055          
   1056          /*********************************************************************
   1057           * @fn      zcl_SendReadReportCfgCmd
   1058           *
   1059           * @brief   Send a Read Reporting Configuration command
   1060           *
   1061           * @param   dstAddr - destination address
   1062           * @param   clusterID - cluster ID
   1063           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1064           * @param   direction - direction of the command
   1065           * @param   seqNum - transaction sequence number
   1066           *
   1067           * @return  ZSuccess if OK
   1068           */
   1069          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1070                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1071                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1072          {
   1073            uint8 dataLen;
   1074            uint8 *buf;
   1075            uint8 *pBuf;
   1076            uint8 i;
   1077            ZStatus_t status;
   1078           
   1079            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1080            
   1081            buf = osal_mem_alloc( dataLen );
   1082            if ( buf != NULL )
   1083            {
   1084              // Load the buffer - serially
   1085              pBuf = buf;
   1086              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   1087              {
   1088                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   1089                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1090                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1091              }
   1092              
   1093              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE, 
   1094                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1095              osal_mem_free( buf );
   1096            }
   1097            else
   1098              status = ZMemError;
   1099            
   1100            return ( status );
   1101          }
   1102          
   1103          /*********************************************************************
   1104           * @fn      zcl_SendReadReportCfgRspCmd
   1105           *
   1106           * @brief   Send a Read Reporting Configuration Response command
   1107           *
   1108           * @param   dstAddr - destination address
   1109           * @param   clusterID - cluster ID
   1110           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1111           * @param   direction - direction of the command
   1112           * @param   seqNum - transaction sequence number
   1113           *
   1114           * @return  ZSuccess if OK
   1115           */
   1116          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1117                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1118                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1119          {
   1120            uint8 *buf;
   1121            uint8 *pBuf;
   1122            uint8 dataLen = 0;
   1123            zclReportCfgRspRec_t *reportRspRec;
   1124            uint8 reportChangeLen;
   1125            uint8 i;
   1126            ZStatus_t status;
   1127          
   1128            // Find out the data length
   1129            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1130            {
   1131              reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1132              
   1133              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1134              
   1135              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1136              {
   1137                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1138                {
   1139                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1140                
   1141                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1142                  {
   1143                    reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   1144                    dataLen += reportChangeLen; // Reportable Change field
   1145                  }
   1146                }
   1147                else
   1148                {
   1149                  dataLen += 2; // Timeout Period
   1150                }
   1151              }
   1152            }
   1153            
   1154            buf = osal_mem_alloc( dataLen );
   1155            if ( buf != NULL )
   1156            {
   1157              // Load the buffer - serially
   1158              pBuf = buf;
   1159          
   1160              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1161              {
   1162                reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1163          
   1164                *pBuf++ = reportRspRec->status;
   1165                *pBuf++ = reportRspRec->direction;
   1166                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1167                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1168               
   1169                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1170                {
   1171                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1172                  {
   1173                    *pBuf++ = reportRspRec->dataType;
   1174                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1175                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1176                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1177                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1178          
   1179                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1180                    {
   1181                      zclSerializeData( reportRspRec->dataType, 
   1182                                        reportRspRec->reportableChange, pBuf );
   1183                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   1184                      pBuf += reportChangeLen;
   1185                    }
   1186                  }
   1187                  else
   1188                  {
   1189                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   1190                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1191                  }
   1192                }
   1193              }
   1194             
   1195              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1196                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1197                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1198              osal_mem_free( buf );
   1199            }
   1200            else
   1201              status = ZMemError;
   1202            
   1203            return ( status );
   1204          }
   1205          
   1206          /*********************************************************************
   1207           * @fn      zcl_SendReportCmd
   1208           *
   1209           * @brief   Send a Report command
   1210           *
   1211           * @param   dstAddr - destination address
   1212           * @param   clusterID - cluster ID
   1213           * @param   reportCmd - report command to be sent
   1214           * @param   direction - direction of the command
   1215           * @param   seqNum - transaction sequence number
   1216           *
   1217           * @return  ZSuccess if OK
   1218           */
   1219          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1220                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1221                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1222          {
   1223            zclReport_t *reportRec;
   1224            uint8 attrDataLen;
   1225            uint8 dataLen = 0;
   1226            uint8 *buf;
   1227            uint8 *pBuf;
   1228            uint8 i;
   1229            ZStatus_t status;
   1230            
   1231            // calculate the size of the command
   1232            for ( i = 0; i < reportCmd->numAttr; i++ )
   1233            {
   1234              reportRec = &(reportCmd->attrList[i]);
   1235              
   1236              dataLen += 2 + 1; // Attribute ID + data type
   1237          
   1238              attrDataLen = zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1239              dataLen += attrDataLen; // Attribute Data
   1240            }
   1241            
   1242            buf = osal_mem_alloc( dataLen );
   1243            if ( buf != NULL )
   1244            {
   1245              // Load the buffer - serially
   1246              pBuf = buf;
   1247              for ( i = 0; i < reportCmd->numAttr; i++ )
   1248              {
   1249                reportRec = &(reportCmd->attrList[i]);
   1250                
   1251                *pBuf++ = LO_UINT16( reportRec->attrID );
   1252                *pBuf++ = HI_UINT16( reportRec->attrID );
   1253                *pBuf++ = reportRec->dataType;
   1254          
   1255                zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1256                attrDataLen = zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1257                pBuf += attrDataLen; // move pass attribute data
   1258              }
   1259           
   1260              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE, 
   1261                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1262              osal_mem_free( buf );
   1263            }
   1264            else
   1265              status = ZMemError;
   1266            
   1267            return ( status );
   1268          }
   1269          #endif // ZCL_REPORT
   1270                 
   1271          /*********************************************************************
   1272           * @fn      zcl_SendDefaultRspCmd
   1273           *
   1274           * @brief   Send a Default Response command
   1275           *
   1276           *          Note: The manufacturer code field should be set if this 
   1277           *          command is being sent in response to a manufacturer specific
   1278           *          command.
   1279           *
   1280           * @param   dstAddr - destination address
   1281           * @param   clusterID - cluster ID
   1282           * @param   defaultRspCmd - default response command to be sent
   1283           * @param   direction - direction of the command
   1284           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1285           * @param   seqNum - transaction sequence number
   1286           *
   1287           * @return  ZSuccess if OK
   1288           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1289          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1290                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1291                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1292          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   7410         MOV     A,#0x10
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000014   7412         MOV     A,#0x12
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FF           MOV     R7,A
   \   00001B   7413         MOV     A,#0x13
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 4,A
   \   000023   7414         MOV     A,#0x14
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5..         MOV     ?V0 + 2,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V0 + 3,A
   \   00002F   7416         MOV     A,#0x16
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F5..         MOV     ?V0 + 5,A
   1293            uint8 buf[2]; // Command ID and Status;
   1294          
   1295            // Load the buffer - serially
   1296            buf[0] = defaultRspCmd->commandID;
   \   000037   8882         MOV     DPL,R0
   \   000039   8983         MOV     DPH,R1
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   12....       LCALL   ?Subroutine14 & 0xFFFF
   1297            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_21:
   \   000045   E0           MOVX    A,@DPTR
   \   000046   C0E0         PUSH    A
   \   000048   7401         MOV     A,#0x1
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   D0E0         POP     A
   \   00004F   F0           MOVX    @DPTR,A
   1298          
   1299            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1300                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) ); 
   \   000050                ; Setup parameters for call to function zcl_SendCommand
   \   000050   85..82       MOV     DPL,?XSP + 0
   \   000053   85..83       MOV     DPH,?XSP + 1
   \   000056   8582..       MOV     ?V0 + 0,DPL
   \   000059   8583..       MOV     ?V0 + 1,DPH
   \   00005C   78..         MOV     R0,#?V0 + 0
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000061   75..02       MOV     ?V0 + 0,#0x2
   \   000064   75..00       MOV     ?V0 + 1,#0x0
   \   000067   78..         MOV     R0,#?V0 + 0
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   E5..         MOV     A,?V0 + 5
   \   00006E   F5..         MOV     ?V0 + 0,A
   \   000070   78..         MOV     R0,#?V0 + 0
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000075   78..         MOV     R0,#?V0 + 2
   \   000077   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007A   E5..         MOV     A,?V0 + 4
   \   00007C   F5..         MOV     ?V0 + 0,A
   \   00007E   78..         MOV     R0,#?V0 + 0
   \   000080   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000083   EF           MOV     A,R7
   \   000084   F5..         MOV     ?V0 + 0,A
   \   000086   78..         MOV     R0,#?V0 + 0
   \   000088   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008B   75..00       MOV     ?V0 + 0,#0x0
   \   00008E   78..         MOV     R0,#?V0 + 0
   \   000090   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000093   75..0B       MOV     ?V0 + 0,#0xb
   \   000096   78..         MOV     R0,#?V0 + 0
   \   000098   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009B   EE           MOV     A,R6
   \   00009C   F9           MOV     R1,A
   \   00009D   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   0000A0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A3   7402         MOV     A,#0x2
   \   0000A5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A8   02....       LJMP    ?Subroutine105 & 0xFFFF
   1301          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   000003   22           RET
   1302          
   1303          #ifdef ZCL_DISCOVER
   1304          /*********************************************************************
   1305           * @fn      zcl_SendDiscoverCmd
   1306           *
   1307           * @brief   Send a Discover command
   1308           *
   1309           * @param   dstAddr - destination address
   1310           * @param   clusterID - cluster ID
   1311           * @param   discoverCmd - discover command to be sent
   1312           * @param   direction - direction of the command
   1313           * @param   seqNum - transaction sequence number
   1314           *
   1315           * @return  ZSuccess if OK
   1316           */
   1317          ZStatus_t zcl_SendDiscoverCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1318                                      uint16 clusterID, zclDiscoverCmd_t *discoverCmd,
   1319                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1320          {
   1321            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1322            uint8 *buf;
   1323            uint8 *pBuf;
   1324            ZStatus_t status;
   1325            
   1326            buf = osal_mem_alloc( dataLen );
   1327            if ( buf != NULL )
   1328            {
   1329              // Load the buffer - serially
   1330              pBuf = buf;
   1331              *pBuf++ = LO_UINT16(discoverCmd->startAttr);
   1332              *pBuf++ = HI_UINT16(discoverCmd->startAttr);
   1333              *pBuf++ = discoverCmd->maxAttrIDs;
   1334              
   1335              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER, FALSE, 
   1336                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1337              osal_mem_free( buf );
   1338            }
   1339            else
   1340              status = ZMemError;
   1341            
   1342            return ( status );
   1343          }
   1344          
   1345          /*********************************************************************
   1346           * @fn      zcl_SendDiscoverRspCmd
   1347           *
   1348           * @brief   Send a Discover Response command
   1349           *
   1350           * @param   dstAddr - destination address
   1351           * @param   clusterID - cluster ID
   1352           * @param   reportRspCmd - report response command to be sent
   1353           * @param   direction - direction of the command
   1354           * @param   seqNum - transaction sequence number
   1355           *
   1356           * @return  ZSuccess if OK
   1357           */
   1358          ZStatus_t zcl_SendDiscoverRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1359                                uint16 clusterID, zclDiscoverRspCmd_t *discoverRspCmd,
   1360                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1361          {
   1362            uint8 dataLen = 1; // Discovery complete
   1363            uint8 *buf;
   1364            uint8 *pBuf;
   1365            uint8 i;
   1366            ZStatus_t status;
   1367            
   1368            // calculate the size of the command
   1369            dataLen += discoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1370            
   1371            buf = osal_mem_alloc( dataLen );
   1372            if ( buf != NULL )
   1373            {
   1374              // Load the buffer - serially
   1375              pBuf = buf;
   1376              *pBuf++ = discoverRspCmd->discComplete;    
   1377              for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   1378              {
   1379                *pBuf++ = LO_UINT16(discoverRspCmd->attrList[i].attrID);
   1380                *pBuf++ = HI_UINT16(discoverRspCmd->attrList[i].attrID);
   1381                *pBuf++ = discoverRspCmd->attrList[i].dataType;
   1382              }
   1383              
   1384              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_RSP, FALSE,
   1385                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1386              osal_mem_free( buf );
   1387            }
   1388            else
   1389              status = ZMemError;
   1390            
   1391            return ( status );
   1392          }
   1393          #endif // ZCL_DISCOVER
   1394          
   1395          /*********************************************************************
   1396           * PRIVATE FUNCTIONS
   1397           *********************************************************************/
   1398          
   1399          /*********************************************************************
   1400           * @fn      zclProcessMessageMSG
   1401           *
   1402           * @brief   Data message processor callback.  This function processes
   1403           *          any incoming data - probably from other devices.  So, based
   1404           *          on cluster ID, perform the intended action.
   1405           *
   1406           * @param   pkt - incoming message
   1407           *
   1408           * @return  none
   1409           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1410          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zclProcessMessageMSG:
   1411          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1412            endPointDesc_t *epDesc;
   1413            zclIncoming_t inMsg;
   1414            zclLibPlugin_t *pInPlugin;
   1415            zclDefaultRspCmd_t defautlRspCmd;
   1416            uint8 options;
   1417            uint8 securityEnable;
   1418            uint8 interPanMsg;
   1419            ZStatus_t status = ZFailure;
   1420          
   1421            if ( pkt->cmd.DataLength == 0 )
   \   00000E   EE           MOV     A,R6
   \   00000F   241F         ADD     A,#0x1f
   \   000011   F5..         MOV     ?V0 + 0,A
   \   000013   EF           MOV     A,R7
   \   000014   3400         ADDC    A,#0x0
   \   000016   F5..         MOV     ?V0 + 1,A
   \   000018   85..82       MOV     DPL,?V0 + 0
   \   00001B   F583         MOV     DPH,A
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   7002         JNZ     ??zclProcessMessageMSG_0
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_0:
   \   000022   7003         JNZ     $+5
   \   000024   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1422              return;   // Error, ignore the message
   1423          
   1424            // Initialize
   1425            inMsg.msg = pkt;
   \   000027   7402         MOV     A,#0x2
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   EE           MOV     A,R6
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   EF           MOV     A,R7
   \   000030   F0           MOVX    @DPTR,A
   1426            inMsg.attrCmd = NULL;
   \   000031   740E         MOV     A,#0xe
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   E4           CLR     A
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   F0           MOVX    @DPTR,A
   1427            inMsg.pData = NULL;
   \   00003A   740A         MOV     A,#0xa
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E4           CLR     A
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   F0           MOVX    @DPTR,A
   1428            inMsg.pDataLen = 0;
   \   000043   740C         MOV     A,#0xc
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   F0           MOVX    @DPTR,A
   1429          
   1430            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   00004C   EE           MOV     A,R6
   \   00004D   2421         ADD     A,#0x21
   \   00004F   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   000052   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   000055   7404         MOV     A,#0x4
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   AA82         MOV     R2,DPL
   \   00005C   AB83         MOV     R3,DPH
   \   00005E   12....       LCALL   ??zclParseHdr?relay
   \   000061   740A         MOV     A,#0xa
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   1431            inMsg.pDataLen = pkt->cmd.DataLength;
   1432            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_292:
   \   000069   85..82       MOV     DPL,?V0 + 0
   \   00006C   85..83       MOV     DPH,?V0 + 1
   \   00006F   C082         PUSH    DPL
   \   000071   C083         PUSH    DPH
   \   000073   740A         MOV     A,#0xa
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   00007B   D083         POP     DPH
   \   00007D   D082         POP     DPL
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   C3           CLR     C
   \   000081   98           SUBB    A,R0
   \   000082   F8           MOV     R0,A
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   99           SUBB    A,R1
   \   000086   F9           MOV     R1,A
   \   000087   85..82       MOV     DPL,?V0 + 2
   \   00008A   85..83       MOV     DPH,?V0 + 3
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   28           ADD     A,R0
   \   00008F   F8           MOV     R0,A
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   39           ADDC    A,R1
   \   000093   F9           MOV     R1,A
   \   000094   740C         MOV     A,#0xc
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   1433          
   1434            // Find the wanted endpoint
   1435            epDesc = afFindEndPointDesc( pkt->endPoint );
   \                     ??CrossCallReturnLabel_238:
   \   00009C   EE           MOV     A,R6
   \   00009D   2414         ADD     A,#0x14
   \   00009F   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   F9           MOV     R1,A
   \   0000A4   12....       LCALL   ??afFindEndPointDesc?relay
   \   0000A7   8A..         MOV     ?V0 + 0,R2
   \   0000A9   8B..         MOV     ?V0 + 1,R3
   \   0000AB   A8..         MOV     R0,?V0 + 0
   \   0000AD   A9..         MOV     R1,?V0 + 1
   1436            if ( epDesc == NULL )
   \   0000AF   E8           MOV     A,R0
   \   0000B0   7001         JNZ     ??zclProcessMessageMSG_2
   \   0000B2   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_2:
   \   0000B3   7003         JNZ     $+5
   \   0000B5   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1437              return;   // Error, ignore the message
   1438          
   1439            if ( pkt->clusterId == ZCL_INVALID_CLUSTER_ID )
   \   0000B8   EE           MOV     A,R6
   \   0000B9   2404         ADD     A,#0x4
   \   0000BB   F5..         MOV     ?V0 + 4,A
   \   0000BD   EF           MOV     A,R7
   \   0000BE   3400         ADDC    A,#0x0
   \   0000C0   F5..         MOV     ?V0 + 5,A
   \   0000C2   85..82       MOV     DPL,?V0 + 4
   \   0000C5   F583         MOV     DPH,A
   \   0000C7   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   0000CA   7003         JNZ     ??zclProcessMessageMSG_3
   \   0000CC   74FF         MOV     A,#-0x1
   \   0000CE   6B           XRL     A,R3
   \                     ??zclProcessMessageMSG_3:
   \   0000CF   7003         JNZ     $+5
   \   0000D1   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1440              return;   // Error, ignore the message
   1441            
   1442            if ((epDesc->simpleDesc == NULL) ||
   1443                (zcl_DeviceOperational(pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type, inMsg.hdr.commandID,
   1444                                             epDesc->simpleDesc->AppProfId) == FALSE))
   \   0000D4   E8           MOV     A,R0
   \   0000D5   2403         ADD     A,#0x3
   \   0000D7   F5..         MOV     ?V0 + 6,A
   \   0000D9   E9           MOV     A,R1
   \   0000DA   3400         ADDC    A,#0x0
   \   0000DC   F5..         MOV     ?V0 + 7,A
   \   0000DE   85..82       MOV     DPL,?V0 + 6
   \   0000E1   F583         MOV     DPH,A
   \   0000E3   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0000E6   7002         JNZ     ??zclProcessMessageMSG_4
   \   0000E8   E583         MOV     A,DPH
   \                     ??zclProcessMessageMSG_4:
   \   0000EA   7003         JNZ     $+5
   \   0000EC   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0000EF                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000EF   A3           INC     DPTR
   \   0000F0   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000F3   740B         MOV     A,#0xb
   \   0000F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F8   E0           MOVX    A,@DPTR
   \   0000F9   FD           MOV     R5,A
   \   0000FA   7406         MOV     A,#0x6
   \   0000FC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FF   E0           MOVX    A,@DPTR
   \   000100   5403         ANL     A,#0x3
   \   000102   FC           MOV     R4,A
   \   000103   85..82       MOV     DPL,?V0 + 2
   \   000106   85..83       MOV     DPH,?V0 + 3
   \   000109   E0           MOVX    A,@DPTR
   \   00010A   F9           MOV     R1,A
   \   00010B   12....       LCALL   ??zcl_DeviceOperational?relay
   \   00010E   7402         MOV     A,#0x2
   \   000110   12....       LCALL   ?DEALLOC_XSTACK8
   \   000113   E9           MOV     A,R1
   \   000114   7003         JNZ     $+5
   \   000116   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1445            {
   1446              return; // Error, ignore the message
   1447            }
   1448          
   1449          #if defined ( INTER_PAN )
   1450            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   1451            {
   1452              // No foundation command is supported thru Inter-PAN communication
   1453              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1454                return;
   1455          
   1456              interPanMsg = TRUE; 
   1457              options = AF_TX_OPTIONS_NONE;
   1458            }
   1459            else
   1460          #endif
   1461            {
   1462              interPanMsg = FALSE;
   1463              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \   000119                ; Setup parameters for call to function zclGetClusterOption
   \   000119   85..82       MOV     DPL,?V0 + 4
   \   00011C   85..83       MOV     DPH,?V0 + 5
   \   00011F   12....       LCALL   ?Subroutine43 & 0xFFFF
   1464            }
   \                     ??CrossCallReturnLabel_55:
   \   000122   E0           MOVX    A,@DPTR
   \   000123   F9           MOV     R1,A
   \   000124   12....       LCALL   ??zclGetClusterOption?relay
   \   000127   E9           MOV     A,R1
   \   000128   FA           MOV     R2,A
   1465            
   1466            // Local and remote Security options must match except for Default Response command
   1467            if ( !zcl_DefaultRspCmd( inMsg.hdr ) )
   \   000129   7404         MOV     A,#0x4
   \   00012B   12....       LCALL   ?XSTACK_DISP0_8
   \   00012E   E0           MOVX    A,@DPTR
   \   00012F   F8           MOV     R0,A
   \   000130   5407         ANL     A,#0x7
   \   000132   700D         JNZ     ??zclProcessMessageMSG_5
   \   000134   7409         MOV     A,#0x9
   \   000136   12....       LCALL   ?XSTACK_DISP0_8
   \   000139   E0           MOVX    A,@DPTR
   \   00013A   640B         XRL     A,#0xb
   \   00013C   7003         JNZ     $+5
   \   00013E   02....       LJMP    ??zclProcessMessageMSG_6 & 0xFFFF
   1468            {
   1469              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zclProcessMessageMSG_5:
   \   000141   EA           MOV     A,R2
   \   000142   A2E6         MOV     C,0xE0 /* A   */.6
   \   000144   5004         JNC     ??zclProcessMessageMSG_7
   \   000146   D2F0         SETB    B.0
   \   000148   8002         SJMP    ??zclProcessMessageMSG_8
   \                     ??zclProcessMessageMSG_7:
   \   00014A   C2F0         CLR     B.0
   \                     ??zclProcessMessageMSG_8:
   \   00014C   A2F0         MOV     C,B.0
   \   00014E   E4           CLR     A
   \   00014F   92E0         MOV     0xE0 /* A   */.0,C
   \   000151   F5..         MOV     ?V0 + 0,A
   1470              if ( pkt->SecurityUse != securityEnable )
   \   000153   EE           MOV     A,R6
   \   000154   2419         ADD     A,#0x19
   \   000156   F582         MOV     DPL,A
   \   000158   EF           MOV     A,R7
   \   000159   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   00015C   65..         XRL     A,?V0 + 0
   \   00015E   7003         JNZ     $+5
   \   000160   02....       LJMP    ??zclProcessMessageMSG_6 & 0xFFFF
   1471              {
   1472                if ( UNICAST_MSG( inMsg.msg ) )
   \   000163   7402         MOV     A,#0x2
   \   000165   12....       LCALL   ?XSTACK_DISP0_8
   \   000168   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00016B   6003         JZ      $+5
   \   00016D   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   000170   7402         MOV     A,#0x2
   \   000172   12....       LCALL   ?XSTACK_DISP0_8
   \   000175   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000178   7002         JNZ     ??zclProcessMessageMSG_9
   \   00017A   A3           INC     DPTR
   \   00017B   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_9:
   \   00017C   6003         JZ      $+5
   \   00017E   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1473                {
   1474                  // Send a Default Response command back with no Application Link Key security
   1475                  if ( securityEnable )
   \   000181   E5..         MOV     A,?V0 + 0
   \   000183   6005         JZ      ??CrossCallReturnLabel_32
   1476                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   000185                ; Setup parameters for call to function zclSetSecurityOption
   \   000185   7C00         MOV     R4,#0x0
   \   000187   12....       LCALL   ?Subroutine27 & 0xFFFF
   1477                  
   1478                  defautlRspCmd.statusCode = status;
   \                     ??CrossCallReturnLabel_32:
   \   00018A   7401         MOV     A,#0x1
   \   00018C   12....       LCALL   ?XSTACK_DISP0_8
   \   00018F   7401         MOV     A,#0x1
   \   000191   F0           MOVX    @DPTR,A
   1479                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   000192   7409         MOV     A,#0x9
   \   000194   12....       LCALL   ?XSTACK_DISP0_8
   \   000197   12....       LCALL   ?Subroutine51 & 0xFFFF
   1480                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1481                                         inMsg.msg->clusterId, &defautlRspCmd, 
   1482                                         ZCL_FRAME_SERVER_CLIENT_DIR, true, 
   1483                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_65:
   \   00019A   12....       LCALL   ?XSTACK_DISP0_8
   \   00019D   E0           MOVX    A,@DPTR
   \   00019E   F5..         MOV     ?V0 + 1,A
   \   0001A0   78..         MOV     R0,#?V0 + 1
   \   0001A2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001A5   7407         MOV     A,#0x7
   \   0001A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AA   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001AD   75..01       MOV     ?V0 + 1,#0x1
   \   0001B0   78..         MOV     R0,#?V0 + 1
   \   0001B2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001B5   78..         MOV     R0,#?V0 + 1
   \   0001B7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001BA   7405         MOV     A,#0x5
   \   0001BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BF   8582..       MOV     ?V0 + 6,DPL
   \   0001C2   8583..       MOV     ?V0 + 7,DPH
   \   0001C5   78..         MOV     R0,#?V0 + 6
   \   0001C7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001CA   7409         MOV     A,#0x9
   \   0001CC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CF   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_180:
   \   0001D2   7409         MOV     A,#0x9
   \   0001D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D7   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   0001DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DD   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   0001E0   12....       LCALL   ?DEALLOC_XSTACK8
   1484                  if ( securityEnable )
   \   0001E3   E5..         MOV     A,?V0 + 0
   \   0001E5   7003         JNZ     $+5
   \   0001E7   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1485                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );       
   \   0001EA                ; Setup parameters for call to function zclSetSecurityOption
   \   0001EA   7C01         MOV     R4,#0x1
   \   0001EC   12....       LCALL   ?Subroutine27 & 0xFFFF
   1486                }
   1487                
   1488                return;   // Error, ignore the message
   1489              }
   1490            }
   \                     ??CrossCallReturnLabel_33:
   \   0001EF   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1491            
   1492            // Is this a foundation type message
   1493            if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zclProcessMessageMSG_6:
   \   0001F2   E8           MOV     A,R0
   \   0001F3   5403         ANL     A,#0x3
   \   0001F5   6003         JZ      $+5
   \   0001F7   02....       LJMP    ??zclProcessMessageMSG_10 & 0xFFFF
   1494            { 
   1495              if ( inMsg.hdr.fc.manuSpecific )
   \   0001FA   E8           MOV     A,R0
   \   0001FB   5404         ANL     A,#0x4
   \   0001FD   6005         JZ      ??zclProcessMessageMSG_11
   1496              {
   1497                // We don't support any manufacturer specific command
   1498                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   0001FF   7A84         MOV     R2,#-0x7c
   \   000201   02....       LJMP    ??zclProcessMessageMSG_12 & 0xFFFF
   1499              }
   1500              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) && 
   1501                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zclProcessMessageMSG_11:
   \   000204   7409         MOV     A,#0x9
   \   000206   12....       LCALL   ?XSTACK_DISP0_8
   \   000209   E0           MOVX    A,@DPTR
   \   00020A   F5..         MOV     ?V0 + 0,A
   \   00020C   C3           CLR     C
   \   00020D   940E         SUBB    A,#0xe
   \   00020F   4003         JC      $+5
   \   000211   02....       LJMP    ??zclProcessMessageMSG_13 & 0xFFFF
   \   000214   75..00       MOV     ?V0 + 1,#0x0
   \   000217   7402         MOV     A,#0x2
   \   000219   78..         MOV     R0,#?V0 + 0
   \   00021B   12....       LCALL   ?S_SHL
   \   00021E   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000221   F8           MOV     R0,A
   \   000222   7401         MOV     A,#0x1
   \   000224   93           MOVC    A,@A+DPTR
   \   000225   F9           MOV     R1,A
   \   000226   E8           MOV     A,R0
   \   000227   7001         JNZ     ??zclProcessMessageMSG_14
   \   000229   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_14:
   \   00022A   7003         JNZ     $+5
   \   00022C   02....       LJMP    ??zclProcessMessageMSG_13 & 0xFFFF
   1502              {
   1503                zclParseCmd_t parseCmd;
   1504                
   1505                parseCmd.endpoint = pkt->endPoint;
   \   00022F   85..82       MOV     DPL,?V0 + 2
   \   000232   85..83       MOV     DPH,?V0 + 3
   \   000235   E0           MOVX    A,@DPTR
   \   000236   C0E0         PUSH    A
   \   000238   7410         MOV     A,#0x10
   \   00023A   12....       LCALL   ?XSTACK_DISP0_8
   \   00023D   D0E0         POP     A
   \   00023F   F0           MOVX    @DPTR,A
   1506                parseCmd.dataLen = inMsg.pDataLen;
   \   000240   740C         MOV     A,#0xc
   \   000242   12....       LCALL   ?XSTACK_DISP0_8
   \   000245   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000248   7411         MOV     A,#0x11
   \   00024A   12....       LCALL   ?XSTACK_DISP0_8
   \   00024D   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   1507                parseCmd.pData = inMsg.pData;
   \                     ??CrossCallReturnLabel_239:
   \   000250   740A         MOV     A,#0xa
   \   000252   12....       LCALL   ?XSTACK_DISP0_8
   \   000255   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000258   7413         MOV     A,#0x13
   \   00025A   12....       LCALL   ?XSTACK_DISP0_8
   \   00025D   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   1508                
   1509                // Parse the command, remember that the return value is a pointer to allocated memory
   1510                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \                     ??CrossCallReturnLabel_240:
   \   000260                ; Setup parameters for indirect call
   \   000260   7410         MOV     A,#0x10
   \   000262   12....       LCALL   ?XSTACK_DISP0_8
   \   000265   AA82         MOV     R2,DPL
   \   000267   AB83         MOV     R3,DPH
   \   000269   7409         MOV     A,#0x9
   \   00026B   12....       LCALL   ?XSTACK_DISP0_8
   \   00026E   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000271   12....       LCALL   ?S_SHL
   \   000274   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000277   C0E0         PUSH    A
   \   000279   7401         MOV     A,#0x1
   \   00027B   93           MOVC    A,@A+DPTR
   \   00027C   F583         MOV     DPH,A
   \   00027E   D082         POP     DPL
   \   000280   12....       LCALL   ?CALL_IND
   \   000283   740E         MOV     A,#0xe
   \   000285   12....       LCALL   ?XSTACK_DISP0_8
   \   000288   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   1511                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \                     ??CrossCallReturnLabel_293:
   \   00028B   740E         MOV     A,#0xe
   \   00028D   12....       LCALL   ?XSTACK_DISP0_8
   \   000290   E0           MOVX    A,@DPTR
   \   000291   7002         JNZ     ??zclProcessMessageMSG_15
   \   000293   A3           INC     DPTR
   \   000294   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_15:
   \   000295   6047         JZ      ??zclProcessMessageMSG_16
   \   000297   7409         MOV     A,#0x9
   \   000299   12....       LCALL   ?XSTACK_DISP0_8
   \   00029C   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   00029F   12....       LCALL   ?S_SHL
   \   0002A2   E5..         MOV     A,?V0 + 0
   \   0002A4   24..         ADD     A,#((zclCmdTable + 2) & 0xff)
   \   0002A6   F582         MOV     DPL,A
   \   0002A8   E5..         MOV     A,?V0 + 1
   \   0002AA   34..         ADDC    A,#(((zclCmdTable + 2) >> 8) & 0xff)
   \   0002AC   F583         MOV     DPH,A
   \   0002AE   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   0002B1   E8           MOV     A,R0
   \   0002B2   7001         JNZ     ??zclProcessMessageMSG_17
   \   0002B4   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_17:
   \   0002B5   601C         JZ      ??zclProcessMessageMSG_18
   1512                { 
   1513                  // Process the command
   1514                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   0002B7                ; Setup parameters for indirect call
   \   0002B7   7402         MOV     A,#0x2
   \   0002B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0002BC   AA82         MOV     R2,DPL
   \   0002BE   AB83         MOV     R3,DPH
   \   0002C0   8882         MOV     DPL,R0
   \   0002C2   8983         MOV     DPH,R1
   \   0002C4   12....       LCALL   ?CALL_IND
   1515                  {
   1516                    // Couldn't find attribute in the table.
   1517                  }
   1518                }
   1519                 
   1520                // Free the buffer
   1521                if ( inMsg.attrCmd )
   \   0002C7   740E         MOV     A,#0xe
   \   0002C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0002CC   E0           MOVX    A,@DPTR
   \   0002CD   7002         JNZ     ??zclProcessMessageMSG_19
   \   0002CF   A3           INC     DPTR
   \   0002D0   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_19:
   \   0002D1   600B         JZ      ??zclProcessMessageMSG_16
   1522                  osal_mem_free( inMsg.attrCmd );
   \                     ??zclProcessMessageMSG_18:
   \   0002D3                ; Setup parameters for call to function osal_mem_free
   \   0002D3   740E         MOV     A,#0xe
   \   0002D5   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D8   12....       LCALL   ??Subroutine131_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   0002DB   12....       LCALL   ??osal_mem_free?relay
   1523                
   1524                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zclProcessMessageMSG_16:
   \   0002DE   7409         MOV     A,#0x9
   \   0002E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0002E3   E0           MOVX    A,@DPTR
   \   0002E4   FA           MOV     R2,A
   \   0002E5   7003         JNZ     $+5
   \   0002E7   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0002EA   7402         MOV     A,#0x2
   \   0002EC   6A           XRL     A,R2
   \   0002ED   7003         JNZ     $+5
   \   0002EF   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0002F2   7403         MOV     A,#0x3
   \   0002F4   6A           XRL     A,R2
   \   0002F5   7003         JNZ     $+5
   \   0002F7   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   0002FA   7406         MOV     A,#0x6
   \   0002FC   6A           XRL     A,R2
   \   0002FD   7003         JNZ     $+5
   \   0002FF   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   000302   7408         MOV     A,#0x8
   \   000304   6A           XRL     A,R2
   \   000305   7003         JNZ     $+5
   \   000307   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   00030A   740C         MOV     A,#0xc
   \   00030C   6A           XRL     A,R2
   \   00030D   7003         JNZ     $+5
   \   00030F   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   \   000312   740B         MOV     A,#0xb
   \   000314   6A           XRL     A,R2
   \   000315   7003         JNZ     $+5
   \   000317   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1525                  return; // We're done
   1526                
   1527                status = ZSuccess;
   \   00031A   7A00         MOV     R2,#0x0
   \   00031C   02....       LJMP    ??zclProcessMessageMSG_12 & 0xFFFF
   1528              }
   1529              else
   1530              {
   1531                // Unsupported message
   1532                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zclProcessMessageMSG_13:
   \   00031F   7A82         MOV     R2,#-0x7e
   \   000321   02....       LJMP    ??zclProcessMessageMSG_12 & 0xFFFF
   1533              }
   1534            }
   1535            else  // Not a foundation type message, so it must be specific to the cluster ID.
   1536            {
   1537              if (epDesc->simpleDesc == NULL)
   \                     ??zclProcessMessageMSG_10:
   \   000324   85..82       MOV     DPL,?V0 + 6
   \   000327   85..83       MOV     DPH,?V0 + 7
   \   00032A   E0           MOVX    A,@DPTR
   \   00032B   7002         JNZ     ??zclProcessMessageMSG_20
   \   00032D   A3           INC     DPTR
   \   00032E   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_20:
   \   00032F   607D         JZ      ??zclProcessMessageMSG_21
   1538              {
   1539                pInPlugin = NULL;
   1540              }
   1541              else
   1542              {
   1543                // Find the appropriate plugin
   1544                pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \   000331   85..82       MOV     DPL,?V0 + 4
   \   000334   85..83       MOV     DPH,?V0 + 5
   \   000337   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   00033A   7003         JNZ     ??zclProcessMessageMSG_22
   \   00033C   74FF         MOV     A,#-0x1
   \   00033E   6B           XRL     A,R3
   \                     ??zclProcessMessageMSG_22:
   \   00033F   6035         JZ      ??zclProcessMessageMSG_23
   \   000341   90....       MOV     DPTR,#plugins
   \   000344   8004         SJMP    ??zclProcessMessageMSG_24
   \                     ??zclProcessMessageMSG_25:
   \   000346   8882         MOV     DPL,R0
   \   000348   8983         MOV     DPH,R1
   \                     ??zclProcessMessageMSG_24:
   \   00034A   12....       LCALL   ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   00034D   7001         JNZ     ??zclProcessMessageMSG_26
   \   00034F   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_26:
   \   000350   6024         JZ      ??zclProcessMessageMSG_23
   \   000352   8882         MOV     DPL,R0
   \   000354   8983         MOV     DPH,R1
   \   000356   12....       LCALL   ??Subroutine126_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   000359   C3           CLR     C
   \   00035A   EA           MOV     A,R2
   \   00035B   9C           SUBB    A,R4
   \   00035C   EB           MOV     A,R3
   \   00035D   9D           SUBB    A,R5
   \   00035E   40E6         JC      ??zclProcessMessageMSG_25
   \   000360   8882         MOV     DPL,R0
   \   000362   8983         MOV     DPH,R1
   \   000364   A3           INC     DPTR
   \   000365   A3           INC     DPTR
   \   000366   A3           INC     DPTR
   \   000367   A3           INC     DPTR
   \   000368   C3           CLR     C
   \   000369   E0           MOVX    A,@DPTR
   \   00036A   9A           SUBB    A,R2
   \   00036B   A3           INC     DPTR
   \   00036C   E0           MOVX    A,@DPTR
   \   00036D   9B           SUBB    A,R3
   \   00036E   40D6         JC      ??zclProcessMessageMSG_25
   \   000370   8882         MOV     DPL,R0
   \   000372   8983         MOV     DPH,R1
   \   000374   8006         SJMP    ??zclProcessMessageMSG_27
   \                     ??zclProcessMessageMSG_23:
   \   000376   758200       MOV     DPL,#0x0
   \   000379   758300       MOV     DPH,#0x0
   1545              }
   1546              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zclProcessMessageMSG_27:
   \   00037C   E582         MOV     A,DPL
   \   00037E   7002         JNZ     ??zclProcessMessageMSG_28
   \   000380   E583         MOV     A,DPH
   \                     ??zclProcessMessageMSG_28:
   \   000382   602A         JZ      ??zclProcessMessageMSG_21
   \   000384   A3           INC     DPTR
   \   000385   A3           INC     DPTR
   \   000386   A3           INC     DPTR
   \   000387   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   00038A   7001         JNZ     ??zclProcessMessageMSG_29
   \   00038C   E9           MOV     A,R1
   \                     ??zclProcessMessageMSG_29:
   \   00038D   601F         JZ      ??zclProcessMessageMSG_21
   1547              { 
   1548                // The return value of the plugin function will be
   1549                //  ZSuccess - Supported and need default response
   1550                //  ZFailure - Unsupported
   1551                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   1552                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   1553                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   1554                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   1555                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   00038F                ; Setup parameters for indirect call
   \   00038F   7402         MOV     A,#0x2
   \   000391   12....       LCALL   ?XSTACK_DISP0_8
   \   000394   AA82         MOV     R2,DPL
   \   000396   AB83         MOV     R3,DPH
   \   000398   8882         MOV     DPL,R0
   \   00039A   8983         MOV     DPH,R1
   \   00039C   12....       LCALL   ?CALL_IND
   \   00039F   E9           MOV     A,R1
   \   0003A0   FA           MOV     R2,A
   1556                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   0003A1   74FF         MOV     A,#-0x1
   \   0003A3   6A           XRL     A,R2
   \   0003A4   7003         JNZ     $+5
   \   0003A6   02....       LJMP    ??zclProcessMessageMSG_1 & 0xFFFF
   1557                  return; // We're done      
   1558              }
   1559              
   1560              if ( status == ZFailure )
   \   0003A9   7401         MOV     A,#0x1
   \   0003AB   6A           XRL     A,R2
   \   0003AC   7010         JNZ     ??zclProcessMessageMSG_12
   1561              {
   1562                // Unsupported message
   1563                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zclProcessMessageMSG_21:
   \   0003AE   7404         MOV     A,#0x4
   \   0003B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B3   E0           MOVX    A,@DPTR
   \   0003B4   5404         ANL     A,#0x4
   \   0003B6   6004         JZ      ??zclProcessMessageMSG_30
   1564                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   0003B8   7A83         MOV     R2,#-0x7d
   \   0003BA   8002         SJMP    ??zclProcessMessageMSG_12
   1565                else
   1566                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zclProcessMessageMSG_30:
   \   0003BC   7A81         MOV     R2,#-0x7f
   1567              }
   1568            }
   1569            
   1570            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zclProcessMessageMSG_12:
   \   0003BE   7402         MOV     A,#0x2
   \   0003C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0003C3   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0003C6   7070         JNZ     ??zclProcessMessageMSG_1
   \   0003C8   7402         MOV     A,#0x2
   \   0003CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0003CD   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0003D0   7002         JNZ     ??zclProcessMessageMSG_31
   \   0003D2   A3           INC     DPTR
   \   0003D3   E0           MOVX    A,@DPTR
   \                     ??zclProcessMessageMSG_31:
   \   0003D4   7062         JNZ     ??zclProcessMessageMSG_1
   \   0003D6   7404         MOV     A,#0x4
   \   0003D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0003DB   E0           MOVX    A,@DPTR
   \   0003DC   5410         ANL     A,#0x10
   \   0003DE   7058         JNZ     ??zclProcessMessageMSG_1
   1571            {
   1572              // Send a Default Response command back
   1573              defautlRspCmd.statusCode = status;
   \   0003E0   7401         MOV     A,#0x1
   \   0003E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0003E5   EA           MOV     A,R2
   \   0003E6   F0           MOVX    @DPTR,A
   1574              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0003E7   7409         MOV     A,#0x9
   \   0003E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0003EC   12....       LCALL   ?Subroutine51 & 0xFFFF
   1575              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1576                                     inMsg.msg->clusterId, &defautlRspCmd, 
   1577                                     ZCL_FRAME_SERVER_CLIENT_DIR, true, 
   1578                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   1579            }
   \                     ??CrossCallReturnLabel_66:
   \   0003EF   12....       LCALL   ?XSTACK_DISP0_8
   \   0003F2   E0           MOVX    A,@DPTR
   \   0003F3   F5..         MOV     ?V0 + 0,A
   \   0003F5   78..         MOV     R0,#?V0 + 0
   \   0003F7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003FA   7407         MOV     A,#0x7
   \   0003FC   12....       LCALL   ?XSTACK_DISP0_8
   \   0003FF   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000402   75..01       MOV     ?V0 + 0,#0x1
   \   000405   78..         MOV     R0,#?V0 + 0
   \   000407   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00040A   78..         MOV     R0,#?V0 + 0
   \   00040C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00040F   7405         MOV     A,#0x5
   \   000411   12....       LCALL   ?XSTACK_DISP0_8
   \   000414   8582..       MOV     ?V0 + 0,DPL
   \   000417   8583..       MOV     ?V0 + 1,DPH
   \   00041A   78..         MOV     R0,#?V0 + 0
   \   00041C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00041F   7409         MOV     A,#0x9
   \   000421   12....       LCALL   ?XSTACK_DISP0_8
   \   000424   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   000427   7409         MOV     A,#0x9
   \   000429   12....       LCALL   ?XSTACK_DISP0_8
   \   00042C   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00042F   12....       LCALL   ?XSTACK_DISP0_8
   \   000432   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000435   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zclProcessMessageMSG_1:
   \   000438   7415         MOV     A,#0x15
   \   00043A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00043D                REQUIRE ?Subroutine116
   \   00043D                ; // Fall through to label ?Subroutine116
   1580          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine116:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   24..         ADD     A,#(zclCmdTable & 0xff)
   \   000004   F582         MOV     DPL,A
   \   000006   E5..         MOV     A,?V0 + 1
   \   000008   34..         ADDC    A,#((zclCmdTable >> 8) & 0xff)
   \   00000A   F583         MOV     DPH,A
   \   00000C   E4           CLR     A
   \   00000D   93           MOVC    A,@A+DPTR
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   000003   74FF         MOV     A,#-0x1
   \   000005   6A           XRL     A,R2
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   75..00       MOV     ?V0 + 1,#0x0
   \   000006   7402         MOV     A,#0x2
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008   7408         MOV     A,#0x8
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   7409         MOV     A,#0x9
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2415         ADD     A,#0x15
   \   000003   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   85..82       MOV     DPL,?V0 + 4
   \   000003   85..83       MOV     DPH,?V0 + 5
   \   000006   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   12....       LCALL   ??zclSetSecurityOption?relay
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2414         ADD     A,#0x14
   \   000003   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000006   F9           MOV     R1,A
   \   000007   12....       LCALL   ??zcl_SendDefaultRspCmd?relay
   \   00000A   7407         MOV     A,#0x7
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F9           MOV     R1,A
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   E4           CLR     A
   \   000001   93           MOVC    A,@A+DPTR
   \   000002   F8           MOV     R0,A
   \   000003   7401         MOV     A,#0x1
   \   000005   93           MOVC    A,@A+DPTR
   \   000006   F9           MOV     R1,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_251:
   \   000003                REQUIRE ??Subroutine125_0
   \   000003                ; // Fall through to label ??Subroutine125_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine125_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine126_0
   \   000002                ; // Fall through to label ??Subroutine126_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine126_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine127_0
   \   000002                ; // Fall through to label ??Subroutine127_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine128_0
   \   000003                ; // Fall through to label ??Subroutine128_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine128_0:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine131_0:
   \   000000   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine140_0:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine141_0
   \   000001                ; // Fall through to label ??Subroutine141_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine141_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_254:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine144_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   F5..         MOV     ?V0 + 2,A
   \   000002   EF           MOV     A,R7
   \   000003                REQUIRE ??Subroutine145_0
   \   000003                ; // Fall through to label ??Subroutine145_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine145_0:
   \   000000   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F5..         MOV     ?V0 + 3,A
   \   000004                ; Setup parameters for call to function zclParseHdr
   \   000004                ; Setup parameters for call to function afFindEndPointDesc
   \   000004                ; Setup parameters for call to function zclGetAttrDataLength
   \   000004   85..82       MOV     DPL,?V0 + 2
   \   000007   F583         MOV     DPH,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   85..82       MOV     DPL,?V0 + 2
   \   000008   85..83       MOV     DPH,?V0 + 3
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET
   1581          
   1582          /*********************************************************************
   1583           * @fn      zclParseHdr
   1584           *
   1585           * @brief   Parse header of the ZCL format
   1586           *
   1587           * @param   hdr - place to put the frame control information
   1588           * @param   pData - incoming buffer to parse
   1589           *
   1590           * @return  pointer past the header
   1591           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1592          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   1593          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   1594            // Clear the header
   1595            osal_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   ??osal_memset?relay
   1596          
   1597            // Parse the Frame Control
   1598            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV     DPL,?V0 + 0
   \   000019   85..83       MOV     DPH,?V0 + 1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   54FC         ANL     A,#0xfc
   \   00001F   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000022   E0           MOVX    A,@DPTR
   \   000023   FA           MOV     R2,A
   \   000024   7403         MOV     A,#0x3
   \   000026   5A           ANL     A,R2
   \   000027   48           ORL     A,R0
   \   000028   F8           MOV     R0,A
   \   000029   85..82       MOV     DPL,?V0 + 0
   \   00002C   85..83       MOV     DPH,?V0 + 1
   \   00002F   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   1599            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_237:
   \   000032   74FB         MOV     A,#-0x5
   \   000034   58           ANL     A,R0
   \   000035   FA           MOV     R2,A
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   A2E2         MOV     C,0xE0 /* A   */.2
   \   00003D   E4           CLR     A
   \   00003E   92E0         MOV     0xE0 /* A   */.0,C
   \   000040   F5..         MOV     ?V0 + 2,A
   \   000042   75..00       MOV     ?V0 + 3,#0x0
   \   000045   7402         MOV     A,#0x2
   \   000047   78..         MOV     R0,#?V0 + 2
   \   000049   12....       LCALL   ?S_SHL
   \   00004C   7404         MOV     A,#0x4
   \   00004E   55..         ANL     A,?V0 + 2
   \   000050   4A           ORL     A,R2
   \   000051   85..82       MOV     DPL,?V0 + 0
   \   000054   85..83       MOV     DPH,?V0 + 1
   \   000057   12....       LCALL   ?Subroutine12 & 0xFFFF
   1600            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_17:
   \   00005A   A2E3         MOV     C,0xE0 /* A   */.3
   \   00005C   85..82       MOV     DPL,?V0 + 0
   \   00005F   85..83       MOV     DPH,?V0 + 1
   \   000062   E0           MOVX    A,@DPTR
   \   000063   5004         JNC     ??zclParseHdr_0
   1601              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000065   4408         ORL     A,#0x8
   \   000067   8002         SJMP    ??zclParseHdr_1
   1602            else
   1603              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_0:
   \   000069   54F7         ANL     A,#0xf7
   \                     ??zclParseHdr_1:
   \   00006B   F0           MOVX    @DPTR,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F0           MOVX    @DPTR,A
   1604            
   1605            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \   00006F   85..82       MOV     DPL,?V0 + 0
   \   000072   85..83       MOV     DPH,?V0 + 1
   \   000075   E0           MOVX    A,@DPTR
   \   000076   54EF         ANL     A,#0xef
   \   000078   FA           MOV     R2,A
   \   000079   A3           INC     DPTR
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   FB           MOV     R3,A
   \   00007C   8E82         MOV     DPL,R6
   \   00007E   8F83         MOV     DPH,R7
   \   000080   E0           MOVX    A,@DPTR
   \   000081   A2E4         MOV     C,0xE0 /* A   */.4
   \   000083   E4           CLR     A
   \   000084   92E0         MOV     0xE0 /* A   */.0,C
   \   000086   F5..         MOV     ?V0 + 2,A
   \   000088   7404         MOV     A,#0x4
   \   00008A   78..         MOV     R0,#?V0 + 2
   \   00008C   12....       LCALL   ?S_SHL
   \   00008F   7410         MOV     A,#0x10
   \   000091   55..         ANL     A,?V0 + 2
   \   000093   4A           ORL     A,R2
   \   000094   F8           MOV     R0,A
   \   000095   EB           MOV     A,R3
   \   000096   F9           MOV     R1,A
   \   000097   85..82       MOV     DPL,?V0 + 0
   \   00009A   85..83       MOV     DPH,?V0 + 1
   \   00009D   E8           MOV     A,R0
   \   00009E   F0           MOVX    @DPTR,A
   \   00009F   A3           INC     DPTR
   \   0000A0   E9           MOV     A,R1
   \   0000A1   12....       LCALL   ??Subroutine135_0 & 0xFFFF
   1606            pData++;  // move past the frame control field
   1607          
   1608            // parse the manfacturer code
   1609            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_212:
   \   0000A4   E8           MOV     A,R0
   \   0000A5   5404         ANL     A,#0x4
   \   0000A7   6014         JZ      ??CrossCallReturnLabel_10
   1610            {
   1611              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   FA           MOV     R2,A
   \   0000AB   A3           INC     DPTR
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   F9           MOV     R1,A
   \   0000AE   EA           MOV     A,R2
   \   0000AF   85..82       MOV     DPL,?V0 + 0
   \   0000B2   85..83       MOV     DPH,?V0 + 1
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   F0           MOVX    @DPTR,A
   \   0000B8   A3           INC     DPTR
   \   0000B9   E9           MOV     A,R1
   \   0000BA   12....       LCALL   ?Subroutine9 & 0xFFFF
   1612              pData += 2;
   1613            }
   1614          
   1615            // parse the Transaction Sequence Number
   1616            hdr->transSeqNum = *pData++;
   \                     ??CrossCallReturnLabel_10:
   \   0000BD   8E82         MOV     DPL,R6
   \   0000BF   8F83         MOV     DPH,R7
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   85..82       MOV     DPL,?V0 + 0
   \   0000C5   85..83       MOV     DPH,?V0 + 1
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   12....       LCALL   ?Subroutine5 & 0xFFFF
   1617          
   1618            // parse the Cluster's command ID
   1619            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_8:
   \   0000CE   85..82       MOV     DPL,?V0 + 0
   \   0000D1   85..83       MOV     DPH,?V0 + 1
   \   0000D4   A3           INC     DPTR
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   1620          
   1621            // Should point to the frame payload
   1622            return ( pData );
   \                     ??CrossCallReturnLabel_218:
   \   0000DC   AA82         MOV     R2,DPL
   \   0000DE   AB83         MOV     R3,DPH
   \   0000E0                REQUIRE ?Subroutine104
   \   0000E0                ; // Fall through to label ?Subroutine104
   1623          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine112:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine135_0:
   \   000000   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   000003   A3           INC     DPTR
   \   000004   AE82         MOV     R6,DPL
   \   000006   AF83         MOV     R7,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   EE           MOV     A,R6
   \   000001   2402         ADD     A,#0x2
   \   000003   0E           INC     R6
   \   000004   0E           INC     R6
   \   000005   02....       LJMP    ?Subroutine109 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine136_0:
   \   000000   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine138_0:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   02....       LJMP    ?Subroutine112 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   02....       LJMP    ?Subroutine112 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET
   1624          
   1625          /*********************************************************************
   1626           * @fn      zclBuildHdr
   1627           *
   1628           * @brief   Build header of the ZCL format
   1629           *
   1630           * @param   hdr - outgoing header information
   1631           * @param   pData - outgoing header space
   1632           *
   1633           * @return  pointer past the header
   1634           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1635          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   1636          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1637            // Build the Frame Control byte
   1638            *pData = hdr->fc.type;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   5403         ANL     A,#0x3
   \   00000C   8C82         MOV     DPL,R4
   \   00000E   8D83         MOV     DPH,R5
   \   000010   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   1639            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_171:
   \   000013   5404         ANL     A,#0x4
   \   000015   12....       LCALL   ?Subroutine16 & 0xFFFF
   1640            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_169:
   \   000018   5408         ANL     A,#0x8
   \   00001A   12....       LCALL   ?Subroutine16 & 0xFFFF
   1641            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_170:
   \   00001D   5410         ANL     A,#0x10
   \   00001F   FE           MOV     R6,A
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   E0           MOVX    A,@DPTR
   \   000025   4E           ORL     A,R6
   \   000026   12....       LCALL   ?Subroutine8 & 0xFFFF
   1642            pData++;  // move past the frame control field
   1643          
   1644            // Add the manfacturer code
   1645            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_230:
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   5404         ANL     A,#0x4
   \   00002C   6013         JZ      ??CrossCallReturnLabel_70
   1646            {
   1647              *pData++ = LO_UINT16( hdr->manuCode );
   \   00002E   EA           MOV     A,R2
   \   00002F   2402         ADD     A,#0x2
   \   000031   F8           MOV     R0,A
   \   000032   EB           MOV     A,R3
   \   000033   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000036   12....       LCALL   ?Subroutine53 & 0xFFFF
   1648              *pData++ = HI_UINT16( hdr->manuCode );
   \                     ??CrossCallReturnLabel_69:
   \   000039   8882         MOV     DPL,R0
   \   00003B   8983         MOV     DPH,R1
   \   00003D   A3           INC     DPTR
   \   00003E   12....       LCALL   ?Subroutine53 & 0xFFFF
   1649            }
   1650          
   1651            // Add the Transaction Sequence Number
   1652            *pData++ = hdr->transSeqNum;
   \                     ??CrossCallReturnLabel_70:
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   8C82         MOV     DPL,R4
   \   00004C   8D83         MOV     DPH,R5
   \   00004E   12....       LCALL   ?Subroutine8 & 0xFFFF
   1653            
   1654            // Add the Cluster's command ID
   1655            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_231:
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   8C82         MOV     DPL,R4
   \   000059   8D83         MOV     DPH,R5
   \   00005B   F0           MOVX    @DPTR,A
   \   00005C   A3           INC     DPTR
   1656          
   1657            // Should point to the frame payload
   1658            return ( pData );
   \   00005D   AA82         MOV     R2,DPL
   \   00005F   AB83         MOV     R3,DPH
   \   000061   7F01         MOV     R7,#0x1
   \   000063   02....       LJMP    ?BANKED_LEAVE_XDATA
   1659          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   0C           INC     R4
   \   000008   AD83         MOV     R5,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   FE           MOV     R6,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   4E           ORL     A,R6
   \   000007                REQUIRE ??Subroutine124_0
   \   000007                ; // Fall through to label ??Subroutine124_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine124_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   AC82         MOV     R4,DPL
   \   000004   AD83         MOV     R5,DPH
   \   000006                REQUIRE ?Subroutine111
   \   000006                ; // Fall through to label ?Subroutine111

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine111:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   22           RET
   1660          
   1661          /*********************************************************************
   1662           * @fn      zclCalcHdrSize
   1663           *
   1664           * @brief   Calculate the number of bytes needed for an outgoing
   1665           *          ZCL header.
   1666           *
   1667           * @param   hdr - outgoing header information
   1668           *
   1669           * @return  returns the number of bytes needed
   1670           */
   1671          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   1672          {
   1673            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   1674          
   1675            // Add the manfacturer code
   1676            if ( hdr->fc.manuSpecific )
   1677              needed += 2;
   1678          
   1679            return ( needed );
   1680          }
   1681          
   1682          /*********************************************************************
   1683           * @fn      zclFindPlugin
   1684           *
   1685           * @brief   Find the right plugin for a cluster ID
   1686           *
   1687           * @param   clusterID - cluster ID to look for
   1688           * @param   profileID - profile ID
   1689           * 
   1690           * @return  pointer to plugin, NULL if not found
   1691           */
   1692          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   1693          {
   1694            zclLibPlugin_t *pLoop;
   1695            
   1696            (void)profileID;  // Intentionally unreferenced parameter
   1697          
   1698            if ( clusterID != ZCL_INVALID_CLUSTER_ID )
   1699            {
   1700              pLoop = plugins;
   1701              while ( pLoop != NULL )
   1702              {
   1703                if ( clusterID >= pLoop->startClusterID && clusterID <= pLoop->endClusterID )
   1704                  return ( pLoop );
   1705                pLoop = pLoop->next;
   1706              }
   1707            }
   1708            return ( (zclLibPlugin_t *)NULL );
   1709          }
   1710          
   1711          /*********************************************************************
   1712           * @fn      zclFindAttrRec
   1713           *
   1714           * @brief   Find the attribute record that matchs the parameters
   1715           *
   1716           * @param   endpoint - Application's endpoint
   1717           * @param   clusterID - cluster ID
   1718           * @param   attrId - attribute looking for
   1719           *
   1720           * @return  TRUE if record found. FALSE, otherwise.
   1721           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1722          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   1723          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   8C..         MOV     ?V0 + 0,R4
   \   00000D   8D..         MOV     ?V0 + 1,R5
   \   00000F   7412         MOV     A,#0x12
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   1724            uint8 x;
   1725            zclAttrRecsList *pLoop;
   1726          
   1727            pLoop = attrList;
   \                     ??CrossCallReturnLabel_175:
   \   000017   90....       MOV     DPTR,#attrList
   \   00001A   8004         SJMP    ??zclFindAttrRec_0
   1728          
   1729            while ( pLoop != NULL )
   1730            {
   1731              if ( pLoop->endpoint == endpoint )
   1732              {
   1733                for ( x = 0; x < pLoop->numAttributes; x++ )
   1734                {
   1735                  if ( pLoop->attrs[x].clusterID == clusterID && pLoop->attrs[x].attr.attrId == attrId )
   1736                  {
   1737                    *pAttr = pLoop->attrs[x];
   1738                    return ( TRUE ); // EMBEDDED RETURN
   1739                  }
   1740                }
   1741              }
   1742              pLoop = pLoop->next;
   \                     ??zclFindAttrRec_1:
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \                     ??zclFindAttrRec_0:
   \   000020   12....       LCALL   ??Subroutine120_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   000023   7001         JNZ     ??zclFindAttrRec_2
   \   000025   EB           MOV     A,R3
   \                     ??zclFindAttrRec_2:
   \   000026   7003         JNZ     $+5
   \   000028   02....       LJMP    ??zclFindAttrRec_3 & 0xFFFF
   \   00002B   8A82         MOV     DPL,R2
   \   00002D   8B83         MOV     DPH,R3
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   65..         XRL     A,?V0 + 2
   \   000034   70E6         JNZ     ??zclFindAttrRec_1
   \   000036   75..00       MOV     ?V0 + 3,#0x0
   \   000039   EA           MOV     A,R2
   \   00003A   2404         ADD     A,#0x4
   \   00003C   F8           MOV     R0,A
   \   00003D   EB           MOV     A,R3
   \   00003E   3400         ADDC    A,#0x0
   \   000040   F9           MOV     R1,A
   \   000041   88..         MOV     ?V0 + 4,R0
   \   000043   89..         MOV     ?V0 + 5,R1
   \   000045   8002         SJMP    ??zclFindAttrRec_4
   \                     ??zclFindAttrRec_5:
   \   000047   05..         INC     ?V0 + 3
   \                     ??zclFindAttrRec_4:
   \   000049   8A82         MOV     DPL,R2
   \   00004B   8B83         MOV     DPH,R3
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F8           MOV     R0,A
   \   000052   E5..         MOV     A,?V0 + 3
   \   000054   C3           CLR     C
   \   000055   98           SUBB    A,R0
   \   000056   50C4         JNC     ??zclFindAttrRec_1
   \   000058   85....       MOV     ?V0 + 8,?V0 + 3
   \   00005B   75..00       MOV     ?V0 + 9,#0x0
   \   00005E   7403         MOV     A,#0x3
   \   000060   78..         MOV     R0,#?V0 + 8
   \   000062   12....       LCALL   ?S_SHL
   \   000065   85....       MOV     ?V0 + 6,?V0 + 8
   \   000068   85....       MOV     ?V0 + 7,?V0 + 9
   \   00006B   85..82       MOV     DPL,?V0 + 4
   \   00006E   85..83       MOV     DPH,?V0 + 5
   \   000071   E0           MOVX    A,@DPTR
   \   000072   25..         ADD     A,?V0 + 6
   \   000074   F8           MOV     R0,A
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   35..         ADDC    A,?V0 + 7
   \   000079   F9           MOV     R1,A
   \   00007A   8882         MOV     DPL,R0
   \   00007C   8983         MOV     DPH,R1
   \   00007E   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000081   EE           MOV     A,R6
   \   000082   68           XRL     A,R0
   \   000083   7002         JNZ     ??zclFindAttrRec_6
   \   000085   EF           MOV     A,R7
   \   000086   69           XRL     A,R1
   \                     ??zclFindAttrRec_6:
   \   000087   70BE         JNZ     ??zclFindAttrRec_5
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   00008E   E5..         MOV     A,?V0 + 0
   \   000090   68           XRL     A,R0
   \   000091   7003         JNZ     ??zclFindAttrRec_7
   \   000093   E5..         MOV     A,?V0 + 1
   \   000095   69           XRL     A,R1
   \                     ??zclFindAttrRec_7:
   \   000096   70AF         JNZ     ??zclFindAttrRec_5
   \   000098   85..82       MOV     DPL,?V0 + 4
   \   00009B   85..83       MOV     DPH,?V0 + 5
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   25..         ADD     A,?V0 + 6
   \   0000A1   FA           MOV     R2,A
   \   0000A2   A3           INC     DPTR
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   35..         ADDC    A,?V0 + 7
   \   0000A6   8A82         MOV     DPL,R2
   \   0000A8   F583         MOV     DPH,A
   \   0000AA   7408         MOV     A,#0x8
   \   0000AC   12....       LCALL   ?MOVE_LONG8_XDATA_CODE
   \   0000AF   7901         MOV     R1,#0x1
   \   0000B1   8002         SJMP    ??zclFindAttrRec_8
   1743            }
   1744          
   1745            return ( FALSE );
   \                     ??zclFindAttrRec_3:
   \   0000B3   7900         MOV     R1,#0x0
   \                     ??zclFindAttrRec_8:
   \   0000B5   7F0A         MOV     R7,#0xa
   \   0000B7   02....       LJMP    ?BANKED_LEAVE_XDATA
   1746          }
   1747          
   1748          /*********************************************************************
   1749           * @fn      zclFindClusterOption
   1750           *
   1751           * @brief   Find the option record that matchs the cluster id
   1752           *
   1753           * @param   endpoint - Application's endpoint
   1754           * @param   clusterID - cluster ID looking for
   1755           *
   1756           * @return  pointer to clutser option, NULL if not found
   1757           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1758          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   1759          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   1760            uint8 x;
   1761            zclClusterOptionList *pLoop;
   1762          
   1763            pLoop = clusterOptionList;
   \   000007   90....       MOV     DPTR,#clusterOptionList
   \   00000A   8004         SJMP    ??zclFindClusterOption_0
   1764          
   1765            while ( pLoop != NULL )
   1766            {
   1767              if ( pLoop->endpoint == endpoint )
   1768              {
   1769                for ( x = 0; x < pLoop->numOptions; x++ )
   1770                {
   1771                  if ( pLoop->options[x].clusterID == clusterID )
   1772                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   1773                }
   1774              }
   1775              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   00000C   8882         MOV     DPL,R0
   \   00000E   8983         MOV     DPH,R1
   \                     ??zclFindClusterOption_0:
   \   000010   12....       LCALL   ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   000013   7001         JNZ     ??zclFindClusterOption_2
   \   000015   E9           MOV     A,R1
   \                     ??zclFindClusterOption_2:
   \   000016   605F         JZ      ??zclFindClusterOption_3
   \   000018   8882         MOV     DPL,R0
   \   00001A   8983         MOV     DPH,R1
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   65..         XRL     A,?V0 + 0
   \   000021   70E9         JNZ     ??zclFindClusterOption_1
   \   000023   75..00       MOV     ?V0 + 2,#0x0
   \   000026   E8           MOV     A,R0
   \   000027   2404         ADD     A,#0x4
   \   000029   FC           MOV     R4,A
   \   00002A   E9           MOV     A,R1
   \   00002B   3400         ADDC    A,#0x0
   \   00002D   FD           MOV     R5,A
   \   00002E   EC           MOV     A,R4
   \   00002F   FE           MOV     R6,A
   \   000030   ED           MOV     A,R5
   \   000031   FF           MOV     R7,A
   \   000032   8002         SJMP    ??zclFindClusterOption_4
   \                     ??zclFindClusterOption_5:
   \   000034   05..         INC     ?V0 + 2
   \                     ??zclFindClusterOption_4:
   \   000036   8882         MOV     DPL,R0
   \   000038   8983         MOV     DPH,R1
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FC           MOV     R4,A
   \   00003F   E5..         MOV     A,?V0 + 2
   \   000041   C3           CLR     C
   \   000042   9C           SUBB    A,R4
   \   000043   50C7         JNC     ??zclFindClusterOption_1
   \   000045   E5..         MOV     A,?V0 + 2
   \   000047   75F003       MOV     B,#0x3
   \   00004A   A4           MUL     AB
   \   00004B   FC           MOV     R4,A
   \   00004C   85F0..       MOV     ?V0 + 1,B
   \   00004F   AD..         MOV     R5,?V0 + 1
   \   000051   8E82         MOV     DPL,R6
   \   000053   8F83         MOV     DPH,R7
   \   000055   E0           MOVX    A,@DPTR
   \   000056   2C           ADD     A,R4
   \   000057   F5..         MOV     ?V0 + 1,A
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   3D           ADDC    A,R5
   \   00005C   85..82       MOV     DPL,?V0 + 1
   \   00005F   F583         MOV     DPH,A
   \   000061   E0           MOVX    A,@DPTR
   \   000062   6A           XRL     A,R2
   \   000063   7003         JNZ     ??zclFindClusterOption_6
   \   000065   A3           INC     DPTR
   \   000066   E0           MOVX    A,@DPTR
   \   000067   6B           XRL     A,R3
   \                     ??zclFindClusterOption_6:
   \   000068   70CA         JNZ     ??zclFindClusterOption_5
   \   00006A   8E82         MOV     DPL,R6
   \   00006C   8F83         MOV     DPH,R7
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   2C           ADD     A,R4
   \   000070   FA           MOV     R2,A
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   3D           ADDC    A,R5
   \   000074   FB           MOV     R3,A
   \   000075   8004         SJMP    ??zclFindClusterOption_7
   1776            }
   1777          
   1778            return ( NULL );
   \                     ??zclFindClusterOption_3:
   \   000077   7A00         MOV     R2,#0x0
   \   000079   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_7:
   \   00007B                REQUIRE ?Subroutine117
   \   00007B                ; // Fall through to label ?Subroutine117
   1779          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine117:
   \   000000   7F03         MOV     R7,#0x3
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1780          
   1781          /*********************************************************************
   1782           * @fn      zclGetClusterOption
   1783           *
   1784           * @brief   Get the option record that matchs the cluster id
   1785           *
   1786           * @param   endpoint - Application's endpoint
   1787           * @param   clusterID - cluster ID looking for
   1788           *
   1789           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   1790           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1791          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   1792          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1793            uint8 option;
   1794            zclOptionRec_t *pOption;
   1795          
   1796             pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption
   \   000005   12....       LCALL   ??zclFindClusterOption?relay
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   1797            if ( pOption != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   7002         JNZ     ??zclGetClusterOption_0
   \   000010   E583         MOV     A,DPH
   \                     ??zclGetClusterOption_0:
   \   000012   6008         JZ      ??zclGetClusterOption_1
   1798            {
   1799              option = pOption->option;
   1800              if ( !ZG_SECURE_ENABLED )
   1801                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   1802          
   1803              return ( option ); // EMBEDDED RETURN
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   54BF         ANL     A,#0xbf
   \   000019   F9           MOV     R1,A
   \   00001A   8002         SJMP    ??zclGetClusterOption_2
   1804            }
   1805          
   1806            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_1:
   \   00001C   7900         MOV     R1,#0x0
   \                     ??zclGetClusterOption_2:
   \   00001E   80..         SJMP    ?Subroutine113
   1807          }
   1808          
   1809          /*********************************************************************
   1810           * @fn      zclSetSecurityOption
   1811           *
   1812           * @brief   Set the security option for the cluster id
   1813           *
   1814           * @param   endpoint - Application's endpoint
   1815           * @param   clusterID - cluster ID looking for
   1816           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   1817           *
   1818           * @return  none
   1819           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1820          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   1821          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   1822            zclOptionRec_t *pOption;
   1823          
   1824            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL   ??zclFindClusterOption?relay
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   A8..         MOV     R0,?V0 + 0
   \   000010   A9..         MOV     R1,?V0 + 1
   1825            if ( pOption != NULL )
   \   000012   E8           MOV     A,R0
   \   000013   7001         JNZ     ??zclSetSecurityOption_0
   \   000015   E9           MOV     A,R1
   \                     ??zclSetSecurityOption_0:
   \   000016   6016         JZ      ??zclSetSecurityOption_1
   1826            {
   1827              if ( enable )
   \   000018   E8           MOV     A,R0
   \   000019   2402         ADD     A,#0x2
   \   00001B   F582         MOV     DPL,A
   \   00001D   E9           MOV     A,R1
   \   00001E   3400         ADDC    A,#0x0
   \   000020   F583         MOV     DPH,A
   \   000022   EE           MOV     A,R6
   \   000023   6005         JZ      ??zclSetSecurityOption_2
   1828                pOption->option |= AF_EN_SECURITY;
   \   000025   E0           MOVX    A,@DPTR
   \   000026   D2E6         SETB    0xE0 /* A   */.6
   \   000028   8003         SJMP    ??zclSetSecurityOption_3
   1829              else
   1830                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_2:
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   C2E6         CLR     0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_3:
   \   00002D   F0           MOVX    @DPTR,A
   1831            }
   1832          }
   \                     ??zclSetSecurityOption_1:
   \   00002E                REQUIRE ?Subroutine113
   \   00002E                ; // Fall through to label ?Subroutine113
   1833          
   1834          #ifdef ZCL_DISCOVER
   1835          /*********************************************************************
   1836           * @fn      zclFindNextAttrRec
   1837           *
   1838           * @brief   Find the attribute (or next) record that matchs the parameters
   1839           *
   1840           * @param   endpoint - Application's endpoint
   1841           * @param   clusterID - cluster ID
   1842           * @param   attr - attribute looking for
   1843           *
   1844           * @return  pointer to attribute record, NULL if not found
   1845           */
   1846          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID,
   1847                                           uint16 *attrId, zclAttrRec_t *pAttr )
   1848          {
   1849            uint16 x;
   1850            zclAttrRecsList *pLoop;
   1851          
   1852            pLoop = attrList;
   1853          
   1854            while ( pLoop != NULL )
   1855            {
   1856              if ( pLoop->endpoint == endpoint )
   1857              {
   1858                for ( x = 0; x < pLoop->numAttributes; x++ )
   1859                {
   1860                  if ( pLoop->attrs[x].clusterID == clusterID && pLoop->attrs[x].attr.attrId >= *attrId )
   1861                  {
   1862                    *pAttr = pLoop->attrs[x];
   1863                    
   1864                    // Update attribute ID
   1865                    *attrId = pAttr->attr.attrId; 
   1866                    return ( TRUE ); // EMBEDDED RETURN
   1867                  }
   1868                }
   1869              }
   1870              pLoop = pLoop->next;
   1871            }
   1872          
   1873            return ( FALSE );
   1874          }
   1875          #endif // ZCL_DISCOVER
   1876          
   1877          #if defined(ZCL_READ) || defined(ZCL_WRITE) || defined(ZCL_REPORT)
   1878          /*********************************************************************
   1879           * @fn      zclSerializeData
   1880           *
   1881           * @brief   Builds a buffer from the attribute data to sent out over
   1882           *          the air.
   1883           *
   1884           * @param   dataType - data types defined in zcl.h
   1885           * @param   attrData - pointer to the attribute data
   1886           * @param   buf - where to put the serialized data
   1887           *
   1888           * @return  none
   1889           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1890          static void zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   1891          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EC           MOV     A,R4
   \   00000A   FA           MOV     R2,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FB           MOV     R3,A
   1892            uint8 *pStr;
   1893            uint8 len;
   1894          
   1895            switch ( dataType )
   \   00000D   8E..         MOV     ?V0 + 0,R6
   \   00000F   8F..         MOV     ?V0 + 1,R7
   \   000011   75..00       MOV     ?V0 + 2,#0x0
   \   000014   8A82         MOV     DPL,R2
   \   000016   8B83         MOV     DPH,R3
   \   000018   A3           INC     DPTR
   \   000019   AC82         MOV     R4,DPL
   \   00001B   AD83         MOV     R5,DPH
   \   00001D   E9           MOV     A,R1
   \   00001E   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   000021   03           DB        3
   \   000022   41           DB        65
   \   000023   42           DB        66
   \   000024   ....         DW        ??zclSerializeData_0
   \   000026   E0           DB        224
   \   000027   E2           DB        226
   \   000028   ....         DW        ??zclSerializeData_1
   \   00002A   E8           DB        232
   \   00002B   E9           DB        233
   \   00002C   ....         DW        ??zclSerializeData_2
   \   00002E   19           DB        25
   \   00002F   08           DB        8
   \   000030   ....         DW        ??zclSerializeData_3
   \   000032   09           DB        9
   \   000033   ....         DW        ??zclSerializeData_2
   \   000035   0A           DB        10
   \   000036   ....         DW        ??zclSerializeData_4
   \   000038   0B           DB        11
   \   000039   ....         DW        ??zclSerializeData_1
   \   00003B   10           DB        16
   \   00003C   ....         DW        ??zclSerializeData_3
   \   00003E   18           DB        24
   \   00003F   ....         DW        ??zclSerializeData_3
   \   000041   19           DB        25
   \   000042   ....         DW        ??zclSerializeData_2
   \   000044   1A           DB        26
   \   000045   ....         DW        ??zclSerializeData_4
   \   000047   1B           DB        27
   \   000048   ....         DW        ??zclSerializeData_1
   \   00004A   20           DB        32
   \   00004B   ....         DW        ??zclSerializeData_3
   \   00004D   21           DB        33
   \   00004E   ....         DW        ??zclSerializeData_2
   \   000050   22           DB        34
   \   000051   ....         DW        ??zclSerializeData_4
   \   000053   23           DB        35
   \   000054   ....         DW        ??zclSerializeData_1
   \   000056   24           DB        36
   \   000057   ....         DW        ??zclSerializeData_5
   \   000059   25           DB        37
   \   00005A   ....         DW        ??zclSerializeData_6
   \   00005C   28           DB        40
   \   00005D   ....         DW        ??zclSerializeData_3
   \   00005F   29           DB        41
   \   000060   ....         DW        ??zclSerializeData_2
   \   000062   2A           DB        42
   \   000063   ....         DW        ??zclSerializeData_4
   \   000065   2B           DB        43
   \   000066   ....         DW        ??zclSerializeData_1
   \   000068   30           DB        48
   \   000069   ....         DW        ??zclSerializeData_3
   \   00006B   31           DB        49
   \   00006C   ....         DW        ??zclSerializeData_2
   \   00006E   38           DB        56
   \   00006F   ....         DW        ??zclSerializeData_2
   \   000071   39           DB        57
   \   000072   ....         DW        ??zclSerializeData_1
   \   000074   EA           DB        234
   \   000075   ....         DW        ??zclSerializeData_1
   \   000077   F0           DB        240
   \   000078   ....         DW        ??zclSerializeData_7
   \   00007A   ....         DW        ??zclSerializeData_8
   1896            {
   1897              case ZCL_DATATYPE_DATA8:
   1898              case ZCL_DATATYPE_BOOLEAN:
   1899              case ZCL_DATATYPE_BITMAP8:
   1900              case ZCL_DATATYPE_INT8:
   1901              case ZCL_DATATYPE_UINT8:
   1902              case ZCL_DATATYPE_ENUM8:
   1903                *buf = *((uint8 *)attrData);
   \                     ??zclSerializeData_3:
   \   00007C   8E82         MOV     DPL,R6
   \   00007E   8F83         MOV     DPH,R7
   \                     ??zclSerializeData_9:
   \   000080   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000083   F0           MOVX    @DPTR,A
   \   000084   02....       LJMP    ??zclSerializeData_8 & 0xFFFF
   1904                 break;
   1905          
   1906              case ZCL_DATATYPE_DATA16:
   1907              case ZCL_DATATYPE_BITMAP16:
   1908              case ZCL_DATATYPE_UINT16:
   1909              case ZCL_DATATYPE_INT16: 
   1910              case ZCL_DATATYPE_ENUM16:
   1911              case ZCL_DATATYPE_SEMI_PREC:
   1912              case ZCL_DATATYPE_CLUSTER_ID:
   1913              case ZCL_DATATYPE_ATTR_ID:
   1914                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_2:
   \   000087   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   00008A   12....       LCALL   ?Subroutine15 & 0xFFFF
   1915                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_225:
   \   00008D   A3           INC     DPTR
   \   00008E   80F0         SJMP    ??zclSerializeData_9
   1916                break;
   1917          
   1918              case ZCL_DATATYPE_DATA24:
   1919              case ZCL_DATATYPE_BITMAP24: 
   1920              case ZCL_DATATYPE_UINT24:
   1921              case ZCL_DATATYPE_INT24:
   1922                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_4:
   \   000090   8E82         MOV     DPL,R6
   \   000092   8F83         MOV     DPH,R7
   \   000094   78..         MOV     R0,#?V0 + 0
   \   000096   12....       LCALL   ?L_MOV_X
   \   000099   8A82         MOV     DPL,R2
   \   00009B   8B83         MOV     DPH,R3
   \   00009D   E5..         MOV     A,?V0 + 0
   \   00009F   12....       LCALL   ?Subroutine15 & 0xFFFF
   1923                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_226:
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   12....       LCALL   ?L_MOV_X
   \   0000A7   E5..         MOV     A,?V0 + 1
   \   0000A9   8A82         MOV     DPL,R2
   \   0000AB   8B83         MOV     DPH,R3
   \   0000AD   F0           MOVX    @DPTR,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   0A           INC     R2
   \   0000B0   AB83         MOV     R3,DPH
   1924                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \   0000B2   8E82         MOV     DPL,R6
   \   0000B4   8F83         MOV     DPH,R7
   \   0000B6   78..         MOV     R0,#?V0 + 0
   \   0000B8   12....       LCALL   ?L_MOV_X
   \   0000BB   7410         MOV     A,#0x10
   \   0000BD   78..         MOV     R0,#?V0 + 0
   \   0000BF   12....       LCALL   ?UL_SHR
   \   0000C2   8A82         MOV     DPL,R2
   \   0000C4   8B83         MOV     DPH,R3
   \   0000C6   E5..         MOV     A,?V0 + 0
   \   0000C8   80B9         SJMP    ??CrossCallReturnLabel_232
   1925                break;
   1926                
   1927              case ZCL_DATATYPE_DATA32:
   1928              case ZCL_DATATYPE_BITMAP32:
   1929              case ZCL_DATATYPE_UINT32:
   1930              case ZCL_DATATYPE_INT32:
   1931              case ZCL_DATATYPE_SINGLE_PREC:
   1932              case ZCL_DATATYPE_TOD:
   1933              case ZCL_DATATYPE_DATE:
   1934              case ZCL_DATATYPE_UTC:
   1935              case ZCL_DATATYPE_BAC_OID:
   1936                buf = osal_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_1:
   \   0000CA                ; Setup parameters for call to function osal_buffer_uint32
   \   0000CA   8E82         MOV     DPL,R6
   \   0000CC   8F83         MOV     DPH,R7
   \   0000CE   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0000D1   12....       LCALL   ??osal_buffer_uint32?relay
   \   0000D4   7404         MOV     A,#0x4
   \   0000D6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D9   8043         SJMP    ??zclSerializeData_8
   1937                break;
   1938                
   1939              case ZCL_DATATYPE_UINT40:
   1940                pStr = (uint8*)attrData;
   1941                osal_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_5:
   \   0000DB                ; Setup parameters for call to function osal_memcpy
   \   0000DB   78..         MOV     R0,#?V0 + 0
   \   0000DD   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E0   7C05         MOV     R4,#0x5
   \   0000E2   8032         SJMP    ??zclSerializeData_10
   1942                break;
   1943                
   1944              case ZCL_DATATYPE_UINT48:
   1945                pStr = (uint8*)attrData;
   1946                osal_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_6:
   \   0000E4                ; Setup parameters for call to function osal_memcpy
   \   0000E4   78..         MOV     R0,#?V0 + 0
   \   0000E6   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E9   7C06         MOV     R4,#0x6
   \   0000EB   8029         SJMP    ??zclSerializeData_10
   1947                break;
   1948                
   1949              case ZCL_DATATYPE_IEEE_ADDR:
   1950                pStr = (uint8*)attrData;
   1951                osal_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_7:
   \   0000ED                ; Setup parameters for call to function osal_memcpy
   \   0000ED   78..         MOV     R0,#?V0 + 0
   \   0000EF   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000F2   7C08         MOV     R4,#0x8
   \   0000F4   8020         SJMP    ??zclSerializeData_10
   1952                break;
   1953                
   1954              case ZCL_DATATYPE_CHAR_STR:
   1955              case ZCL_DATATYPE_OCTET_STR:
   1956                pStr = (uint8*)attrData;
   1957                len = *pStr++;
   \                     ??zclSerializeData_0:
   \   0000F6   8E82         MOV     DPL,R6
   \   0000F8   8F83         MOV     DPH,R7
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   F5..         MOV     ?V0 + 3,A
   \   0000FD   A3           INC     DPTR
   \   0000FE   AE82         MOV     R6,DPL
   \   000100   AF83         MOV     R7,DPH
   1958                *buf++ = len;
   \   000102   8A82         MOV     DPL,R2
   \   000104   8B83         MOV     DPH,R3
   \   000106   F0           MOVX    @DPTR,A
   \   000107   EC           MOV     A,R4
   \   000108   FA           MOV     R2,A
   \   000109   ED           MOV     A,R5
   \   00010A   FB           MOV     R3,A
   1959                osal_memcpy( buf, pStr, len );
   \   00010B                ; Setup parameters for call to function osal_memcpy
   \   00010B   8E..         MOV     ?V0 + 0,R6
   \   00010D   8F..         MOV     ?V0 + 1,R7
   \   00010F   78..         MOV     R0,#?V0 + 0
   \   000111   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000114   AC..         MOV     R4,?V0 + 3
   \                     ??zclSerializeData_10:
   \   000116   7D00         MOV     R5,#0x0
   1960                break;
   1961                
   1962              case ZCL_DATATYPE_NO_DATA:
   1963              case ZCL_DATATYPE_UNKNOWN:
   1964                // Fall through
   1965          
   1966              default:
   1967                break;
   1968            }
   \   000118   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   00011B   12....       LCALL   ?DEALLOC_XSTACK8
   1969          }
   \                     ??zclSerializeData_8:
   \   00011E   02....       LJMP    ?Subroutine104 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EC           MOV     A,R4
   \   000002   FA           MOV     R2,A
   \   000003   ED           MOV     A,R5
   \   000004   FB           MOV     R3,A
   \   000005                REQUIRE ?Subroutine112
   \   000005                ; // Fall through to label ?Subroutine112

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine139_0
   \   000004                ; // Fall through to label ??Subroutine139_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine139_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   02....       LJMP    ?Subroutine111 & 0xFFFF
   1970          #endif // ZCL_READ || ZCL_WRITE || ZCL_REPORT
   1971          
   1972          #ifdef ZCL_REPORT
   1973          /*********************************************************************
   1974           * @fn      zclAnalogDataType
   1975           *
   1976           * @brief   Checks to see if Data Type is Analog
   1977           *
   1978           * @param   dataType - data type
   1979           *
   1980           * @return  TRUE if data type is analog
   1981           */
   1982          uint8 zclAnalogDataType( uint8 dataType )
   1983          {
   1984            uint8 analog;
   1985            
   1986            switch ( dataType )
   1987            {
   1988              case ZCL_DATATYPE_UINT8:
   1989              case ZCL_DATATYPE_UINT16:
   1990              case ZCL_DATATYPE_UINT24:
   1991              case ZCL_DATATYPE_UINT32:
   1992              case ZCL_DATATYPE_UINT40:
   1993              case ZCL_DATATYPE_UINT48:
   1994              case ZCL_DATATYPE_INT8:
   1995              case ZCL_DATATYPE_INT16:
   1996              case ZCL_DATATYPE_INT24:
   1997              case ZCL_DATATYPE_INT32:
   1998              case ZCL_DATATYPE_SEMI_PREC:
   1999              case ZCL_DATATYPE_SINGLE_PREC:
   2000              case ZCL_DATATYPE_DOUBLE_PREC:
   2001              case ZCL_DATATYPE_TOD:
   2002              case ZCL_DATATYPE_DATE:
   2003              case ZCL_DATATYPE_UTC:
   2004                analog = TRUE;
   2005                break;
   2006                
   2007              default:
   2008                analog = FALSE;
   2009                break;
   2010            }
   2011            
   2012            return ( analog );
   2013          }
   2014          
   2015          /*********************************************************************
   2016           * @fn      zcl_BuildAnalogData
   2017           *
   2018           * @brief   Build an analog arribute out of sequential bytes.
   2019           *
   2020           * @param   dataType - type of data
   2021           * @param   pData - pointer to data
   2022           * @param   pBuf - where to put the data
   2023           *
   2024           * @return  none
   2025           */
   2026          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf)
   2027          {
   2028            switch ( dataType )
   2029            {
   2030              case ZCL_DATATYPE_UINT8:
   2031              case ZCL_DATATYPE_INT8:
   2032                *pData = *pBuf;
   2033                break;
   2034          
   2035              case ZCL_DATATYPE_UINT16:
   2036              case ZCL_DATATYPE_INT16:
   2037              case ZCL_DATATYPE_SEMI_PREC:
   2038                *((uint16*)pData) = BUILD_UINT16( pBuf[0], pBuf[1] ); 
   2039                break;
   2040           
   2041              case ZCL_DATATYPE_UINT24:
   2042              case ZCL_DATATYPE_INT24:
   2043                *((uint32*)pData) = osal_build_uint32( pBuf, 3 );
   2044                break;
   2045                
   2046              case ZCL_DATATYPE_UINT32:
   2047              case ZCL_DATATYPE_INT32:
   2048              case ZCL_DATATYPE_SINGLE_PREC:
   2049              case ZCL_DATATYPE_TOD:
   2050              case ZCL_DATATYPE_DATE:
   2051              case ZCL_DATATYPE_UTC:
   2052                *((uint32*)pData) = osal_build_uint32( pBuf, 4 );
   2053                break;
   2054                
   2055              case ZCL_DATATYPE_DOUBLE_PREC:
   2056                *pData = 0;
   2057                break;
   2058           
   2059              default:
   2060                break;
   2061            }
   2062          }
   2063          #endif // ZCL_REPORT
   2064          
   2065          /*********************************************************************
   2066           * @fn      zclGetDataTypeLength
   2067           *
   2068           * @brief   Return the length of the datatype in length. 
   2069           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or 
   2070           *                ZCL_DATATYPE_CHAR_STR data types.
   2071           *
   2072           * @param   dataType - data type
   2073           *
   2074           * @return  length of data
   2075           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2076          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   2077          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2078            uint8 len;
   2079            
   2080            switch ( dataType )
   \   000004   E9           MOV     A,R1
   \   000005   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclGetDataTypeLength>_0`:
   \   000008   02           DB        2
   \   000009   E0           DB        224
   \   00000A   E2           DB        226
   \   00000B   ....         DW        ??zclGetDataTypeLength_0
   \   00000D   E8           DB        232
   \   00000E   E9           DB        233
   \   00000F   ....         DW        ??zclGetDataTypeLength_1
   \   000011   1A           DB        26
   \   000012   08           DB        8
   \   000013   ....         DW        ??zclGetDataTypeLength_2
   \   000015   09           DB        9
   \   000016   ....         DW        ??zclGetDataTypeLength_1
   \   000018   0A           DB        10
   \   000019   ....         DW        ??zclGetDataTypeLength_3
   \   00001B   0B           DB        11
   \   00001C   ....         DW        ??zclGetDataTypeLength_0
   \   00001E   10           DB        16
   \   00001F   ....         DW        ??zclGetDataTypeLength_2
   \   000021   18           DB        24
   \   000022   ....         DW        ??zclGetDataTypeLength_2
   \   000024   19           DB        25
   \   000025   ....         DW        ??zclGetDataTypeLength_1
   \   000027   1A           DB        26
   \   000028   ....         DW        ??zclGetDataTypeLength_3
   \   00002A   1B           DB        27
   \   00002B   ....         DW        ??zclGetDataTypeLength_0
   \   00002D   20           DB        32
   \   00002E   ....         DW        ??zclGetDataTypeLength_2
   \   000030   21           DB        33
   \   000031   ....         DW        ??zclGetDataTypeLength_1
   \   000033   22           DB        34
   \   000034   ....         DW        ??zclGetDataTypeLength_3
   \   000036   23           DB        35
   \   000037   ....         DW        ??zclGetDataTypeLength_0
   \   000039   24           DB        36
   \   00003A   ....         DW        ??zclGetDataTypeLength_4
   \   00003C   25           DB        37
   \   00003D   ....         DW        ??zclGetDataTypeLength_5
   \   00003F   28           DB        40
   \   000040   ....         DW        ??zclGetDataTypeLength_2
   \   000042   29           DB        41
   \   000043   ....         DW        ??zclGetDataTypeLength_1
   \   000045   2A           DB        42
   \   000046   ....         DW        ??zclGetDataTypeLength_3
   \   000048   2B           DB        43
   \   000049   ....         DW        ??zclGetDataTypeLength_0
   \   00004B   30           DB        48
   \   00004C   ....         DW        ??zclGetDataTypeLength_2
   \   00004E   31           DB        49
   \   00004F   ....         DW        ??zclGetDataTypeLength_1
   \   000051   38           DB        56
   \   000052   ....         DW        ??zclGetDataTypeLength_1
   \   000054   39           DB        57
   \   000055   ....         DW        ??zclGetDataTypeLength_0
   \   000057   3A           DB        58
   \   000058   ....         DW        ??zclGetDataTypeLength_6
   \   00005A   EA           DB        234
   \   00005B   ....         DW        ??zclGetDataTypeLength_0
   \   00005D   F0           DB        240
   \   00005E   ....         DW        ??zclGetDataTypeLength_6
   \   000060   ....         DW        ??zclGetDataTypeLength_7
   2081            {
   2082              case ZCL_DATATYPE_DATA8:
   2083              case ZCL_DATATYPE_BOOLEAN:
   2084              case ZCL_DATATYPE_BITMAP8:
   2085              case ZCL_DATATYPE_INT8:
   2086              case ZCL_DATATYPE_UINT8:
   2087              case ZCL_DATATYPE_ENUM8:
   2088                len = 1;
   \                     ??zclGetDataTypeLength_2:
   \   000062   7901         MOV     R1,#0x1
   \   000064   801A         SJMP    ??zclGetDataTypeLength_8
   2089                break;
   2090                
   2091              case ZCL_DATATYPE_DATA16:
   2092              case ZCL_DATATYPE_BITMAP16:
   2093              case ZCL_DATATYPE_UINT16:
   2094              case ZCL_DATATYPE_INT16: 
   2095              case ZCL_DATATYPE_ENUM16:
   2096              case ZCL_DATATYPE_SEMI_PREC:
   2097              case ZCL_DATATYPE_CLUSTER_ID:
   2098              case ZCL_DATATYPE_ATTR_ID:
   2099                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000066   7902         MOV     R1,#0x2
   \   000068   8016         SJMP    ??zclGetDataTypeLength_8
   2100                break;
   2101                
   2102              case ZCL_DATATYPE_DATA24:
   2103              case ZCL_DATATYPE_BITMAP24: 
   2104              case ZCL_DATATYPE_UINT24:
   2105              case ZCL_DATATYPE_INT24:
   2106                len = 3;
   \                     ??zclGetDataTypeLength_3:
   \   00006A   7903         MOV     R1,#0x3
   \   00006C   8012         SJMP    ??zclGetDataTypeLength_8
   2107                break;
   2108                
   2109              case ZCL_DATATYPE_DATA32:
   2110              case ZCL_DATATYPE_BITMAP32:
   2111              case ZCL_DATATYPE_UINT32:
   2112              case ZCL_DATATYPE_INT32:
   2113              case ZCL_DATATYPE_SINGLE_PREC:
   2114              case ZCL_DATATYPE_TOD:
   2115              case ZCL_DATATYPE_DATE:
   2116              case ZCL_DATATYPE_UTC:
   2117              case ZCL_DATATYPE_BAC_OID:
   2118                len = 4;
   \                     ??zclGetDataTypeLength_0:
   \   00006E   7904         MOV     R1,#0x4
   \   000070   800E         SJMP    ??zclGetDataTypeLength_8
   2119                break;                       
   2120                          
   2121             case ZCL_DATATYPE_UINT40:
   2122                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   000072   7905         MOV     R1,#0x5
   \   000074   800A         SJMP    ??zclGetDataTypeLength_8
   2123                 break;
   2124                 
   2125             case ZCL_DATATYPE_UINT48:
   2126                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000076   7906         MOV     R1,#0x6
   \   000078   8006         SJMP    ??zclGetDataTypeLength_8
   2127                 break;
   2128                 
   2129             case ZCL_DATATYPE_DOUBLE_PREC:
   2130             case ZCL_DATATYPE_IEEE_ADDR:
   2131               len = 8;
   \                     ??zclGetDataTypeLength_6:
   \   00007A   7908         MOV     R1,#0x8
   \   00007C   8002         SJMP    ??zclGetDataTypeLength_8
   2132               break;
   2133          
   2134              case ZCL_DATATYPE_NO_DATA:
   2135              case ZCL_DATATYPE_UNKNOWN:
   2136                // Fall through
   2137                
   2138              default:
   2139                len = 0;
   \                     ??zclGetDataTypeLength_7:
   \   00007E   7900         MOV     R1,#0x0
   2140                break;
   2141            }
   2142            
   2143            return ( len );
   \                     ??zclGetDataTypeLength_8:
   \   000080   02....       LJMP    ?Subroutine103 & 0xFFFF
   2144          }
   2145          
   2146          /*********************************************************************
   2147           * @fn      zclGetAttrDataLength
   2148           *
   2149           * @brief   Return the length of the attribute.
   2150           *
   2151           * @param   dataType - data type
   2152           * @param   pData - pointer to data
   2153           *
   2154           * @return  returns atrribute lentgh
   2155           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2156          uint8 zclGetAttrDataLength( uint8  dataType, uint8 *pData)
   \                     zclGetAttrDataLength:
   2157          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2158            uint8 dataLen = 0;
   2159            
   2160            if ( dataType  == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \   000004   7442         MOV     A,#0x42
   \   000006   69           XRL     A,R1
   \   000007   6005         JZ      ??zclGetAttrDataLength_0
   \   000009   7441         MOV     A,#0x41
   \   00000B   69           XRL     A,R1
   \   00000C   7009         JNZ     ??zclGetAttrDataLength_1
   2161            {
   2162              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_0:
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   E0           MOVX    A,@DPTR
   \   000013   04           INC     A
   \   000014   F9           MOV     R1,A
   \   000015   8003         SJMP    ??zclGetAttrDataLength_2
   2163            }
   2164            else
   2165            {
   2166              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_1:
   \   000017                ; Setup parameters for call to function zclGetDataTypeLength
   \   000017   12....       LCALL   ??zclGetDataTypeLength?relay
   2167            }
   2168          
   2169            return ( dataLen );
   \                     ??zclGetAttrDataLength_2:
   \   00001A   02....       LJMP    ?Subroutine103 & 0xFFFF
   2170          }
   2171          
   2172          /*********************************************************************
   2173           * @fn      zclReadAttrData
   2174           *
   2175           * @brief   Read the attribute's current value into pAttrData.
   2176           *
   2177           * @param   pAttrData - where to put attribute data
   2178           * @param   pAttr - pointer to attribute
   2179           *
   2180           * @return Success
   2181           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2182          uint8 zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr )
   \                     zclReadAttrData:
   2183          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2184            uint8 dataLen;
   2185              
   2186            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \   000009   EC           MOV     A,R4
   \   00000A   2406         ADD     A,#0x6
   \   00000C   F8           MOV     R0,A
   \   00000D   ED           MOV     A,R5
   \   00000E   3400         ADDC    A,#0x0
   \   000010   F9           MOV     R1,A
   \   000011   88..         MOV     ?V0 + 0,R0
   \   000013   89..         MOV     ?V0 + 1,R1
   \   000015                ; Setup parameters for call to function zclGetAttrDataLength
   \   000015   8882         MOV     DPL,R0
   \   000017   F583         MOV     DPH,A
   \   000019   12....       LCALL   ??Subroutine131_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   00001C   8C82         MOV     DPL,R4
   \   00001E   8D83         MOV     DPH,R5
   \   000020   12....       LCALL   ?Subroutine29 & 0xFFFF
   2187            osal_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \                     ??CrossCallReturnLabel_186:
   \   000023                ; Setup parameters for call to function osal_memcpy
   \   000023   85..82       MOV     DPL,?V0 + 0
   \   000026   85..83       MOV     DPH,?V0 + 1
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F5..         MOV     ?V0 + 0,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F5..         MOV     ?V0 + 1,A
   \   000030   75..00       MOV     ?V0 + 2,#0x0
   \   000033   78..         MOV     R0,#?V0 + 0
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000038   EA           MOV     A,R2
   \   000039   FC           MOV     R4,A
   \   00003A   7D00         MOV     R5,#0x0
   \   00003C   EE           MOV     A,R6
   \   00003D   FA           MOV     R2,A
   \   00003E   EF           MOV     A,R7
   \   00003F   FB           MOV     R3,A
   \   000040   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   2188              
   2189            return ( ZCL_STATUS_SUCCESS );
   \   000046   7900         MOV     R1,#0x0
   \   000048   02....       LJMP    ?Subroutine117 & 0xFFFF
   2190          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine129_0
   \   000002                ; // Fall through to label ??Subroutine129_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine129_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine130_0
   \   000002                ; // Fall through to label ??Subroutine130_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine130_0:
   \   000000   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   000003   FA           MOV     R2,A
   \   000004   22           RET
   2191          
   2192          #ifdef ZCL_WRITE
   2193          /*********************************************************************
   2194           * @fn      zclWriteAttrData
   2195           *
   2196           * @brief   Write the received data.
   2197           *
   2198           * @param   pAttr - where to write data to
   2199           * @param   pWriteRec - data to be written
   2200           *
   2201           * @return  Successful if data was written
   2202           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2203          static uint8 zclWriteAttrData( zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   \                     zclWriteAttrData:
   2204          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   2205            uint8 len;
   2206          
   2207            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   A2E1         MOV     C,0xE0 /* A   */.1
   \   000019   5058         JNC     ??zclWriteAttrData_0
   2208            {
   2209              if ( zcl_ValidateAttrDataCB && !zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \   00001B   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   7002         JNZ     ??zclWriteAttrData_1
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \                     ??zclWriteAttrData_1:
   \   000023   6010         JZ      ??zclWriteAttrData_2
   \   000025                ; Setup parameters for indirect call
   \   000025   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000028   12....       LCALL   ??Subroutine142_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   00002B   12....       LCALL   ?CALL_IND
   \   00002E   E9           MOV     A,R1
   \   00002F   7004         JNZ     ??zclWriteAttrData_2
   2210                return ( ZCL_STATUS_INVALID_VALUE );
   \   000031   7987         MOV     R1,#-0x79
   \   000033   8040         SJMP    ??zclWriteAttrData_3
   2211              
   2212              len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000035   EE           MOV     A,R6
   \   000036   2403         ADD     A,#0x3
   \   000038   EF           MOV     A,R7
   \   000039   3400         ADDC    A,#0x0
   \   00003B   0E           INC     R6
   \   00003C   0E           INC     R6
   \   00003D   0E           INC     R6
   \   00003E   FF           MOV     R7,A
   \   00003F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00003F   8E82         MOV     DPL,R6
   \   000041   8F83         MOV     DPH,R7
   \   000043   12....       LCALL   ??Subroutine131_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   000046   85..82       MOV     DPL,?V0 + 0
   \   000049   85..83       MOV     DPH,?V0 + 1
   \   00004C   12....       LCALL   ?Subroutine29 & 0xFFFF
   2213              osal_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \                     ??CrossCallReturnLabel_187:
   \   00004F                ; Setup parameters for call to function osal_memcpy
   \   00004F   8E82         MOV     DPL,R6
   \   000051   8F83         MOV     DPH,R7
   \   000053   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000059   EA           MOV     A,R2
   \   00005A   FC           MOV     R4,A
   \   00005B   7D00         MOV     R5,#0x0
   \   00005D   85..82       MOV     DPL,?V0 + 0
   \   000060   85..83       MOV     DPH,?V0 + 1
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   00006C   12....       LCALL   ?DEALLOC_XSTACK8
   2214              return ( ZCL_STATUS_SUCCESS );
   \   00006F   7900         MOV     R1,#0x0
   \   000071   8002         SJMP    ??zclWriteAttrData_3
   2215            }
   2216              
   2217            return ( ZCL_STATUS_READ_ONLY );
   \                     ??zclWriteAttrData_0:
   \   000073   7988         MOV     R1,#-0x78
   \                     ??zclWriteAttrData_3:
   \   000075   7F07         MOV     R7,#0x7
   \   000077   02....       LJMP    ?BANKED_LEAVE_XDATA
   2218          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine108:
   \   000000   75..00       MOV     ?V0 + 6,#0x0
   \   000003   78..         MOV     R0,#?V0 + 4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine142_0:
   \   000000   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_252:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   000003   02....       LJMP    ?Subroutine107 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000003   02....       LJMP    ?Subroutine108 & 0xFFFF
   2219          #endif // ZCL_WRITE
   2220          
   2221          #ifdef ZCL_READ
   2222          /*********************************************************************
   2223           * @fn      zclParseInReadCmd
   2224           *
   2225           * @brief   Parse the "Profile" Read Commands
   2226           *
   2227           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2228           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2229           *
   2230           * @param   pCmd - pointer to incoming data to parse
   2231           *
   2232           * @return  pointer to the parsed command structure
   2233           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2234          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   2235          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   2236            zclReadCmd_t *readCmd;
   2237            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   00000C   FE           MOV     R6,A
   \   00000D   E9           MOV     A,R1
   \   00000E   FF           MOV     R7,A
   2238            
   2239            readCmd = (zclReadCmd_t *)osal_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \   00000F   12....       LCALL   ?Subroutine32 & 0xFFFF
   2240            if ( readCmd != NULL )
   \                     ??CrossCallReturnLabel_36:
   \   000012   7001         JNZ     ??zclParseInReadCmd_0
   \   000014   EB           MOV     A,R3
   \                     ??zclParseInReadCmd_0:
   \   000015   6049         JZ      ??zclParseInReadCmd_1
   2241            {
   2242              uint8 i;
   2243              
   2244              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   000017   85..82       MOV     DPL,?V0 + 0
   \   00001A   85..83       MOV     DPH,?V0 + 1
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   C3           CLR     C
   \   000022   13           RRC     A
   \   000023   E8           MOV     A,R0
   \   000024   13           RRC     A
   \   000025   8A82         MOV     DPL,R2
   \   000027   8B83         MOV     DPH,R3
   \   000029   F0           MOVX    @DPTR,A
   2245              for ( i = 0; i < readCmd->numAttr; i++ )
   \   00002A   75..00       MOV     ?V0 + 0,#0x0
   \   00002D   8025         SJMP    ??zclParseInReadCmd_2
   2246              {
   2247                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_3:
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   12....       LCALL   ?Subroutine86 & 0xFFFF
   2248                pBuf += 2;
   2249              }
   \                     ??CrossCallReturnLabel_262:
   \   000036   F9           MOV     R1,A
   \   000037   E4           CLR     A
   \   000038   2C           ADD     A,R4
   \   000039   E9           MOV     A,R1
   \   00003A   FD           MOV     R5,A
   \   00003B   E5..         MOV     A,?V0 + 0
   \   00003D   33           RLC     A
   \   00003E   F8           MOV     R0,A
   \   00003F   E4           CLR     A
   \   000040   33           RLC     A
   \   000041   F9           MOV     R1,A
   \   000042   EA           MOV     A,R2
   \   000043   28           ADD     A,R0
   \   000044   F582         MOV     DPL,A
   \   000046   EB           MOV     A,R3
   \   000047   39           ADDC    A,R1
   \   000048   F583         MOV     DPH,A
   \   00004A   A3           INC     DPTR
   \   00004B   EC           MOV     A,R4
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   A3           INC     DPTR
   \   00004E   ED           MOV     A,R5
   \   00004F   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000052   05..         INC     ?V0 + 0
   \                     ??zclParseInReadCmd_2:
   \   000054   8A82         MOV     DPL,R2
   \   000056   8B83         MOV     DPH,R3
   \   000058   E0           MOVX    A,@DPTR
   \   000059   FC           MOV     R4,A
   \   00005A   E5..         MOV     A,?V0 + 0
   \   00005C   C3           CLR     C
   \   00005D   9C           SUBB    A,R4
   \   00005E   40CF         JC      ??zclParseInReadCmd_3
   2250            }
   2251          
   2252            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_1:
   \   000060   02....       LJMP    ?Subroutine104 & 0xFFFF
   2253          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   8582..       MOV     ?V0 + 0,DPL
   \   000008   8583..       MOV     ?V0 + 1,DPH
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   2401         ADD     A,#0x1
   \   00000E   FA           MOV     R2,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   3400         ADDC    A,#0x0
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??osal_mem_alloc?relay
   \   000017   EA           MOV     A,R2
   \   000018   22           RET
   2254          
   2255          /*********************************************************************
   2256           * @fn      zclParseInReadRspCmd
   2257           *
   2258           * @brief   Parse the "Profile" Read Response Commands
   2259           *
   2260           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2261           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2262           *
   2263           * @param   pCmd - pointer to incoming data to parse
   2264           *
   2265           * @return  pointer to the parsed command structure
   2266           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   E9           MOV     A,R1
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   FC           MOV     R4,A
   \   000004   7D00         MOV     R5,#0x0
   \   000006   AA..         MOV     R2,?V0 + 2
   \   000008   AB..         MOV     R3,?V0 + 3
   \   00000A                REQUIRE ?Subroutine107
   \   00000A                ; // Fall through to label ?Subroutine107

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2267          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   2268          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine38 & 0xFFFF
   2269            zclReadRspCmd_t *readRspCmd;
   2270            zclReadRspStatus_t *statusRec;
   2271            uint8 *pBuf = pCmd->pData;
   2272            uint8 *dataPtr;
   2273            uint8 numAttr = 0;
   2274            uint8 hdrLen;
   2275            uint8 dataLen = 0;
   \                     ??CrossCallReturnLabel_44:
   \   000008   801B         SJMP    ??zclParseInReadRspCmd_0
   2276            uint8 attrDataLen;
   2277            uint8 dataType;
   2278            uint8 status;
   2279            uint8 i;
   2280            
   2281            // find out the number of attributes and the length of attribute data
   2282            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2283            {
   2284              numAttr++;
   \                     ??zclParseInReadRspCmd_1:
   \   00000A   12....       LCALL   ?Subroutine69 & 0xFFFF
   2285          
   2286              pBuf += 2; // move pass attribute id
   2287              
   2288              status = *pBuf++;  
   \                     ??CrossCallReturnLabel_140:
   \   00000D   A3           INC     DPTR
   \   00000E   AE82         MOV     R6,DPL
   \   000010   AF83         MOV     R7,DPH
   2289              if ( status == ZCL_STATUS_SUCCESS )
   \   000012   7011         JNZ     ??zclParseInReadRspCmd_0
   2290              {
   2291                dataType = *pBuf++;
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   A3           INC     DPTR
   \   000017   0E           INC     R6
   \   000018   12....       LCALL   ?Subroutine67 & 0xFFFF
   2292          
   2293                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2294                pBuf += attrDataLen; // move pass attribute data
   2295                
   2296                // add padding if needed
   2297                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_89:
   \   00001B   5002         JNC     ??zclParseInReadRspCmd_2
   2298                  attrDataLen++;
   \   00001D   05..         INC     ?V0 + 8
   2299                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_2:
   \   00001F   E5..         MOV     A,?V0 + 8
   \   000021   25..         ADD     A,?V0 + 6
   \   000023   F5..         MOV     ?V0 + 6,A
   2300              }
   2301            }
   \                     ??zclParseInReadRspCmd_0:
   \   000025   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   000028   40E0         JC      ??zclParseInReadRspCmd_1
   2302            
   2303            // calculate the length of the response header
   2304            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   00002A   75F006       MOV     B,#0x6
   \   00002D   12....       LCALL   ?Subroutine60 & 0xFFFF
   2305            
   2306            readRspCmd = (zclReadRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2307            if ( readRspCmd != NULL )
   \                     ??CrossCallReturnLabel_200:
   \   000030   7001         JNZ     ??zclParseInReadRspCmd_3
   \   000032   EB           MOV     A,R3
   \                     ??zclParseInReadRspCmd_3:
   \   000033   6049         JZ      ??zclParseInReadRspCmd_4
   2308            {
   2309              pBuf = pCmd->pData;
   \   000035   12....       LCALL   ?Subroutine23 & 0xFFFF
   2310              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   2311                  
   2312              readRspCmd->numAttr = numAttr;
   2313              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_26:
   \   000038   803D         SJMP    ??zclParseInReadRspCmd_5
   2314              {
   2315                statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_6:
   \   00003A   E5..         MOV     A,?V0 + 9
   \   00003C   75F006       MOV     B,#0x6
   \   00003F   12....       LCALL   ?Subroutine3 & 0xFFFF
   2316                
   2317                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2318                pBuf += 2;
   2319                
   2320                statusRec->status = *pBuf++;
   \                     ??CrossCallReturnLabel_138:
   \   000042   12....       LCALL   ?Subroutine6 & 0xFFFF
   2321                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_213:
   \   000045   702E         JNZ     ??CrossCallReturnLabel_91
   2322                {
   2323                  statusRec->dataType = *pBuf++;
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F9           MOV     R1,A
   \   000049   85..82       MOV     DPL,?V0 + 10
   \   00004C   85..83       MOV     DPH,?V0 + 11
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   000055   0E           INC     R6
   \   000056   AF83         MOV     R7,DPH
   2324          
   2325                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   000058                ; Setup parameters for call to function zclGetAttrDataLength
   \   000058   12....       LCALL   ?Subroutine71 & 0xFFFF
   2326                  osal_memcpy( dataPtr, pBuf, attrDataLen);
   \                     ??CrossCallReturnLabel_150:
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00005E   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
   2327                  statusRec->data = dataPtr;
   \   000064   85..82       MOV     DPL,?V0 + 10
   \   000067   85..83       MOV     DPH,?V0 + 11
   \   00006A   A3           INC     DPTR
   \   00006B   12....       LCALL   ?Subroutine4 & 0xFFFF
   2328                  
   2329                  pBuf += attrDataLen; // move pass attribute data
   2330                  
   2331                  // advance attribute data pointer
   2332                  if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_6:
   \   00006E   5002         JNC     ??zclParseInReadRspCmd_7
   2333                    attrDataLen++;
   \   000070   05..         INC     ?V0 + 8
   2334                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_7:
   \   000072   12....       LCALL   ?Subroutine68 & 0xFFFF
   2335                }
   2336              }
   \                     ??CrossCallReturnLabel_91:
   \   000075   05..         INC     ?V0 + 9
   \                     ??zclParseInReadRspCmd_5:
   \   000077   E5..         MOV     A,?V0 + 9
   \   000079   C3           CLR     C
   \   00007A   95..         SUBB    A,?V0 + 7
   \   00007C   40BC         JC      ??zclParseInReadRspCmd_6
   2337            }
   2338          
   2339            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_4:
   \   00007E                REQUIRE ?Subroutine118
   \   00007E                ; // Fall through to label ?Subroutine118
   2340          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine118:
   \   000000   AA..         MOV     R2,?V0 + 0
   \   000002   AB..         MOV     R3,?V0 + 1
   \   000004   7F0C         MOV     R7,#0xc
   \   000006   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   E5..         MOV     A,?V0 + 7
   \   000002   A4           MUL     AB
   \   000003   04           INC     A
   \   000004   FA           MOV     R2,A
   \   000005   8A82         MOV     DPL,R2
   \   000007   8582..       MOV     ?V0 + 4,DPL
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A   85....       MOV     ?V0 + 0,?V0 + 6
   \   00000D   E5..         MOV     A,?V0 + 0
   \   00000F   25..         ADD     A,?V0 + 4
   \   000011   FA           MOV     R2,A
   \   000012   E4           CLR     A
   \   000013   3400         ADDC    A,#0x0
   \   000015   FB           MOV     R3,A
   \   000016                REQUIRE ??Subroutine133_0
   \   000016                ; // Fall through to label ??Subroutine133_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine133_0:
   \   000000   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   85..82       MOV     DPL,?V0 + 0
   \   000003   85..83       MOV     DPH,?V0 + 1
   \   000006   A3           INC     DPTR
   \   000007                REQUIRE ??Subroutine134_0
   \   000007                ; // Fall through to label ??Subroutine134_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine134_0:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000003   85..82       MOV     DPL,?V0 + 2
   \   000006   85..83       MOV     DPH,?V0 + 3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   28           ADD     A,R0
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   39           ADDC    A,R1
   \   00000F   F9           MOV     R1,A
   \   000010   C3           CLR     C
   \   000011   EE           MOV     A,R6
   \   000012   98           SUBB    A,R0
   \   000013   EF           MOV     A,R7
   \   000014   99           SUBB    A,R1
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   85..82       MOV     DPL,?V0 + 10
   \   000003   85..83       MOV     DPH,?V0 + 11
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008                REQUIRE ??Subroutine135_0
   \   000008                ; // Fall through to label ??Subroutine135_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   EE           MOV     A,R6
   \   000001   FA           MOV     R2,A
   \   000002   EF           MOV     A,R7
   \   000003   FB           MOV     R3,A
   \   000004   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000007   E9           MOV     A,R1
   \   000008   F5..         MOV     ?V0 + 8,A
   \   00000A                ; Setup parameters for call to function osal_memcpy
   \   00000A                ; Setup parameters for call to function osal_memcpy
   \   00000A   8E..         MOV     ?V0 + 4,R6
   \   00000C   8F..         MOV     ?V0 + 5,R7
   \   00000E                REQUIRE ?Subroutine108
   \   00000E                ; // Fall through to label ?Subroutine108

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   05..         INC     ?V0 + 7
   \   000002   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000005                REQUIRE ?Subroutine106
   \   000005                ; // Fall through to label ?Subroutine106

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine106:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   85....       MOV     ?V0 + 4,?V0 + 8
   \   000003   E5..         MOV     A,?V0 + 2
   \   000005   25..         ADD     A,?V0 + 4
   \   000007   F5..         MOV     ?V0 + 2,A
   \   000009   E5..         MOV     A,?V0 + 3
   \   00000B   3400         ADDC    A,#0x0
   \   00000D   F5..         MOV     ?V0 + 3,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   AF83         MOV     R7,DPH
   \   000002                ; Setup parameters for call to function zclGetAttrDataLength
   \   000002                ; Setup parameters for call to function zclGetAttrDataLength
   \   000002   EE           MOV     A,R6
   \   000003   FA           MOV     R2,A
   \   000004   EF           MOV     A,R7
   \   000005   FB           MOV     R3,A
   \   000006   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000009   E9           MOV     A,R1
   \   00000A   F5..         MOV     ?V0 + 8,A
   \   00000C   F5..         MOV     ?V0 + 4,A
   \   00000E   EE           MOV     A,R6
   \   00000F   25..         ADD     A,?V0 + 4
   \   000011   FE           MOV     R6,A
   \   000012   EF           MOV     A,R7
   \   000013   3400         ADDC    A,#0x0
   \   000015   FF           MOV     R7,A
   \   000016   E9           MOV     A,R1
   \   000017   A2E0         MOV     C,0xE0 /* A   */.0
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   8A..         MOV     ?V0 + 0,R2
   \   000002   8B..         MOV     ?V0 + 1,R3
   \   000004   EA           MOV     A,R2
   \   000005   2403         ADD     A,#0x3
   \   000007   F5..         MOV     ?V0 + 2,A
   \   000009   EB           MOV     A,R3
   \   00000A   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   FE           MOV     R6,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   FF           MOV     R7,A
   \   000012   75..00       MOV     ?V0 + 7,#0x0
   \   000015   75..00       MOV     ?V0 + 6,#0x0
   \   000018   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FE           MOV     R6,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FF           MOV     R7,A
   \   00000B   EA           MOV     A,R2
   \   00000C   25..         ADD     A,?V0 + 4
   \   00000E   F5..         MOV     ?V0 + 2,A
   \   000010   EB           MOV     A,R3
   \   000011   3400         ADDC    A,#0x0
   \   000013   F5..         MOV     ?V0 + 3,A
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   E5..         MOV     A,?V0 + 7
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   75..00       MOV     ?V0 + 9,#0x0
   \   00001F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   E5..         MOV     A,?V0 + 2
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   E5..         MOV     A,?V0 + 3
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   EE           MOV     A,R6
   \   00000B   25..         ADD     A,?V0 + 4
   \   00000D   FE           MOV     R6,A
   \   00000E   EF           MOV     A,R7
   \   00000F   3400         ADDC    A,#0x0
   \   000011   FF           MOV     R7,A
   \   000012   E5..         MOV     A,?V0 + 8
   \   000014   A2E0         MOV     C,0xE0 /* A   */.0
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   000003   A3           INC     DPTR
   \   000004   8582..       MOV     ?V0 + 10,DPL
   \   000007   8583..       MOV     ?V0 + 11,DPH
   \   00000A   8E82         MOV     DPL,R6
   \   00000C   8F83         MOV     DPH,R7
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   FA           MOV     R2,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   \   000013   EA           MOV     A,R2
   \   000014   85..82       MOV     DPL,?V0 + 10
   \   000017   85..83       MOV     DPH,?V0 + 11
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   E9           MOV     A,R1
   \   00001D   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000020   02....       LJMP    ?Subroutine106 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V0 + 0
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V0 + 1
   \   00000B   39           ADDC    A,R1
   \   00000C   F583         MOV     DPH,A
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   12....       LCALL   ??osal_mem_alloc?relay
   \   000003   8A..         MOV     ?V0 + 0,R2
   \   000005   8B..         MOV     ?V0 + 1,R3
   \   000007   EA           MOV     A,R2
   \   000008   22           RET
   2341          #endif // ZCL_READ
   2342          
   2343          #ifdef ZCL_WRITE
   2344          /*********************************************************************
   2345           * @fn      zclParseInWriteCmd
   2346           *
   2347           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   2348           *          Response Commands
   2349           *
   2350           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2351           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2352           * 
   2353           * @param   pCmd - pointer to incoming data to parse
   2354           *
   2355           * @return  pointer to the parsed command structure
   2356           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2357          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   2358          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine38 & 0xFFFF
   2359            zclWriteCmd_t *writeCmd;
   2360            zclWriteRec_t *statusRec;
   2361            uint8 *pBuf = pCmd->pData;
   2362            uint8 attrDataLen;
   2363            uint8 *dataPtr;
   2364            uint8 numAttr = 0;
   2365            uint8 hdrLen;
   2366            uint8 dataLen = 0;
   \                     ??CrossCallReturnLabel_45:
   \   000008   8014         SJMP    ??zclParseInWriteCmd_0
   2367            uint8 dataType;
   2368            uint8 i;
   2369          
   2370            // find out the number of attributes and the length of attribute data
   2371            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2372            {
   2373              numAttr++;
   \                     ??zclParseInWriteCmd_1:
   \   00000A   12....       LCALL   ?Subroutine69 & 0xFFFF
   2374          
   2375              pBuf += 2; // move pass attribute id
   2376          
   2377              dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_141:
   \   00000D   F9           MOV     R1,A
   \   00000E   A3           INC     DPTR
   \   00000F   AE82         MOV     R6,DPL
   \   000011   12....       LCALL   ?Subroutine67 & 0xFFFF
   2378          
   2379              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2380              pBuf += attrDataLen; // move pass attribute data
   2381                
   2382              // add padding if needed
   2383              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_90:
   \   000014   5002         JNC     ??zclParseInWriteCmd_2
   2384                attrDataLen++;
   \   000016   05..         INC     ?V0 + 8
   2385              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_2:
   \   000018   E5..         MOV     A,?V0 + 8
   \   00001A   25..         ADD     A,?V0 + 6
   \   00001C   F5..         MOV     ?V0 + 6,A
   2386            }
   \                     ??zclParseInWriteCmd_0:
   \   00001E   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000021   40E7         JC      ??zclParseInWriteCmd_1
   2387            
   2388            // calculate the length of the response header
   2389            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \   000023   75F005       MOV     B,#0x5
   \   000026   12....       LCALL   ?Subroutine60 & 0xFFFF
   2390            
   2391            writeCmd = (zclWriteCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2392            if ( writeCmd != NULL )
   \                     ??CrossCallReturnLabel_201:
   \   000029   7001         JNZ     ??zclParseInWriteCmd_3
   \   00002B   EB           MOV     A,R3
   \                     ??zclParseInWriteCmd_3:
   \   00002C   6036         JZ      ??zclParseInWriteCmd_4
   2393            {
   2394              pBuf = pCmd->pData;
   \   00002E   12....       LCALL   ?Subroutine23 & 0xFFFF
   2395              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   2396          
   2397              writeCmd->numAttr = numAttr;
   2398              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_27:
   \   000031   802A         SJMP    ??zclParseInWriteCmd_5
   2399              {
   2400                statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_6:
   \   000033   E5..         MOV     A,?V0 + 9
   \   000035   75F005       MOV     B,#0x5
   \   000038   12....       LCALL   ?Subroutine3 & 0xFFFF
   2401                
   2402                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2403                pBuf += 2;
   2404                statusRec->dataType = *pBuf++;
   \                     ??CrossCallReturnLabel_139:
   \   00003B   F9           MOV     R1,A
   \   00003C   12....       LCALL   ?Subroutine6 & 0xFFFF
   2405          
   2406                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_214:
   \   00003F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00003F   12....       LCALL   ?Subroutine71 & 0xFFFF
   2407                osal_memcpy( dataPtr, pBuf, attrDataLen);
   \                     ??CrossCallReturnLabel_151:
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000045   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   2408                statusRec->attrData = dataPtr;
   \   00004B   85..82       MOV     DPL,?V0 + 10
   \   00004E   85..83       MOV     DPH,?V0 + 11
   \   000051   12....       LCALL   ?Subroutine4 & 0xFFFF
   2409                
   2410                pBuf += attrDataLen; // move pass attribute data
   2411                  
   2412                // advance attribute data pointer
   2413                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_7:
   \   000054   5002         JNC     ??zclParseInWriteCmd_7
   2414                  attrDataLen++;
   \   000056   05..         INC     ?V0 + 8
   2415                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_7:
   \   000058   12....       LCALL   ?Subroutine68 & 0xFFFF
   2416              }
   \                     ??CrossCallReturnLabel_92:
   \   00005B   05..         INC     ?V0 + 9
   \                     ??zclParseInWriteCmd_5:
   \   00005D   E5..         MOV     A,?V0 + 9
   \   00005F   C3           CLR     C
   \   000060   95..         SUBB    A,?V0 + 7
   \   000062   40CF         JC      ??zclParseInWriteCmd_6
   2417            }
   2418            
   2419            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_4:
   \   000064   02....       LJMP    ?Subroutine118 & 0xFFFF
   2420          }
   2421          
   2422          /*********************************************************************
   2423           * @fn      zclParseInWriteRspCmd
   2424           *
   2425           * @brief   Parse the "Profile" Write Response Commands
   2426           *
   2427           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2428           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2429           *
   2430           * @param   pCmd - pointer to incoming data to parse
   2431           *
   2432           * @return  pointer to the parsed command structure
   2433           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2434          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   2435          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   2436            zclWriteRspCmd_t *writeRspCmd;
   2437            uint8 *pBuf = pCmd->pData;
   \   000005   EA           MOV     A,R2
   \   000006   2403         ADD     A,#0x3
   \   000008   F5..         MOV     ?V0 + 2,A
   \   00000A   EB           MOV     A,R3
   \   00000B   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   00000E   12....       LCALL   ?Subroutine39 & 0xFFFF
   2438            uint8 i = 0;
   \                     ??CrossCallReturnLabel_47:
   \   000011   75..00       MOV     ?V0 + 4,#0x0
   2439          
   2440            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \   000014   12....       LCALL   ?Subroutine32 & 0xFFFF
   2441            if ( writeRspCmd != NULL )
   \                     ??CrossCallReturnLabel_37:
   \   000017   7001         JNZ     ??zclParseInWriteRspCmd_0
   \   000019   EB           MOV     A,R3
   \                     ??zclParseInWriteRspCmd_0:
   \   00001A   605C         JZ      ??zclParseInWriteRspCmd_1
   2442            {
   2443              if ( pCmd->dataLen == 1 )
   \   00001C   85..82       MOV     DPL,?V0 + 0
   \   00001F   85..83       MOV     DPH,?V0 + 1
   \   000022   E0           MOVX    A,@DPTR
   \   000023   6401         XRL     A,#0x1
   \   000025   7002         JNZ     ??zclParseInWriteRspCmd_2
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \                     ??zclParseInWriteRspCmd_2:
   \   000029   703B         JNZ     ??CrossCallReturnLabel_126
   2444              {
   2445                // special case when all writes were successfull
   2446                writeRspCmd->attrList[i++].status = *pBuf;
   \   00002B   12....       LCALL   ?Subroutine49 & 0xFFFF
   2447              }
   \                     ??CrossCallReturnLabel_236:
   \   00002E   A3           INC     DPTR
   \   00002F   F0           MOVX    @DPTR,A
   \   000030   75..01       MOV     ?V0 + 4,#0x1
   \   000033   803C         SJMP    ??zclParseInWriteRspCmd_3
   2448              else
   2449              {
   2450                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2451                {
   2452                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_4:
   \   000035   E5..         MOV     A,?V0 + 4
   \   000037   75F003       MOV     B,#0x3
   \   00003A   A4           MUL     AB
   \   00003B   F8           MOV     R0,A
   \   00003C   A9F0         MOV     R1,B
   \   00003E   EA           MOV     A,R2
   \   00003F   28           ADD     A,R0
   \   000040   F8           MOV     R0,A
   \   000041   EB           MOV     A,R3
   \   000042   39           ADDC    A,R1
   \   000043   F9           MOV     R1,A
   \   000044   8E82         MOV     DPL,R6
   \   000046   8F83         MOV     DPH,R7
   \   000048   E0           MOVX    A,@DPTR
   \   000049   8882         MOV     DPL,R0
   \   00004B   8983         MOV     DPH,R1
   \   00004D   12....       LCALL   ?Subroutine5 & 0xFFFF
   2453                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_9:
   \   000050   F5..         MOV     ?V0 + 6,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   FD           MOV     R5,A
   \   000055   E5..         MOV     A,?V0 + 6
   \   000057   8882         MOV     DPL,R0
   \   000059   8983         MOV     DPH,R1
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   ED           MOV     A,R5
   \   000060   F0           MOVX    @DPTR,A
   \   000061   05..         INC     ?V0 + 4
   2454                  pBuf += 2;
   \   000063   12....       LCALL   ?Subroutine95 & 0xFFFF
   2455                }
   \                     ??CrossCallReturnLabel_126:
   \   000066   85..82       MOV     DPL,?V0 + 0
   \   000069   85..83       MOV     DPH,?V0 + 1
   \   00006C   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   2456              }
   \                     ??CrossCallReturnLabel_205:
   \   00006F   40C4         JC      ??zclParseInWriteRspCmd_4
   2457              
   2458              writeRspCmd->numAttr = i; 
   \                     ??zclParseInWriteRspCmd_3:
   \   000071   8A82         MOV     DPL,R2
   \   000073   8B83         MOV     DPH,R3
   \   000075   E5..         MOV     A,?V0 + 4
   \   000077   F0           MOVX    @DPTR,A
   2459            }
   2460          
   2461            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_1:
   \   000078   02....       LJMP    ?Subroutine116 & 0xFFFF
   2462          }
   2463          #endif // ZCL_WRITE
   2464          
   2465          #ifdef ZCL_REPORT
   2466          /*********************************************************************
   2467           * @fn      zclParseInConfigReportCmd
   2468           *
   2469           * @brief   Parse the "Profile" Configure Reporting Command
   2470           *
   2471           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2472           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2473           *
   2474           * @param   pCmd - pointer to incoming data to parse
   2475           *
   2476           * @return  pointer to the parsed command structure
   2477           */
   2478          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   2479          {
   2480            zclCfgReportCmd_t *cfgReportCmd;
   2481            zclCfgReportRec_t *reportRec;
   2482            uint8 *pBuf = pCmd->pData;
   2483            uint8 *dataPtr;
   2484            uint8 numAttr = 0;
   2485            uint8 direction;
   2486            uint8 dataType;
   2487            uint8 hdrLen;
   2488            uint8 dataLen = 0;
   2489            uint8 reportChangeLen; // length of Reportable Change field
   2490            uint8 i;
   2491            
   2492            // Calculate the length of the Request command
   2493            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2494            {
   2495              numAttr++;
   2496              
   2497              direction = *pBuf++;
   2498              pBuf += 2; // move pass the attribute ID
   2499              
   2500              // Is there a Reportable Change field?
   2501              if ( direction == ZCL_SEND_ATTR_REPORTS )
   2502              {
   2503                dataType = *pBuf++;
   2504                pBuf += 4; // move pass the Min and Max Reporting Intervals
   2505          
   2506                // For attributes of 'discrete' data types this field is omitted
   2507                if ( zclAnalogDataType( dataType ) )
   2508                {
   2509                  reportChangeLen = zclGetDataTypeLength( dataType );
   2510                  pBuf += reportChangeLen;
   2511                  
   2512                  // add padding if needed
   2513                  if ( PADDING_NEEDED( reportChangeLen ) )
   2514                    reportChangeLen++;
   2515                  dataLen += reportChangeLen;
   2516                }
   2517              }
   2518              else
   2519              {
   2520                pBuf += 2; // move pass the Timeout Period
   2521              }
   2522            } // while loop
   2523          
   2524            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   2525            
   2526            cfgReportCmd = (zclCfgReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2527            if ( cfgReportCmd != NULL )
   2528            { 
   2529              pBuf = pCmd->pData;
   2530              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   2531              
   2532              cfgReportCmd->numAttr = numAttr;
   2533              for ( i = 0; i < numAttr; i++ )
   2534              {
   2535                reportRec = &(cfgReportCmd->attrList[i]);
   2536                
   2537                osal_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   2538                  
   2539                reportRec->direction = *pBuf++;
   2540                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2541                pBuf += 2;
   2542                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   2543                {
   2544                  // Attribute to be reported
   2545                  reportRec->dataType = *pBuf++;
   2546                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2547                  pBuf += 2;
   2548                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2549                  pBuf += 2;
   2550          
   2551                  // For attributes of 'discrete' data types this field is omitted
   2552                  if ( zclAnalogDataType( reportRec->dataType ) )
   2553                  {
   2554                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   2555                    reportRec->reportableChange = dataPtr;
   2556                    
   2557                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   2558                    pBuf += reportChangeLen;
   2559                    
   2560                    // advance attribute data pointer
   2561                    if ( PADDING_NEEDED( reportChangeLen ) )
   2562                      reportChangeLen++;
   2563                    dataPtr += reportChangeLen;
   2564                  }
   2565                }
   2566                else
   2567                {
   2568                  // Attribute reports to be received
   2569                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   2570                  pBuf += 2;
   2571                }
   2572              } // while loop
   2573            }
   2574            
   2575            return ( (void *)cfgReportCmd );
   2576          }
   2577          
   2578          /*********************************************************************
   2579           * @fn      zclParseInConfigReportRspCmd
   2580           *
   2581           * @brief   Parse the "Profile" Configure Reporting Response Command
   2582           *
   2583           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2584           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2585           *
   2586           * @param   pCmd - pointer to incoming data to parse
   2587           *
   2588           * @return  pointer to the parsed command structure
   2589           */
   2590          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   2591          {
   2592            zclCfgReportRspCmd_t *cfgReportRspCmd;
   2593            uint8 *pBuf = pCmd->pData;
   2594            uint8 numAttr;
   2595            uint8 i; 
   2596            
   2597            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   2598            
   2599            cfgReportRspCmd = (zclCfgReportRspCmd_t *)osal_mem_alloc( sizeof( zclCfgReportRspCmd_t ) 
   2600                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   2601            if ( cfgReportRspCmd != NULL )
   2602            {
   2603              cfgReportRspCmd->numAttr = numAttr;
   2604              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   2605              {
   2606                cfgReportRspCmd->attrList[i].status = *pBuf++;
   2607                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   2608                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2609                pBuf += 2;
   2610              }
   2611            }
   2612          
   2613            return ( (void *)cfgReportRspCmd );  
   2614          }
   2615          
   2616          /*********************************************************************
   2617           * @fn      zclParseInReadReportCfgCmd
   2618           *
   2619           * @brief   Parse the "Profile" Read Reporting Configuration Command
   2620           *
   2621           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2622           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2623           *
   2624           * @param   pCmd - pointer to incoming data to parse
   2625           *
   2626           * @return  pointer to the parsed command structure
   2627           */
   2628          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   2629          {
   2630            zclReadReportCfgCmd_t *readReportCfgCmd;
   2631            uint8 *pBuf = pCmd->pData;
   2632            uint8 numAttr;
   2633            uint8 i;
   2634            
   2635            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   2636            
   2637            readReportCfgCmd = (zclReadReportCfgCmd_t *)osal_mem_alloc( sizeof( zclReadReportCfgCmd_t ) 
   2638                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   2639            if ( readReportCfgCmd != NULL )
   2640            {
   2641              readReportCfgCmd->numAttr = numAttr;
   2642              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   2643              {
   2644                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   2645                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2646                pBuf += 2;
   2647              }
   2648            }
   2649            
   2650            return ( (void *)readReportCfgCmd );
   2651          }
   2652          
   2653          /*********************************************************************
   2654           * @fn      zclParseInReadReportCfgRspCmd
   2655           *
   2656           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   2657           *
   2658           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2659           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2660           *
   2661           * @param   pCmd - pointer to incoming data to parse
   2662           *
   2663           * @return  pointer to the parsed command structure
   2664           */
   2665          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   2666          {
   2667            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   2668            zclReportCfgRspRec_t *reportRspRec;
   2669            uint8 reportChangeLen;
   2670            uint8 *pBuf = pCmd->pData;
   2671            uint8 *dataPtr;
   2672            uint8 numAttr = 0;
   2673            uint8 hdrLen;
   2674            uint8 dataLen = 0;
   2675            uint8 status;
   2676            uint8 direction;
   2677            uint8 dataType;
   2678            uint8 i;
   2679            
   2680            // Calculate the length of the response command
   2681            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2682            { 
   2683              numAttr++;
   2684              
   2685              status = *pBuf++;
   2686              direction = *pBuf++; 
   2687              pBuf += 2; // move pass the attribute ID
   2688              
   2689              if ( status == ZCL_STATUS_SUCCESS )
   2690              {
   2691                if ( direction == ZCL_SEND_ATTR_REPORTS )
   2692                {
   2693                  dataType = *pBuf++;
   2694                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   2695           
   2696                  // For attributes of 'discrete' data types this field is omitted
   2697                  if ( zclAnalogDataType( dataType ) )
   2698                  {
   2699                    reportChangeLen = zclGetDataTypeLength( dataType );
   2700                    pBuf += reportChangeLen;
   2701                    
   2702                    // add padding if needed
   2703                    if ( PADDING_NEEDED( reportChangeLen ) )
   2704                      reportChangeLen++;
   2705                    dataLen += reportChangeLen;
   2706                  }
   2707                }
   2708                else
   2709                {
   2710                  pBuf += 2; // move pass the Timeout field
   2711                }
   2712              }
   2713            } // while loop
   2714            
   2715            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   2716            
   2717            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2718            if ( readReportCfgRspCmd != NULL )
   2719            {
   2720              pBuf = pCmd->pData;
   2721              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   2722              
   2723              readReportCfgRspCmd->numAttr = numAttr;
   2724              for ( i = 0; i < numAttr; i++ )
   2725              {
   2726                reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   2727                
   2728                reportRspRec->status = *pBuf++;
   2729                reportRspRec->direction = *pBuf++;
   2730                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2731                pBuf += 2;
   2732           
   2733                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   2734                {
   2735                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   2736                  {
   2737                    reportRspRec->dataType = *pBuf++;
   2738                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2739                    pBuf += 2;
   2740                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2741                    pBuf += 2;
   2742          
   2743                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   2744                    {
   2745                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   2746                      reportRspRec->reportableChange = dataPtr;
   2747                      
   2748                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType ); 
   2749                      pBuf += reportChangeLen;
   2750                      
   2751                      // advance attribute data pointer
   2752                      if ( PADDING_NEEDED( reportChangeLen ) )
   2753                        reportChangeLen++;
   2754                      dataPtr += reportChangeLen;
   2755                    }
   2756                  }
   2757                  else
   2758                  {
   2759                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   2760                    pBuf += 2;
   2761                  }
   2762                }
   2763              } 
   2764            }
   2765            
   2766            return ( (void *)readReportCfgRspCmd );
   2767          }
   2768          
   2769          /*********************************************************************
   2770           * @fn      zclParseInReportCmd
   2771           *
   2772           * @brief   Parse the "Profile" Report Command
   2773           *
   2774           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2775           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2776           *
   2777           * @param   pCmd - pointer to incoming data to parse
   2778           *
   2779           * @return  pointer to the parsed command structure
   2780           */
   2781          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   2782          {
   2783            zclReportCmd_t *reportCmd;
   2784            zclReport_t *reportRec;
   2785            uint8 *pBuf = pCmd->pData;
   2786            uint8 attrDataLen;
   2787            uint8 *dataPtr;
   2788            uint8 numAttr = 0;
   2789            uint8 hdrLen;
   2790            uint8 dataLen = 0;
   2791            uint8 dataType;
   2792            uint8 i;
   2793          
   2794            // find out the number of attributes and the length of attribute data
   2795            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2796            {
   2797              numAttr++;
   2798          
   2799              pBuf += 2; // move pass attribute id
   2800          
   2801              dataType = *pBuf++;
   2802          
   2803              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2804              pBuf += attrDataLen; // move pass attribute data
   2805                
   2806              // add padding if needed
   2807              if ( PADDING_NEEDED( attrDataLen ) )
   2808                attrDataLen++;
   2809              dataLen += attrDataLen;
   2810            }
   2811            
   2812            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   2813            
   2814            reportCmd = (zclReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2815            if (reportCmd != NULL )
   2816            {
   2817              pBuf = pCmd->pData;
   2818              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   2819              
   2820              reportCmd->numAttr = numAttr;
   2821              for ( i = 0; i < numAttr; i++ )
   2822              {
   2823                reportRec = &(reportCmd->attrList[i]);
   2824                
   2825                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2826                pBuf += 2;
   2827                reportRec->dataType = *pBuf++;
   2828          
   2829                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );  
   2830                osal_memcpy( dataPtr, pBuf, attrDataLen );
   2831                reportRec->attrData = dataPtr;
   2832                
   2833                pBuf += attrDataLen; // move pass attribute data
   2834                
   2835                // advance attribute data pointer
   2836                if ( PADDING_NEEDED( attrDataLen ) )
   2837                  attrDataLen++;
   2838                dataPtr += attrDataLen;
   2839              }
   2840            }
   2841            
   2842            return ( (void *)reportCmd );
   2843          }
   2844          #endif // ZCL_REPORT
   2845          
   2846          /*********************************************************************
   2847           * @fn      zclParseInDefaultRspCmd
   2848           *
   2849           * @brief   Parse the "Profile" Default Response Command
   2850           *
   2851           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2852           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2853           *
   2854           * @param   pCmd - pointer to incoming data to parse
   2855           *
   2856           * @return  pointer to the parsed command structure
   2857           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2858          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   2859          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2860            zclDefaultRspCmd_t *defaultRspCmd;
   2861            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ?Subroutine39 & 0xFFFF
   2862          
   2863            defaultRspCmd = (zclDefaultRspCmd_t *)osal_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_48:
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   7A02         MOV     R2,#0x2
   \   000011   7B00         MOV     R3,#0x0
   \   000013   12....       LCALL   ??osal_mem_alloc?relay
   2864            if ( defaultRspCmd != NULL )
   \   000016   EA           MOV     A,R2
   \   000017   7001         JNZ     ??zclParseInDefaultRspCmd_0
   \   000019   EB           MOV     A,R3
   \                     ??zclParseInDefaultRspCmd_0:
   \   00001A   600D         JZ      ??zclParseInDefaultRspCmd_1
   2865            {
   2866              defaultRspCmd->commandID = *pBuf++;
   \   00001C   8E82         MOV     DPL,R6
   \   00001E   8F83         MOV     DPH,R7
   \   000020   E0           MOVX    A,@DPTR
   \   000021   12....       LCALL   ?Subroutine7 & 0xFFFF
   2867              defaultRspCmd->statusCode = *pBuf;
   \                     ??CrossCallReturnLabel_220:
   \   000024   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   2868            }
   \                     ??CrossCallReturnLabel_233:
   \   000027   A3           INC     DPTR
   \   000028   F0           MOVX    @DPTR,A
   2869          
   2870            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_1:
   \   000029   02....       LJMP    ?Subroutine113 & 0xFFFF
   2871          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004                REQUIRE ??Subroutine136_0
   \   000004                ; // Fall through to label ??Subroutine136_0
   2872          
   2873          #ifdef ZCL_DISCOVER
   2874          /*********************************************************************
   2875           * @fn      zclParseInDiscCmd
   2876           *
   2877           * @brief   Parse the "Profile" Discovery Commands
   2878           *
   2879           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2880           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2881           *
   2882           * @param   pCmd - pointer to incoming data to parse
   2883           *
   2884           * @return  pointer to the parsed command structure
   2885           */
   2886          void *zclParseInDiscCmd( zclParseCmd_t *pCmd )
   2887          {
   2888            zclDiscoverCmd_t *discoverCmd;
   2889            uint8 *pBuf = pCmd->pData;
   2890          
   2891            discoverCmd = (zclDiscoverCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverCmd_t ) );
   2892            if ( discoverCmd != NULL )
   2893            {
   2894              discoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   2895              pBuf += 2;
   2896              discoverCmd->maxAttrIDs = *pBuf;
   2897            }
   2898          
   2899            return ( (void *)discoverCmd );
   2900          }
   2901          
   2902          /*********************************************************************
   2903           * @fn      zclParseInDiscRspCmd
   2904           *
   2905           * @brief   Parse the "Profile" Discovery Response Commands
   2906           *
   2907           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2908           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2909           *
   2910           * @param   pCmd - pointer to incoming data to parse
   2911           *
   2912           * @return  pointer to the parsed command structure
   2913           */
   2914          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   2915          static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd )
   2916          {
   2917            zclDiscoverRspCmd_t *discoverRspCmd;
   2918            uint8 *pBuf = pCmd->pData;
   2919            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   2920            uint8 i;
   2921          
   2922            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverRspCmd_t ) 
   2923                                                           + ( numAttr * sizeof(zclDiscoverInfo_t) ) );
   2924            if ( discoverRspCmd != NULL )
   2925            {
   2926              discoverRspCmd->discComplete = *pBuf++;
   2927              discoverRspCmd->numAttr = numAttr;
   2928              
   2929              for ( i = 0; i < numAttr; i++ )
   2930              {
   2931                discoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2932                pBuf += 2;
   2933                discoverRspCmd->attrList[i].dataType = *pBuf++;;
   2934              }
   2935            }
   2936          
   2937            return ( (void *)discoverRspCmd );
   2938          }
   2939          #endif // ZCL_DISCOVER
   2940          
   2941          #ifdef ZCL_READ
   2942          /*********************************************************************
   2943           * @fn      zclProcessInReadCmd
   2944           *
   2945           * @brief   Process the "Profile" Read Command
   2946           *
   2947           * @param   pInMsg - incoming message to process
   2948           *
   2949           * @return  TRUE if command processed. FALSE, otherwise.
   2950           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2951          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   2952          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   2953            zclReadCmd_t *readCmd;
   2954            zclReadRspCmd_t *readRspCmd;
   2955            zclReadRspStatus_t *statusRec;
   2956            zclAttrRec_t attrRec;
   2957            uint8 len;
   2958            uint8 i;
   2959            
   2960            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   000011   F5..         MOV     ?V0 + 2,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 3,A
   2961            
   2962            // calculate the length of the response status record
   2963            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   2964            
   2965            readRspCmd = osal_mem_alloc( len );
   \   000017                ; Setup parameters for call to function osal_mem_alloc
   \   000017   75F006       MOV     B,#0x6
   \   00001A   85..82       MOV     DPL,?V0 + 2
   \   00001D   F583         MOV     DPH,A
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   A4           MUL     AB
   \   000021   04           INC     A
   \   000022   FA           MOV     R2,A
   \   000023   7B00         MOV     R3,#0x0
   \   000025   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   2966            if ( readRspCmd == NULL )
   \                     ??CrossCallReturnLabel_202:
   \   000028   7001         JNZ     ??zclProcessInReadCmd_0
   \   00002A   EB           MOV     A,R3
   \                     ??zclProcessInReadCmd_0:
   \   00002B   7005         JNZ     ??zclProcessInReadCmd_1
   2967              return FALSE; // EMBEDDED RETURN
   \   00002D   7900         MOV     R1,#0x0
   \   00002F   02....       LJMP    ??zclProcessInReadCmd_2 & 0xFFFF
   2968          
   2969            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_1:
   \   000032   85..82       MOV     DPL,?V0 + 2
   \   000035   85..83       MOV     DPH,?V0 + 3
   \   000038   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   00003B   F0           MOVX    @DPTR,A
   2970            for (i = 0; i < readCmd->numAttr; i++)
   \   00003C   75..00       MOV     ?V0 + 6,#0x0
   \   00003F   800B         SJMP    ??zclProcessInReadCmd_3
   2971            {
   2972              statusRec = &(readRspCmd->attrList[i]);
   2973              
   2974              statusRec->attrID = readCmd->attrID[i];
   2975              
   2976              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, readCmd->attrID[i], &attrRec ) )
   2977              {
   2978                statusRec->data = attrRec.attr.dataPtr;
   2979                statusRec->status = ZCL_STATUS_SUCCESS;
   2980                statusRec->dataType = attrRec.attr.dataType;
   2981              }
   2982              else
   2983              {
   2984                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_4:
   \   000041   7486         MOV     A,#-0x7a
   \   000043   85..82       MOV     DPL,?V0 + 10
   \   000046   85..83       MOV     DPH,?V0 + 11
   \                     ??zclProcessInReadCmd_5:
   \   000049   F0           MOVX    @DPTR,A
   2985              }
   \   00004A   05..         INC     ?V0 + 6
   \                     ??zclProcessInReadCmd_3:
   \   00004C   85..82       MOV     DPL,?V0 + 2
   \   00004F   85..83       MOV     DPH,?V0 + 3
   \   000052   E0           MOVX    A,@DPTR
   \   000053   FA           MOV     R2,A
   \   000054   E5..         MOV     A,?V0 + 6
   \   000056   C3           CLR     C
   \   000057   9A           SUBB    A,R2
   \   000058   4003         JC      $+5
   \   00005A   02....       LJMP    ??zclProcessInReadCmd_6 & 0xFFFF
   \   00005D   85..82       MOV     DPL,?V0 + 6
   \   000060   A882         MOV     R0,DPL
   \   000062   E8           MOV     A,R0
   \   000063   75F006       MOV     B,#0x6
   \   000066   A4           MUL     AB
   \   000067   FA           MOV     R2,A
   \   000068   ABF0         MOV     R3,B
   \   00006A   E5..         MOV     A,?V0 + 0
   \   00006C   2A           ADD     A,R2
   \   00006D   F582         MOV     DPL,A
   \   00006F   E5..         MOV     A,?V0 + 1
   \   000071   3B           ADDC    A,R3
   \   000072   F583         MOV     DPH,A
   \   000074   A3           INC     DPTR
   \   000075   AE82         MOV     R6,DPL
   \   000077   AF83         MOV     R7,DPH
   \   000079   E8           MOV     A,R0
   \   00007A   C3           CLR     C
   \   00007B   33           RLC     A
   \   00007C   F8           MOV     R0,A
   \   00007D   E4           CLR     A
   \   00007E   33           RLC     A
   \   00007F   F9           MOV     R1,A
   \   000080   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000083   AA82         MOV     R2,DPL
   \   000085   AB83         MOV     R3,DPH
   \   000087   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   00008A   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   00008D   EE           MOV     A,R6
   \   00008E   2402         ADD     A,#0x2
   \   000090   F5..         MOV     ?V0 + 10,A
   \   000092   EF           MOV     A,R7
   \   000093   3400         ADDC    A,#0x0
   \   000095   F5..         MOV     ?V0 + 11,A
   \   000097   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_288:
   \   00009A                ; Setup parameters for call to function zclFindAttrRec
   \   00009A   85..82       MOV     DPL,?XSP + 0
   \   00009D   85..83       MOV     DPH,?XSP + 1
   \   0000A0   8582..       MOV     ?V0 + 12,DPL
   \   0000A3   8583..       MOV     ?V0 + 13,DPH
   \   0000A6   78..         MOV     R0,#?V0 + 12
   \   0000A8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AB   8A82         MOV     DPL,R2
   \   0000AD   8B83         MOV     DPH,R3
   \   0000AF   12....       LCALL   ??Subroutine143_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_257:
   \   0000B2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B5   E9           MOV     A,R1
   \   0000B6   6089         JZ      ??zclProcessInReadCmd_4
   \   0000B8   7406         MOV     A,#0x6
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   0000C7   E4           CLR     A
   \   0000C8   85..82       MOV     DPL,?V0 + 10
   \   0000CB   85..83       MOV     DPH,?V0 + 11
   \   0000CE   F0           MOVX    @DPTR,A
   \   0000CF   7404         MOV     A,#0x4
   \   0000D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   8E82         MOV     DPL,R6
   \   0000D7   8F83         MOV     DPH,R7
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   02....       LJMP    ??zclProcessInReadCmd_5 & 0xFFFF
   2986            }
   2987            
   2988            // Build and send Read Response command
   2989            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   2990                             readRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   2991                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_6:
   \   0000DF   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_289:
   \   0000E2                ; Setup parameters for call to function zcl_SendReadRsp
   \   0000E2   85..82       MOV     DPL,?V0 + 4
   \   0000E5   85..83       MOV     DPH,?V0 + 5
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   A3           INC     DPTR
   \   0000EB   A3           INC     DPTR
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   E0           MOVX    A,@DPTR
   \   0000EF   F5..         MOV     ?V0 + 2,A
   \   0000F1   78..         MOV     R0,#?V0 + 2
   \   0000F3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000F6   75..01       MOV     ?V0 + 2,#0x1
   \   0000F9   78..         MOV     R0,#?V0 + 2
   \   0000FB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000FE   78..         MOV     R0,#?V0 + 2
   \   000100   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000103   78..         MOV     R0,#?V0 + 0
   \   000105   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000108   85..82       MOV     DPL,?V0 + 8
   \   00010B   85..83       MOV     DPH,?V0 + 9
   \   00010E   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   000111   E5..         MOV     A,?V0 + 8
   \   000113   2406         ADD     A,#0x6
   \   000115   FA           MOV     R2,A
   \   000116   E5..         MOV     A,?V0 + 9
   \   000118   3400         ADDC    A,#0x0
   \   00011A   FB           MOV     R3,A
   \   00011B   E5..         MOV     A,?V0 + 8
   \   00011D   2414         ADD     A,#0x14
   \   00011F   F582         MOV     DPL,A
   \   000121   E5..         MOV     A,?V0 + 9
   \   000123   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   000126   F9           MOV     R1,A
   \   000127   12....       LCALL   ??zcl_SendReadRsp?relay
   \   00012A   7405         MOV     A,#0x5
   \   00012C   12....       LCALL   ?DEALLOC_XSTACK8
   2992            osal_mem_free( readRspCmd );
   \   00012F                ; Setup parameters for call to function osal_mem_free
   \   00012F   AA..         MOV     R2,?V0 + 0
   \   000131   AB..         MOV     R3,?V0 + 1
   \   000133   12....       LCALL   ??osal_mem_free?relay
   2993              
   2994            return TRUE;
   \   000136   7901         MOV     R1,#0x1
   \                     ??zclProcessInReadCmd_2:
   \   000138   7408         MOV     A,#0x8
   \   00013A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00013D   02....       LJMP    ??Subroutine122_0 & 0xFFFF
   2995          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   85..82       MOV     DPL,?V0 + 4
   \   000003   85..83       MOV     DPH,?V0 + 5
   \   000006                REQUIRE ??Subroutine137_0
   \   000006                ; // Fall through to label ??Subroutine137_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine137_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 8,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 9,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   E0           MOVX    A,@DPTR
   \   000001                REQUIRE ??Subroutine138_0
   \   000001                ; // Fall through to label ??Subroutine138_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine143_0:
   \   000000   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   000003   FD           MOV     R5,A
   \   000004   85..82       MOV     DPL,?V0 + 8
   \   000007   85..83       MOV     DPH,?V0 + 9
   \   00000A   A3           INC     DPTR
   \   00000B   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   00000E   E5..         MOV     A,?V0 + 8
   \   000010   2414         ADD     A,#0x14
   \   000012   F582         MOV     DPL,A
   \   000014   E5..         MOV     A,?V0 + 9
   \   000016   3400         ADDC    A,#0x0
   \   000018   F583         MOV     DPH,A
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   12....       LCALL   ??zclFindAttrRec?relay
   \   00001F   7402         MOV     A,#0x2
   \   000021   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   EA           MOV     A,R2
   \   000001   240C         ADD     A,#0xc
   \   000003   F582         MOV     DPL,A
   \   000005   EB           MOV     A,R3
   \   000006                REQUIRE ??Subroutine144_0
   \   000006                ; // Fall through to label ??Subroutine144_0
   2996          #endif // ZCL_READ
   2997          
   2998          #ifdef ZCL_WRITE
   2999          /*********************************************************************
   3000           * @fn      processInWriteCmd
   3001           *
   3002           * @brief   Process the "Profile" Write and Write No Response Commands
   3003           *
   3004           * @param   pInMsg - incoming message to process
   3005           *
   3006           * @return  TRUE if command processed. FALSE, otherwise.
   3007           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   F9           MOV     R1,A
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007                REQUIRE ??Subroutine140_0
   \   000007                ; // Fall through to label ??Subroutine140_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3008          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   3009          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 6,R2
   \   00000C   8B..         MOV     ?V0 + 7,R3
   3010            zclWriteCmd_t *writeCmd;
   3011            zclWriteRec_t *statusRec;
   3012            zclWriteRspCmd_t *writeRspCmd;
   3013            zclAttrRec_t attrRec;
   3014            uint8 sendRsp = FALSE;
   \   00000E   75..00       MOV     ?V0 + 4,#0x0
   3015            uint8 status;
   3016            uint8 i, j = 0;
   \   000011   75..00       MOV     ?V0 + 2,#0x0
   3017          
   3018            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000014   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   000017   F8           MOV     R0,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   12....       LCALL   ?Subroutine13 & 0xFFFF
   3019            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \                     ??CrossCallReturnLabel_245:
   \   00001D   8A82         MOV     DPL,R2
   \   00001F   8B83         MOV     DPH,R3
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   6402         XRL     A,#0x2
   \   00002B   7013         JNZ     ??zclProcessInWriteCmd_0
   3020            {
   3021              // We need to send a response back - allocate space for it
   3022              writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t ) 
   3023                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   00002D                ; Setup parameters for call to function osal_mem_alloc
   \   00002D   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_248:
   \   000030   12....       LCALL   ?Subroutine24 & 0xFFFF
   3024              if ( writeRspCmd == NULL )
   \                     ??CrossCallReturnLabel_28:
   \   000033   7001         JNZ     ??zclProcessInWriteCmd_1
   \   000035   EB           MOV     A,R3
   \                     ??zclProcessInWriteCmd_1:
   \   000036   7005         JNZ     ??zclProcessInWriteCmd_2
   3025                return FALSE; // EMBEDDED RETURN
   \   000038   7900         MOV     R1,#0x0
   \   00003A   02....       LJMP    ??zclProcessInWriteCmd_3 & 0xFFFF
   3026              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_2:
   \   00003D   75..01       MOV     ?V0 + 4,#0x1
   3027            }
   3028            
   3029            for (i = 0; i < writeCmd->numAttr; i++)
   \                     ??zclProcessInWriteCmd_0:
   \   000040   75..00       MOV     ?V0 + 3,#0x0
   \   000043   801F         SJMP    ??zclProcessInWriteCmd_4
   3030            {
   3031              statusRec = &(writeCmd->attrList[i]);
   3032              
   3033              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   3034              {
   3035                if ( statusRec->dataType == attrRec.attr.dataType )
   3036                {
   3037                  status = zclWriteAttrData( &attrRec, statusRec );
   3038          
   3039                  // If successful, a write attribute status record shall NOT be generated
   3040                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   3041                  {
   3042                    // Attribute is read only - move on to the next write attribute record
   3043                    writeRspCmd->attrList[j].status = status;
   3044                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3045                  }
   3046                }
   3047                else
   3048                {
   3049                  // Attribute data type is incorrect - move on to the next write attribute record
   3050                  if ( sendRsp )
   3051                  {
   3052                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   3053                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3054                  }
   3055                }
   3056              }
   3057              else
   3058              {
   3059                // Attribute is not supported - move on to the next write attribute record
   3060                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_5:
   \   000045   E5..         MOV     A,?V0 + 4
   \   000047   6019         JZ      ??zclProcessInWriteCmd_6
   3061                {
   3062                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   000049   7486         MOV     A,#-0x7a
   \                     ??zclProcessInWriteCmd_7:
   \   00004B   85..82       MOV     DPL,?V0 + 14
   \   00004E   85..83       MOV     DPH,?V0 + 15
   3063                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3064                }
   3065              }
   \   000051   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   000054   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000057   85..82       MOV     DPL,?V0 + 12
   \   00005A   85..83       MOV     DPH,?V0 + 13
   \   00005D   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000060   05..         INC     ?V0 + 2
   \                     ??zclProcessInWriteCmd_6:
   \   000062   05..         INC     ?V0 + 3
   \                     ??zclProcessInWriteCmd_4:
   \   000064   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   000067   E0           MOVX    A,@DPTR
   \   000068   FA           MOV     R2,A
   \   000069   E5..         MOV     A,?V0 + 3
   \   00006B   C3           CLR     C
   \   00006C   9A           SUBB    A,R2
   \   00006D   4003         JC      $+5
   \   00006F   02....       LJMP    ??zclProcessInWriteCmd_8 & 0xFFFF
   \   000072   E5..         MOV     A,?V0 + 3
   \   000074   75F005       MOV     B,#0x5
   \   000077   A4           MUL     AB
   \   000078   F8           MOV     R0,A
   \   000079   A9F0         MOV     R1,B
   \   00007B   85..82       MOV     DPL,?XSP + 0
   \   00007E   85..83       MOV     DPH,?XSP + 1
   \   000081   E0           MOVX    A,@DPTR
   \   000082   28           ADD     A,R0
   \   000083   FA           MOV     R2,A
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   39           ADDC    A,R1
   \   000087   8A82         MOV     DPL,R2
   \   000089   F583         MOV     DPH,A
   \   00008B   A3           INC     DPTR
   \   00008C   AE82         MOV     R6,DPL
   \   00008E   AF83         MOV     R7,DPH
   \   000090   E5..         MOV     A,?V0 + 2
   \   000092   75F003       MOV     B,#0x3
   \   000095   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000098   E582         MOV     A,DPL
   \   00009A   2402         ADD     A,#0x2
   \   00009C   F5..         MOV     ?V0 + 12,A
   \   00009E   E583         MOV     A,DPH
   \   0000A0   3400         ADDC    A,#0x0
   \   0000A2   F5..         MOV     ?V0 + 13,A
   \   0000A4   A3           INC     DPTR
   \   0000A5   8582..       MOV     ?V0 + 14,DPL
   \   0000A8   8583..       MOV     ?V0 + 15,DPH
   \   0000AB   85..82       MOV     DPL,?V0 + 6
   \   0000AE   85..83       MOV     DPH,?V0 + 7
   \   0000B1   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   8582..       MOV     ?V0 + 10,DPL
   \   0000BA   8583..       MOV     ?V0 + 11,DPH
   \   0000BD   78..         MOV     R0,#?V0 + 10
   \   0000BF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C2   8E82         MOV     DPL,R6
   \   0000C4   8F83         MOV     DPH,R7
   \   0000C6   12....       LCALL   ??Subroutine143_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   0000C9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000CC   E9           MOV     A,R1
   \   0000CD   7003         JNZ     $+5
   \   0000CF   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   0000D2   8E82         MOV     DPL,R6
   \   0000D4   8F83         MOV     DPH,R7
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   FA           MOV     R2,A
   \   0000DA   7406         MOV     A,#0x6
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   6A           XRL     A,R2
   \   0000E1   7022         JNZ     ??zclProcessInWriteCmd_9
   \   0000E3                ; Setup parameters for call to function zclWriteAttrData
   \   0000E3   EE           MOV     A,R6
   \   0000E4   FC           MOV     R4,A
   \   0000E5   EF           MOV     A,R7
   \   0000E6   FD           MOV     R5,A
   \   0000E7   7402         MOV     A,#0x2
   \   0000E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EC   AA82         MOV     R2,DPL
   \   0000EE   AB83         MOV     R3,DPH
   \   0000F0   12....       LCALL   ??zclWriteAttrData?relay
   \   0000F3   E9           MOV     A,R1
   \   0000F4   FA           MOV     R2,A
   \   0000F5   E5..         MOV     A,?V0 + 4
   \   0000F7   7003         JNZ     $+5
   \   0000F9   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   0000FC   EA           MOV     A,R2
   \   0000FD   7003         JNZ     $+5
   \   0000FF   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   000102   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   \                     ??zclProcessInWriteCmd_9:
   \   000105   E5..         MOV     A,?V0 + 4
   \   000107   7003         JNZ     $+5
   \   000109   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   00010C   748D         MOV     A,#-0x73
   \   00010E   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   3066            } // for loop
   3067          
   3068            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_8:
   \   000111   E5..         MOV     A,?V0 + 4
   \   000113   604A         JZ      ??zclProcessInWriteCmd_10
   3069            {
   3070              writeRspCmd->numAttr = j;
   \   000115   85..82       MOV     DPL,?V0 + 0
   \   000118   85..83       MOV     DPH,?V0 + 1
   \   00011B   E5..         MOV     A,?V0 + 2
   \   00011D   F0           MOVX    @DPTR,A
   3071              if ( writeRspCmd->numAttr == 0 )
   \   00011E   7003         JNZ     ??CrossCallReturnLabel_12
   3072              {
   3073                // Since all records were written successful, include a single status record
   3074                // in the resonse command with the status field set to SUCCESS and the 
   3075                // attribute ID field omitted.
   3076                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000120   12....       LCALL   ?Subroutine10 & 0xFFFF
   3077                writeRspCmd->numAttr = 1;
   3078              }
   3079              
   3080              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3081                                pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   3082                                true, pInMsg->hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_12:
   \   000123   85..82       MOV     DPL,?V0 + 6
   \   000126   85..83       MOV     DPH,?V0 + 7
   \   000129   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   00012C                ; Setup parameters for call to function zcl_SendWriteRsp
   \   00012C   85..82       MOV     DPL,?V0 + 6
   \   00012F   85..83       MOV     DPH,?V0 + 7
   \   000132   A3           INC     DPTR
   \   000133   A3           INC     DPTR
   \   000134   A3           INC     DPTR
   \   000135   A3           INC     DPTR
   \   000136   A3           INC     DPTR
   \   000137   A3           INC     DPTR
   \   000138   E0           MOVX    A,@DPTR
   \   000139   F5..         MOV     ?V0 + 2,A
   \   00013B   78..         MOV     R0,#?V0 + 2
   \   00013D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000140   75..01       MOV     ?V0 + 2,#0x1
   \   000143   78..         MOV     R0,#?V0 + 2
   \   000145   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000148   78..         MOV     R0,#?V0 + 2
   \   00014A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00014D   78..         MOV     R0,#?V0 + 0
   \   00014F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000152   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000155   12....       LCALL   ?DEALLOC_XSTACK8
   3083              osal_mem_free( writeRspCmd );
   \   000158                ; Setup parameters for call to function osal_mem_free
   \   000158   AA..         MOV     R2,?V0 + 0
   \   00015A   AB..         MOV     R3,?V0 + 1
   \   00015C   12....       LCALL   ??osal_mem_free?relay
   3084            }
   3085            
   3086            return TRUE; 
   \                     ??zclProcessInWriteCmd_10:
   \   00015F   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteCmd_3:
   \   000161   740A         MOV     A,#0xa
   \   000163   02....       LJMP    ??Subroutine121_0 & 0xFFFF
   3087          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine142_0
   \   000006                ; // Fall through to label ??Subroutine142_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine146_0:
   \   000000   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   000003                ; Setup parameters for call to function zclFindAttrRec
   \   000003                ; Setup parameters for call to function zclFindAttrRec
   \   000003                ; Setup parameters for call to function zclFindAttrRec
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   75F003       MOV     B,#0x3
   \   000004   A4           MUL     AB
   \   000005   F8           MOV     R0,A
   \   000006   A9F0         MOV     R1,B
   \   000008   7401         MOV     A,#0x1
   \   00000A   28           ADD     A,R0
   \   00000B   FA           MOV     R2,A
   \   00000C   E4           CLR     A
   \   00000D   39           ADDC    A,R1
   \   00000E   FB           MOV     R3,A
   \   00000F   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   00000B   FD           MOV     R5,A
   \   00000C   EE           MOV     A,R6
   \   00000D   2406         ADD     A,#0x6
   \   00000F   FA           MOV     R2,A
   \   000010   EF           MOV     A,R7
   \   000011   3400         ADDC    A,#0x0
   \   000013   FB           MOV     R3,A
   \   000014   EE           MOV     A,R6
   \   000015   2414         ADD     A,#0x14
   \   000017   F582         MOV     DPL,A
   \   000019   EF           MOV     A,R7
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   F583         MOV     DPH,A
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F9           MOV     R1,A
   \   000020   12....       LCALL   ??zcl_SendWriteRsp?relay
   \   000023   7405         MOV     A,#0x5
   \   000025   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E4           CLR     A
   \   000001   A3           INC     DPTR
   \   000002   F0           MOVX    @DPTR,A
   \   000003   7401         MOV     A,#0x1
   \   000005   85..82       MOV     DPL,?V0 + 0
   \   000008   85..83       MOV     DPH,?V0 + 1
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   22           RET
   3088          
   3089          /*********************************************************************
   3090           * @fn      zclRevertWriteUndividedCmd
   3091           *
   3092           * @brief   Revert the "Profile" Write Undevided Command
   3093           *
   3094           * @param   pInMsg - incoming message to process
   3095           * @param   curWriteRec - old data
   3096           * @param   numAttr - number of attributes to be reverted
   3097           *
   3098           * @return  none
   3099           */
   3100          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg, 
   3101                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   3102          {
   3103            zclWriteRec_t *statusRec;
   3104            zclAttrRec_t attrRec;
   3105            uint8 dataLen;
   3106            uint8 i;
   3107          
   3108            statusRec = curWriteRec;
   3109            for (i = 0; i < numAttr; i++)
   3110            {
   3111              statusRec = &(curWriteRec[i]);
   3112              
   3113              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   3114                break; // should never happen
   3115           
   3116              // Just copy the old data back - no need to validate the data
   3117              dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   3118              osal_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   3119            } // for loop
   3120          }
   3121          
   3122          /*********************************************************************
   3123           * @fn      zclProcessInWriteUndividedCmd
   3124           *
   3125           * @brief   Process the "Profile" Write Undivided Command
   3126           *
   3127           * @param   pInMsg - incoming message to process
   3128           *
   3129           * @return  TRUE if command processed. FALSE, otherwise.
   3130           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine131_0
   \   000003                ; // Fall through to label ??Subroutine131_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006                REQUIRE ??Subroutine143_0
   \   000006                ; // Fall through to label ??Subroutine143_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3131          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   3132          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 14,R2
   \   00000C   8B..         MOV     ?V0 + 15,R3
   3133            zclWriteCmd_t *writeCmd;
   3134            zclWriteRec_t *statusRec;
   3135            zclWriteRec_t *curWriteRec;
   3136            zclWriteRec_t *curStatusRec;
   3137            zclWriteRspCmd_t *writeRspCmd;
   3138            zclAttrRec_t attrRec;
   3139            uint8 *curDataPtr;
   3140            uint8 hdrLen;
   3141            uint8 dataLen;
   3142            uint8 curLen = 0;
   \   00000E   75..00       MOV     ?V0 + 4,#0x0
   3143            uint8 status;
   3144            uint8 i, j = 0;
   \   000011   7F00         MOV     R7,#0x0
   3145          
   3146            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000013   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   000016   F5..         MOV     ?V0 + 6,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F5..         MOV     ?V0 + 7,A
   3147            
   3148            // Allocate space for Write Response Command
   3149            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t ) 
   3150                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \   00001C                ; Setup parameters for call to function osal_mem_alloc
   \   00001C   85..82       MOV     DPL,?V0 + 6
   \   00001F   F583         MOV     DPH,A
   \   000021   12....       LCALL   ?Subroutine24 & 0xFFFF
   3151            if ( writeRspCmd == NULL )
   \                     ??CrossCallReturnLabel_29:
   \   000024   7001         JNZ     ??zclProcessInWriteUndividedCmd_0
   \   000026   EB           MOV     A,R3
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   000027   7005         JNZ     ??zclProcessInWriteUndividedCmd_1
   3152              return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   000029   7900         MOV     R1,#0x0
   \   00002B   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   3153            
   3154            // If any attribute cannot be written, no attribute values are changed. Hence,
   3155            // make sure all the attributes are supported and writable
   3156            for (i = 0; i < writeCmd->numAttr; i++)
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   00002E   7E00         MOV     R6,#0x0
   \   000030   8019         SJMP    ??zclProcessInWriteUndividedCmd_4
   3157            {
   3158              statusRec = &(writeCmd->attrList[i]);
   3159              
   3160              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   3161              {
   3162                // Attribute is not supported - stop here
   3163                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   3164                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3165                break;
   3166              }
   3167              
   3168              if ( statusRec->dataType != attrRec.attr.dataType )
   3169              {
   3170                // Attribute data type is incorrect - stope here
   3171                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   3172                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3173                break;
   3174              }
   3175              
   3176              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   3177              {
   3178                // Attribute is not writable - stop here
   3179                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   3180                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3181                break;
   3182              }
   3183              
   3184              dataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   000032                ; Setup parameters for call to function zclGetAttrDataLength
   \   000032   85..82       MOV     DPL,?V0 + 2
   \   000035   85..83       MOV     DPH,?V0 + 3
   \   000038   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   00003B   12....       LCALL   ??zclGetAttrDataLength?relay
   \   00003E   E9           MOV     A,R1
   \   00003F   FA           MOV     R2,A
   3185              
   3186              // add padding if needed
   3187              if ( PADDING_NEEDED( dataLen ) )
   \   000040   A2E0         MOV     C,0xE0 /* A   */.0
   \   000042   5001         JNC     ??zclProcessInWriteUndividedCmd_6
   3188                dataLen++;
   \   000044   0A           INC     R2
   3189              curLen += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   000045   EA           MOV     A,R2
   \   000046   25..         ADD     A,?V0 + 4
   \   000048   F5..         MOV     ?V0 + 4,A
   \   00004A   0E           INC     R6
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   00004B   85..82       MOV     DPL,?V0 + 6
   \   00004E   85..83       MOV     DPH,?V0 + 7
   \   000051   E0           MOVX    A,@DPTR
   \   000052   FA           MOV     R2,A
   \   000053   EE           MOV     A,R6
   \   000054   C3           CLR     C
   \   000055   9A           SUBB    A,R2
   \   000056   505D         JNC     ??zclProcessInWriteUndividedCmd_7
   \   000058   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   00005B   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   00005E   12....       LCALL   ?XSTACK_DISP0_8
   \   000061   8582..       MOV     ?V0 + 10,DPL
   \   000064   8583..       MOV     ?V0 + 11,DPH
   \   000067   78..         MOV     R0,#?V0 + 10
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_255:
   \   00006F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000072   E9           MOV     A,R1
   \   000073   7004         JNZ     ??zclProcessInWriteUndividedCmd_8
   \   000075   7486         MOV     A,#-0x7a
   \   000077   8023         SJMP    ??zclProcessInWriteUndividedCmd_9
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   000079   85..82       MOV     DPL,?V0 + 2
   \   00007C   85..83       MOV     DPH,?V0 + 3
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   E0           MOVX    A,@DPTR
   \   000082   F9           MOV     R1,A
   \   000083   7406         MOV     A,#0x6
   \   000085   12....       LCALL   ?XSTACK_DISP0_8
   \   000088   E0           MOVX    A,@DPTR
   \   000089   69           XRL     A,R1
   \   00008A   6004         JZ      ??zclProcessInWriteUndividedCmd_10
   \   00008C   748D         MOV     A,#-0x73
   \   00008E   800C         SJMP    ??zclProcessInWriteUndividedCmd_9
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   000090   7407         MOV     A,#0x7
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   E0           MOVX    A,@DPTR
   \   000096   A2E1         MOV     C,0xE0 /* A   */.1
   \   000098   4098         JC      ??zclProcessInWriteUndividedCmd_5
   \   00009A   7488         MOV     A,#-0x78
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   00009C   85..82       MOV     DPL,?V0 + 0
   \   00009F   85..83       MOV     DPH,?V0 + 1
   \   0000A2   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   0000A5   F8           MOV     R0,A
   \   0000A6   A3           INC     DPTR
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   F9           MOV     R1,A
   \   0000A9   85..82       MOV     DPL,?V0 + 0
   \   0000AC   85..83       MOV     DPH,?V0 + 1
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   0000B4   0F           INC     R7
   3190            } // for loop
   3191            
   3192            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0000B5   EF           MOV     A,R7
   \   0000B6   85..82       MOV     DPL,?V0 + 0
   \   0000B9   85..83       MOV     DPH,?V0 + 1
   \   0000BC   F0           MOVX    @DPTR,A
   3193            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   0000BD   6003         JZ      $+5
   \   0000BF   02....       LJMP    ??zclProcessInWriteUndividedCmd_11 & 0xFFFF
   3194            {
   3195              // calculate the length of the current data header
   3196              hdrLen = j * sizeof( zclWriteRec_t );
   \   0000C2   75F005       MOV     B,#0x5
   \   0000C5   A4           MUL     AB
   \   0000C6   FA           MOV     R2,A
   3197            
   3198              // Allocate space to keep a copy of the current data
   3199              curWriteRec = (zclWriteRec_t *) osal_mem_alloc( hdrLen + curLen ); 
   \   0000C7   8A82         MOV     DPL,R2
   \   0000C9   8582..       MOV     ?V0 + 2,DPL
   \   0000CC                ; Setup parameters for call to function osal_mem_alloc
   \   0000CC   E5..         MOV     A,?V0 + 4
   \   0000CE   25..         ADD     A,?V0 + 2
   \   0000D0   FA           MOV     R2,A
   \   0000D1   E4           CLR     A
   \   0000D2   3400         ADDC    A,#0x0
   \   0000D4   FB           MOV     R3,A
   \   0000D5   12....       LCALL   ??osal_mem_alloc?relay
   \   0000D8   8A..         MOV     ?V0 + 12,R2
   \   0000DA   8B..         MOV     ?V0 + 13,R3
   3200              if ( curWriteRec == NULL )
   \   0000DC   EA           MOV     A,R2
   \   0000DD   7001         JNZ     ??zclProcessInWriteUndividedCmd_12
   \   0000DF   EB           MOV     A,R3
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   0000E0   700A         JNZ     ??zclProcessInWriteUndividedCmd_13
   3201              {
   3202                osal_mem_free(writeRspCmd );
   \   0000E2                ; Setup parameters for call to function osal_mem_free
   \   0000E2   AA..         MOV     R2,?V0 + 0
   \   0000E4   AB..         MOV     R3,?V0 + 1
   \   0000E6   12....       LCALL   ??osal_mem_free?relay
   3203                return FALSE; // EMBEDDED RETURN
   \   0000E9   02....       LJMP    ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   3204              }
   3205          
   3206              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   0000EC   EA           MOV     A,R2
   \   0000ED   25..         ADD     A,?V0 + 2
   \   0000EF   F5..         MOV     ?V0 + 4,A
   \   0000F1   EB           MOV     A,R3
   \   0000F2   3400         ADDC    A,#0x0
   \   0000F4   F5..         MOV     ?V0 + 5,A
   3207              
   3208              // Write the new data over
   3209              for (i = 0; i < writeCmd->numAttr; i++)
   \   0000F6   7E00         MOV     R6,#0x0
   \   0000F8   8023         SJMP    ??zclProcessInWriteUndividedCmd_14
   3210              {
   3211                statusRec = &(writeCmd->attrList[i]);
   3212                curStatusRec = &(curWriteRec[i]);
   3213              
   3214                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) )
   3215                  break; // should never happen
   3216          
   3217                // Keep a copy of the current data before before writing the new data over
   3218                curStatusRec->attrID = statusRec->attrID;
   3219                zclReadAttrData( curDataPtr, &attrRec );
   3220                curStatusRec->attrData = curDataPtr;
   3221                
   3222                status = zclWriteAttrData( &attrRec, statusRec );
   3223                   
   3224                // If successful, a write attribute status record shall NOT be generated
   3225                if ( status != ZCL_STATUS_SUCCESS )
   3226                {
   3227                  writeRspCmd->attrList[j].status = status;
   3228                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3229                    
   3230                  // Since this write failed, we need to revert all the pervious writes
   3231                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   3232                  break;
   3233                }
   3234                
   3235                dataLen = zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0000FA                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000FA   85..82       MOV     DPL,?V0 + 2
   \   0000FD   85..83       MOV     DPH,?V0 + 3
   \   000100   A3           INC     DPTR
   \   000101   A3           INC     DPTR
   \   000102   A3           INC     DPTR
   \   000103   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000106   12....       LCALL   ??Subroutine129_0 & 0xFFFF
   3236                
   3237                // add padding if needed
   3238                if ( PADDING_NEEDED( dataLen ) )
   \                     ??CrossCallReturnLabel_188:
   \   000109   A2E0         MOV     C,0xE0 /* A   */.0
   \   00010B   5001         JNC     ??zclProcessInWriteUndividedCmd_16
   3239                  dataLen++;
   \   00010D   0A           INC     R2
   3240                curDataPtr += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   00010E   8A..         MOV     ?V0 + 2,R2
   \   000110   E5..         MOV     A,?V0 + 4
   \   000112   25..         ADD     A,?V0 + 2
   \   000114   F5..         MOV     ?V0 + 4,A
   \   000116   E5..         MOV     A,?V0 + 5
   \   000118   3400         ADDC    A,#0x0
   \   00011A   F5..         MOV     ?V0 + 5,A
   \   00011C   0E           INC     R6
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   00011D   85..82       MOV     DPL,?V0 + 6
   \   000120   85..83       MOV     DPH,?V0 + 7
   \   000123   E0           MOVX    A,@DPTR
   \   000124   FA           MOV     R2,A
   \   000125   EE           MOV     A,R6
   \   000126   C3           CLR     C
   \   000127   9A           SUBB    A,R2
   \   000128   4003         JC      $+5
   \   00012A   02....       LJMP    ??zclProcessInWriteUndividedCmd_17 & 0xFFFF
   \   00012D   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000130   E5..         MOV     A,?V0 + 12
   \   000132   28           ADD     A,R0
   \   000133   F8           MOV     R0,A
   \   000134   E5..         MOV     A,?V0 + 13
   \   000136   39           ADDC    A,R1
   \   000137   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   00013A   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   00013D   12....       LCALL   ?XSTACK_DISP0_8
   \   000140   8582..       MOV     ?V0 + 10,DPL
   \   000143   8583..       MOV     ?V0 + 11,DPH
   \   000146   78..         MOV     R0,#?V0 + 10
   \   000148   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014B   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   00014E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000151   E9           MOV     A,R1
   \   000152   7003         JNZ     $+5
   \   000154   02....       LJMP    ??zclProcessInWriteUndividedCmd_17 & 0xFFFF
   \   000157   85..82       MOV     DPL,?V0 + 2
   \   00015A   85..83       MOV     DPH,?V0 + 3
   \   00015D   12....       LCALL   ??Subroutine131_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000160   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   000163   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   000166                ; Setup parameters for call to function zclReadAttrData
   \   000166   7402         MOV     A,#0x2
   \   000168   12....       LCALL   ?XSTACK_DISP0_8
   \   00016B   AC82         MOV     R4,DPL
   \   00016D   AD83         MOV     R5,DPH
   \   00016F   AA..         MOV     R2,?V0 + 4
   \   000171   AB..         MOV     R3,?V0 + 5
   \   000173   12....       LCALL   ??zclReadAttrData?relay
   \   000176   85..82       MOV     DPL,?XSP + 0
   \   000179   85..83       MOV     DPH,?XSP + 1
   \   00017C   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   00017F   E5..         MOV     A,?V0 + 4
   \   000181   F0           MOVX    @DPTR,A
   \   000182   A3           INC     DPTR
   \   000183   E5..         MOV     A,?V0 + 5
   \   000185   F0           MOVX    @DPTR,A
   \   000186                ; Setup parameters for call to function zclWriteAttrData
   \   000186   AC..         MOV     R4,?V0 + 2
   \   000188   AD..         MOV     R5,?V0 + 3
   \   00018A   7402         MOV     A,#0x2
   \   00018C   12....       LCALL   ?XSTACK_DISP0_8
   \   00018F   AA82         MOV     R2,DPL
   \   000191   AB83         MOV     R3,DPH
   \   000193   12....       LCALL   ??zclWriteAttrData?relay
   \   000196   E9           MOV     A,R1
   \   000197   FB           MOV     R3,A
   \   000198   7003         JNZ     $+5
   \   00019A   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   00019D   EF           MOV     A,R7
   \   00019E   75F003       MOV     B,#0x3
   \   0001A1   A4           MUL     AB
   \   0001A2   F8           MOV     R0,A
   \   0001A3   A9F0         MOV     R1,B
   \   0001A5   E5..         MOV     A,?V0 + 0
   \   0001A7   28           ADD     A,R0
   \   0001A8   F8           MOV     R0,A
   \   0001A9   E5..         MOV     A,?V0 + 1
   \   0001AB   39           ADDC    A,R1
   \   0001AC   F9           MOV     R1,A
   \   0001AD   EB           MOV     A,R3
   \   0001AE   8882         MOV     DPL,R0
   \   0001B0   8983         MOV     DPH,R1
   \   0001B2   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   0001B5   FA           MOV     R2,A
   \   0001B6   A3           INC     DPTR
   \   0001B7   E0           MOVX    A,@DPTR
   \   0001B8   FB           MOV     R3,A
   \   0001B9   8882         MOV     DPL,R0
   \   0001BB   8983         MOV     DPH,R1
   \   0001BD   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   0001C0   0F           INC     R7
   \   0001C1   8E82         MOV     DPL,R6
   \   0001C3   8582..       MOV     ?V0 + 8,DPL
   \   0001C6   7E00         MOV     R6,#0x0
   \   0001C8   8032         SJMP    ??zclProcessInWriteUndividedCmd_18
   3241              } // for loop
   \                     ??zclProcessInWriteUndividedCmd_19:
   \   0001CA   E5..         MOV     A,?V0 + 2
   \   0001CC   2403         ADD     A,#0x3
   \   0001CE   F5..         MOV     ?V0 + 2,A
   \   0001D0   E5..         MOV     A,?V0 + 3
   \   0001D2   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   0001D5   12....       LCALL   ??Subroutine131_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   0001D8   740E         MOV     A,#0xe
   \   0001DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DD   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   0001E0                ; Setup parameters for call to function osal_memcpy
   \   0001E0   85..82       MOV     DPL,?V0 + 2
   \   0001E3   85..83       MOV     DPH,?V0 + 3
   \   0001E6   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   0001E9   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001EC   EA           MOV     A,R2
   \   0001ED   FC           MOV     R4,A
   \   0001EE   7D00         MOV     R5,#0x0
   \   0001F0   7413         MOV     A,#0x13
   \   0001F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F5   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   0001F8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001FB   0E           INC     R6
   \                     ??zclProcessInWriteUndividedCmd_18:
   \   0001FC   8E..         MOV     ?V0 + 2,R6
   \   0001FE   C3           CLR     C
   \   0001FF   E5..         MOV     A,?V0 + 2
   \   000201   95..         SUBB    A,?V0 + 8
   \   000203   E4           CLR     A
   \   000204   9400         SUBB    A,#0x0
   \   000206   5058         JNC     ??zclProcessInWriteUndividedCmd_17
   \   000208   EE           MOV     A,R6
   \   000209   75F005       MOV     B,#0x5
   \   00020C   A4           MUL     AB
   \   00020D   F8           MOV     R0,A
   \   00020E   A9F0         MOV     R1,B
   \   000210   E5..         MOV     A,?V0 + 12
   \   000212   28           ADD     A,R0
   \   000213   F5..         MOV     ?V0 + 2,A
   \   000215   E5..         MOV     A,?V0 + 13
   \   000217   39           ADDC    A,R1
   \   000218   F5..         MOV     ?V0 + 3,A
   \   00021A   85..82       MOV     DPL,?V0 + 14
   \   00021D   85..83       MOV     DPH,?V0 + 15
   \   000220   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000223                ; Setup parameters for call to function zclFindAttrRec
   \   000223   740A         MOV     A,#0xa
   \   000225   12....       LCALL   ?XSTACK_DISP0_8
   \   000228   8582..       MOV     ?V0 + 6,DPL
   \   00022B   8583..       MOV     ?V0 + 7,DPH
   \   00022E   78..         MOV     R0,#?V0 + 6
   \   000230   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000233   85..82       MOV     DPL,?V0 + 2
   \   000236   85..83       MOV     DPH,?V0 + 3
   \   000239   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   00023C   85..82       MOV     DPL,?V0 + 4
   \   00023F   85..83       MOV     DPH,?V0 + 5
   \   000242   A3           INC     DPTR
   \   000243   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   000246   E5..         MOV     A,?V0 + 4
   \   000248   2414         ADD     A,#0x14
   \   00024A   F582         MOV     DPL,A
   \   00024C   E5..         MOV     A,?V0 + 5
   \   00024E   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   000251   F9           MOV     R1,A
   \   000252   12....       LCALL   ??zclFindAttrRec?relay
   \   000255   7402         MOV     A,#0x2
   \   000257   12....       LCALL   ?DEALLOC_XSTACK8
   \   00025A   E9           MOV     A,R1
   \   00025B   6003         JZ      $+5
   \   00025D   02....       LJMP    ??zclProcessInWriteUndividedCmd_19 & 0xFFFF
   3242            
   3243              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   000260   EF           MOV     A,R7
   \   000261   85..82       MOV     DPL,?V0 + 0
   \   000264   85..83       MOV     DPH,?V0 + 1
   \   000267   F0           MOVX    @DPTR,A
   3244              if ( writeRspCmd->numAttr  == 0 )
   \   000268   7003         JNZ     ??CrossCallReturnLabel_13
   3245              {
   3246                // Since all records were written successful, include a single status record
   3247                // in the resonse command with the status field set to SUCCESS and the 
   3248                // attribute ID field omitted.
   3249                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   00026A   12....       LCALL   ?Subroutine10 & 0xFFFF
   3250                writeRspCmd->numAttr = 1;
   3251              }
   3252          
   3253              osal_mem_free( curWriteRec );
   \                     ??CrossCallReturnLabel_13:
   \   00026D                ; Setup parameters for call to function osal_mem_free
   \   00026D   AA..         MOV     R2,?V0 + 12
   \   00026F   AB..         MOV     R3,?V0 + 13
   \   000271   12....       LCALL   ??osal_mem_free?relay
   3254            }
   3255            
   3256            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3257                              pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   3258                              true, pInMsg->hdr.transSeqNum );  
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   000274   85..82       MOV     DPL,?V0 + 14
   \   000277   85..83       MOV     DPH,?V0 + 15
   \   00027A   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00027D                ; Setup parameters for call to function zcl_SendWriteRsp
   \   00027D   85..82       MOV     DPL,?V0 + 14
   \   000280   85..83       MOV     DPH,?V0 + 15
   \   000283   A3           INC     DPTR
   \   000284   A3           INC     DPTR
   \   000285   A3           INC     DPTR
   \   000286   A3           INC     DPTR
   \   000287   A3           INC     DPTR
   \   000288   A3           INC     DPTR
   \   000289   E0           MOVX    A,@DPTR
   \   00028A   F5..         MOV     ?V0 + 2,A
   \   00028C   78..         MOV     R0,#?V0 + 2
   \   00028E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000291   75..01       MOV     ?V0 + 2,#0x1
   \   000294   78..         MOV     R0,#?V0 + 2
   \   000296   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000299   78..         MOV     R0,#?V0 + 2
   \   00029B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00029E   78..         MOV     R0,#?V0 + 0
   \   0002A0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002A3   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0002A6   12....       LCALL   ?DEALLOC_XSTACK8
   3259            osal_mem_free( writeRspCmd );
   \   0002A9                ; Setup parameters for call to function osal_mem_free
   \   0002A9   AA..         MOV     R2,?V0 + 0
   \   0002AB   AB..         MOV     R3,?V0 + 1
   \   0002AD   12....       LCALL   ??osal_mem_free?relay
   3260           
   3261            return TRUE; 
   \   0002B0   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   0002B2   02....       LJMP    ?Subroutine119 & 0xFFFF
   3262          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   EE           MOV     A,R6
   \   000001   75F005       MOV     B,#0x5
   \   000004   A4           MUL     AB
   \   000005   F8           MOV     R0,A
   \   000006   A9F0         MOV     R1,B
   \   000008   E5..         MOV     A,?V0 + 6
   \   00000A   28           ADD     A,R0
   \   00000B   F582         MOV     DPL,A
   \   00000D   E5..         MOV     A,?V0 + 7
   \   00000F   39           ADDC    A,R1
   \   000010   F583         MOV     DPH,A
   \   000012   A3           INC     DPTR
   \   000013   8582..       MOV     ?V0 + 2,DPL
   \   000016   8583..       MOV     ?V0 + 3,DPH
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   85..82       MOV     DPL,?V0 + 14
   \   000003   85..83       MOV     DPH,?V0 + 15
   \   000006                REQUIRE ??Subroutine146_0
   \   000006                ; // Fall through to label ??Subroutine146_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   A3           INC     DPTR
   \   000001   F0           MOVX    @DPTR,A
   \   000002   85..82       MOV     DPL,?V0 + 2
   \   000005   85..83       MOV     DPH,?V0 + 3
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000003   A3           INC     DPTR
   \   000004   22           RET
   3263          #endif // ZCL_WRITE
   3264          
   3265          #ifdef ZCL_DISCOVER
   3266          /*********************************************************************
   3267           * @fn      zclProcessInDiscCmd
   3268           *
   3269           * @brief   Process the "Profile" Discover Command
   3270           *
   3271           * @param   pInMsg - incoming message to process
   3272           *
   3273           * @return  TRUE if command processed. FALSE, otherwise.
   3274           */
   3275          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   3276          {
   3277            zclDiscoverCmd_t *discoverCmd;
   3278            zclDiscoverRspCmd_t *discoverRspCmd;
   3279            uint8 discComplete = TRUE;
   3280            zclAttrRec_t attrRec;
   3281            uint16 attrID;
   3282            uint8 i;
   3283            
   3284            discoverCmd = (zclDiscoverCmd_t *)pInMsg->attrCmd;
   3285            
   3286            // Find out the number of attributes supported within the specified range
   3287            for ( i = 0, attrID = discoverCmd->startAttr; i < discoverCmd->maxAttrIDs; i++, attrID++ )
   3288            {
   3289              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3290                break;
   3291            }
   3292            
   3293            // Allocate space for the response command
   3294            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof (zclDiscoverRspCmd_t) 
   3295                                                                   + sizeof ( zclDiscoverInfo_t ) * i );
   3296            if ( discoverRspCmd == NULL )
   3297              return FALSE; // EMEDDED RETURN
   3298            
   3299            discoverRspCmd->numAttr = i;
   3300            if ( discoverRspCmd->numAttr != 0 )
   3301            {
   3302              for ( i = 0, attrID = discoverCmd->startAttr; i < discoverRspCmd->numAttr; i++, attrID++ )
   3303              {
   3304                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3305                  break; // Attribute not supported
   3306                
   3307                discoverRspCmd->attrList[i].attrID = attrRec.attr.attrId;
   3308                discoverRspCmd->attrList[i].dataType = attrRec.attr.dataType;
   3309              }
   3310              
   3311              // Are there more attributes to be discovered?
   3312              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3313                discComplete = FALSE;
   3314            }
   3315            
   3316            discoverRspCmd->discComplete = discComplete;
   3317            zcl_SendDiscoverRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr, 
   3318                                    pInMsg->msg->clusterId, discoverRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR, 
   3319                                    true, pInMsg->hdr.transSeqNum );
   3320            osal_mem_free( discoverRspCmd );
   3321            
   3322            return TRUE;
   3323          }
   3324          #endif // ZCL_DISCOVER
   3325          
   3326          /*********************************************************************
   3327           * @fn      zclSendMsg
   3328           *
   3329           * @brief   Send an incoming message to the Application
   3330           *
   3331           * @param   pInMsg - incoming message to process
   3332           *
   3333           * @return  TRUE
   3334           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3335          static uint8 zclSendMsg( zclIncoming_t *pInMsg )
   \                     zclSendMsg:
   3336          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   3337            zclIncomingMsg_t *pCmd;
   3338              
   3339            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000009   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   64FF         XRL     A,#0xff
   \   00000F   7005         JNZ     ??zclSendMsg_0
   3340              return ( TRUE );
   \                     ??zclSendMsg_1:
   \   000011   7901         MOV     R1,#0x1
   \   000013   02....       LJMP    ?Subroutine113 & 0xFFFF
   3341            
   3342            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \                     ??zclSendMsg_0:
   \   000016                ; Setup parameters for call to function osal_msg_allocate
   \   000016   7A18         MOV     R2,#0x18
   \   000018   7B00         MOV     R3,#0x0
   \   00001A   12....       LCALL   ??osal_msg_allocate?relay
   3343            if ( pCmd != NULL )
   \   00001D   EA           MOV     A,R2
   \   00001E   7001         JNZ     ??zclSendMsg_2
   \   000020   EB           MOV     A,R3
   \                     ??zclSendMsg_2:
   \   000021   60EE         JZ      ??zclSendMsg_1
   3344            {
   3345              // fill in the message
   3346              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   000023   7434         MOV     A,#0x34
   \   000025   12....       LCALL   ?Subroutine7 & 0xFFFF
   3347              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_217:
   \   000028   A3           INC     DPTR
   \   000029   EA           MOV     A,R2
   \   00002A   2402         ADD     A,#0x2
   \   00002C   FC           MOV     R4,A
   \   00002D   EB           MOV     A,R3
   \   00002E   3400         ADDC    A,#0x0
   \   000030   FD           MOV     R5,A
   \   000031   7406         MOV     A,#0x6
   \   000033   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   3348              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   00003D   A3           INC     DPTR
   \   00003E   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   E8           MOV     A,R0
   \   00004E   12....       LCALL   ?Subroutine12 & 0xFFFF
   3349              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_18:
   \   000051   F8           MOV     R0,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F583         MOV     DPH,A
   \   000056   8882         MOV     DPL,R0
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   EA           MOV     A,R2
   \   00005F   240A         ADD     A,#0xa
   \   000061   FC           MOV     R4,A
   \   000062   EB           MOV     A,R3
   \   000063   3400         ADDC    A,#0x0
   \   000065   FD           MOV     R5,A
   \   000066   740C         MOV     A,#0xc
   \   000068   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   3350              pCmd->attrCmd   = pInMsg->attrCmd;
   \   00006B   EE           MOV     A,R6
   \   00006C   240C         ADD     A,#0xc
   \   00006E   F8           MOV     R0,A
   \   00006F   EF           MOV     A,R7
   \   000070   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   000073   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   000076   EA           MOV     A,R2
   \   000077   2416         ADD     A,#0x16
   \   000079   F582         MOV     DPL,A
   \   00007B   EB           MOV     A,R3
   \   00007C   3400         ADDC    A,#0x0
   \   00007E   F583         MOV     DPH,A
   \   000080   EC           MOV     A,R4
   \   000081   F0           MOVX    @DPTR,A
   \   000082   A3           INC     DPTR
   \   000083   ED           MOV     A,R5
   \   000084   F0           MOVX    @DPTR,A
   3351              
   3352              // Application will free the attrCmd buffer
   3353              pInMsg->attrCmd = NULL;
   \   000085   8882         MOV     DPL,R0
   \   000087   8983         MOV     DPH,R1
   \   000089   E4           CLR     A
   \   00008A   F0           MOVX    @DPTR,A
   \   00008B   A3           INC     DPTR
   \   00008C   F0           MOVX    @DPTR,A
   3354              
   3355              /* send message through task message */
   3356              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   00008D                ; Setup parameters for call to function osal_msg_send
   \   00008D   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000090   E0           MOVX    A,@DPTR
   \   000091   F9           MOV     R1,A
   \   000092   12....       LCALL   ??osal_msg_send?relay
   \   000095   02....       LJMP    ??zclSendMsg_1 & 0xFFFF
   3357            }
   3358            
   3359            return ( TRUE );
   3360          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_event_loop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerPlugin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerAttrList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerClusterOptionList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerValidateAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerForMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_DeviceOperational?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRequest?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessMessageMSG?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclBuildHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindAttrRec?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSetSecurityOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSerializeData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetDataTypeLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAttrDataLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclWriteAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSendMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSendMsg
   3361          
   3362          /*********************************************************************
   3363          *********************************************************************/

   Maximum stack usage in bytes:

     Function                      ISTACK PSTACK XSTACK
     --------                      ------ ------ ------
     zclBuildHdr                       1      0     54
     zclFindAttrRec                    1      0     62
     zclFindClusterOption              1      0     21
     zclGetAttrDataLength              2      0     42
       -> zclGetDataTypeLength         4      0      0
     zclGetClusterOption               0      0     52
       -> zclFindClusterOption         0      0     20
     zclGetDataTypeLength              2      0      0
     zclParseHdr                       1      0     49
       -> osal_memset                  0      0     24
     zclParseInDefaultRspCmd           1      0     10
       -> osal_mem_alloc               0      0     20
     zclParseInReadCmd                 1      0     12
       -> osal_mem_alloc               0      0     24
     zclParseInReadRspCmd              1      0     23
       -> zclGetAttrDataLength         0      0     40
       -> osal_mem_alloc               0      0     40
       -> zclGetAttrDataLength         0      0     40
       -> osal_memcpy                  0      0     46
     zclParseInWriteCmd                1      0     23
       -> zclGetAttrDataLength         0      0     40
       -> osal_mem_alloc               0      0     40
       -> zclGetAttrDataLength         0      0     40
       -> osal_memcpy                  0      0     46
     zclParseInWriteRspCmd             1      0     16
       -> osal_mem_alloc               0      0     32
     zclProcessInReadCmd               1      0     35
       -> osal_mem_alloc               0      0     60
       -> zclFindAttrRec               0      0     64
       -> zcl_SendReadRsp              0      0     70
       -> osal_mem_free                0      0     60
     zclProcessInWriteCmd              1      0     39
       -> osal_mem_alloc               0      0     68
       -> zclFindAttrRec               0      0     72
       -> zclWriteAttrData             0      0     68
       -> zcl_SendWriteRsp             0      0     78
       -> osal_mem_free                0      0     68
     zclProcessInWriteUndividedCmd     1      0     47
       -> osal_mem_alloc               0      0     84
       -> zclGetAttrDataLength         0      0     84
       -> zclFindAttrRec               0      0     88
       -> osal_mem_alloc               0      0     84
       -> osal_mem_free                0      0     84
       -> zclGetAttrDataLength         0      0     84
       -> zclFindAttrRec               0      0     88
       -> zclReadAttrData              0      0     84
       -> zclWriteAttrData             0      0     84
       -> zclGetAttrDataLength         0      0     84
       -> osal_memcpy                  0      0     90
       -> zclFindAttrRec               0      0     88
       -> osal_mem_free                0      0     84
       -> zcl_SendWriteRsp             0      0     94
       -> osal_mem_free                0      0     84
     zclProcessMessageMSG              2      0     56
       -> zclParseHdr                  0      0     74
       -> afFindEndPointDesc           0      0     74
       -> zcl_DeviceOperational        0      0     78
       -> zclGetClusterOption          0      0     74
       -> zclSetSecurityOption         0      0     74
       -> zcl_SendDefaultRspCmd        0      0     88
       -> zclSetSecurityOption         0      0     74
       -> osal_mem_free                0      0     74
       -> zcl_SendDefaultRspCmd        0      0     88
     zclReadAttrData                   0      0     56
       -> zclGetAttrDataLength         0      0     22
       -> osal_memcpy                  0      0     28
     zclSendMsg                        1      0     10
       -> osal_msg_allocate            0      0     20
       -> osal_msg_send                0      0     20
     zclSerializeData                  1      0     44
       -> osal_buffer_uint32           0      0     32
       -> osal_memcpy                  0      0     30
       -> osal_memcpy                  0      0     30
       -> osal_memcpy                  0      0     30
       -> osal_memcpy                  0      0     30
     zclSetSecurityOption              0      0     47
       -> zclFindClusterOption         0      0     20
     zclWriteAttrData                  0      0     60
       -> zclGetAttrDataLength         0      0     30
       -> osal_memcpy                  0      0     36
     zcl_DeviceOperational             1      0     65
       -> zclFindAttrRec               0      0     42
       -> zclReadAttrData              0      0     38
     zcl_Init                          2      0      0
     zcl_SendCommand                   1      0     90
       -> osal_memcpy                  0      0     90
       -> afFindEndPointDesc           0      0     84
       -> zclGetClusterOption          0      0     84
       -> osal_memset                  0      0     84
       -> zcl_DeviceOperational        0      0     88
       -> osal_mem_alloc               0      0     84
       -> zclBuildHdr                  0      0     90
       -> osal_memcpy                  0      0     90
       -> AF_DataRequest               0      0    102
       -> osal_mem_free                0      0     84
     zcl_SendDefaultRspCmd             1      0     71
       -> zcl_SendCommand              0      0     54
     zcl_SendRead                      1      0     38
       -> osal_mem_alloc               0      0     44
       -> zcl_SendCommand              0      0     66
       -> osal_mem_free                0      0     44
     zcl_SendReadRsp                   1      0     74
       -> zclGetAttrDataLength         0      0     56
       -> osal_mem_alloc               0      0     56
       -> zclSerializeData             0      0     56
       -> zclGetAttrDataLength         0      0     56
       -> zcl_SendCommand              0      0     78
       -> osal_mem_free                0      0     56
     zcl_SendWriteRequest              1      0     45
       -> zclGetAttrDataLength         0      0     56
       -> osal_mem_alloc               0      0     56
       -> zclSerializeData             0      0     56
       -> zclGetAttrDataLength         0      0     56
       -> zcl_SendCommand              0      0     78
       -> osal_mem_free                0      0     56
     zcl_SendWriteRsp                  1      0     80
       -> osal_mem_alloc               0      0     44
       -> zcl_SendCommand              0      0     66
       -> osal_mem_free                0      0     44
     zcl_event_loop                    0      0     12
       -> osal_msg_receive             0      0     24
       -> zclProcessMessageMSG         0      0     24
       -> osal_msg_deallocate          0      0     24
       -> osal_msg_receive             0      0     24
       -> osal_msg_send                0      0     24
     zcl_registerAttrList              1      0     12
       -> osal_mem_alloc               0      0     24
     zcl_registerClusterOptionList     1      0     12
       -> osal_mem_alloc               0      0     24
     zcl_registerForMsg                2      0      0
     zcl_registerPlugin                0      0     16
       -> osal_mem_alloc               0      0     28
     zcl_registerValidateAttrData      2      0      0


   Segment part sizes:

     Function/Label                             Bytes
     --------------                             -----
     zcl_TaskID                                    1
     zcl_RegisteredMsgTaskID                       1
     zcl_ValidateAttrDataCB                        2
     zcl_SeqNum                                    1
     plugins                                       2
     attrList                                      2
     clusterOptionList                             2
     zcl_TransID                                   1
     zclCmdTable                                  56
     zcl_Init                                     31
     ?Subroutine103                                7
     zcl_event_loop                              102
     ?Subroutine104                                5
     zcl_registerPlugin                          127
     ?Subroutine105                                5
     ?Subroutine33                                 5
     ??Subroutine120_0                             5
     ?Subroutine11                                 8
     ?Subroutine14                                 4
     ?Subroutine96                                 7
     ?Subroutine86                                 5
     ??Subroutine132_0                             6
     ?Subroutine39                                 6
     ?Subroutine17                                 2
     ??Subroutine147_0                             6
     zcl_registerAttrList                         59
     ?Subroutine62                                25
     ?Subroutine0                                 28
     ?Subroutine77                                 6
     zcl_registerClusterOptionList                59
     zcl_registerValidateAttrData                 14
     zcl_registerForMsg                           20
     zcl_DeviceOperational                       118
     ?Subroutine113                                5
     zcl_SendCommand                             514
     ?Subroutine119                                4
     ??Subroutine121_0                             8
     ?Subroutine40                                10
     ?Subroutine107                                6
     ?Subroutine87                                 6
     ?Subroutine78                                 8
     zcl_SendRead                                218
     ?Subroutine115                                2
     ??Subroutine122_0                             5
     ?Subroutine28                                 5
     ??Subroutine123_0                            11
     ?Subroutine110                                5
     ?Subroutine92                                 6
     ?Subroutine63                                11
     ?Subroutine56                                 6
     ?Subroutine41                                10
     ?Subroutine114                                4
     zcl_SendReadRsp                             251
     ?Subroutine85                                 7
     ?Subroutine72                                 4
     ?Subroutine93                                 7
     ?Subroutine64                                21
     ?Subroutine57                                10
     ?Subroutine44                                16
     ?Subroutine83                                 5
     ?Subroutine98                                11
     ?Subroutine42                                10
     ?Subroutine37                                13
     ?Subroutine36                                 9
     ?Subroutine20                                28
     ?Subroutine109                                5
     ?Subroutine79                                20
     ?Subroutine2                                 21
     ?Subroutine1                                 25
     ??Subroutine127_0                             5
     ?Subroutine81                                 3
     ?Subroutine101                               12
     zcl_SendWriteRequest                        222
     zcl_SendWriteRsp                            250
     zcl_SendDefaultRspCmd                       171
     ?Subroutine55                                 4
     zclProcessMessageMSG                       1085
     ?Subroutine116                                5
     ?Subroutine73                                15
     ?Subroutine58                                 7
     ?Subroutine52                                11
     ?Subroutine51                                11
     ?Subroutine48                                12
     ?Subroutine45                                 5
     ?Subroutine31                                 7
     ?Subroutine88                                 8
     ?Subroutine27                                15
     ?Subroutine26                                13
     ?Subroutine100                                8
     ?Subroutine74                                 8
     ?Subroutine25                                 3
     ??Subroutine125_0                             2
     ??Subroutine126_0                             2
     ?Subroutine34                                 3
     ??Subroutine128_0                             5
     ??Subroutine131_0                             4
     ??Subroutine140_0                             1
     ??Subroutine141_0                             5
     ?Subroutine89                                 4
     ?Subroutine99                                 9
     ??Subroutine144_0                             6
     ?Subroutine65                                 3
     ??Subroutine145_0                             4
     ?Subroutine91                                10
     ?Subroutine43                                 4
     ?Subroutine80                                12
     ?Subroutine84                                 6
     zclParseHdr                                 224
     ?Subroutine112                                5
     ?Subroutine9                                  4
     ?Subroutine75                                 5
     ??Subroutine135_0                             4
     ?Subroutine76                                 9
     ?Subroutine102                                8
     ?Subroutine5                                  6
     ??Subroutine136_0                             5
     ??Subroutine138_0                             7
     ?Subroutine97                                 4
     ?Subroutine12                                 8
     zclBuildHdr                                 102
     ?Subroutine53                                11
     ?Subroutine16                                 7
     ??Subroutine124_0                             7
     ?Subroutine8                                  6
     ?Subroutine111                                5
     zclFindAttrRec                              186
     zclFindClusterOption                        123
     ?Subroutine117                                5
     zclGetClusterOption                          32
     zclSetSecurityOption                         46
     zclSerializeData                            289
     ?Subroutine15                                 5
     ?Subroutine49                                 4
     ??Subroutine139_0                             4
     zclGetDataTypeLength                        131
     zclGetAttrDataLength                         29
     zclReadAttrData                              75
     ?Subroutine29                                 2
     ??Subroutine129_0                             2
     ??Subroutine130_0                             5
     zclWriteAttrData                            122
     ?Subroutine108                                6
     ??Subroutine142_0                             4
     ?Subroutine50                                 6
     ?Subroutine35                                 6
     zclParseInReadCmd                            99
     ?Subroutine32                                25
     ?Subroutine61                                10
     zclParseInReadRspCmd                        126
     ?Subroutine118                                9
     ?Subroutine60                                22
     ??Subroutine133_0                             4
     ?Subroutine21                                 7
     ??Subroutine134_0                            22
     ?Subroutine6                                  8
     ?Subroutine71                                14
     ?Subroutine69                                 5
     ?Subroutine106                                6
     ?Subroutine68                                16
     ?Subroutine67                                26
     ?Subroutine38                                25
     ?Subroutine23                                32
     ?Subroutine4                                 23
     ?Subroutine3                                 35
     ?Subroutine95                                 4
     ?Subroutine94                                15
     ?Subroutine90                                 9
     zclParseInWriteCmd                          103
     zclParseInWriteRspCmd                       123
     zclParseInDefaultRspCmd                      44
     ?Subroutine7                                  4
     zclProcessInReadCmd                         320
     ?Subroutine82                                 6
     ??Subroutine137_0                             8
     ?Subroutine54                                 1
     ??Subroutine143_0                            34
     ?Subroutine66                                 6
     ?Subroutine13                                 7
     zclProcessInWriteCmd                        358
     ?Subroutine47                                 6
     ??Subroutine146_0                             6
     ?Subroutine24                                19
     ?Subroutine22                                38
     ?Subroutine10                                13
     ?Subroutine59                                 3
     ?Subroutine19                                 6
     zclProcessInWriteUndividedCmd               693
     ?Subroutine70                                26
     ?Subroutine30                                 6
     ?Subroutine18                                10
     ?Subroutine46                                 5
     zclSendMsg                                  152
     ?<Initializer for zcl_RegisteredMsgTaskID>    1
     ??zcl_Init?relay                              6
     ??zcl_event_loop?relay                        6
     ??zcl_registerPlugin?relay                    6
     ??zcl_registerAttrList?relay                  6
     ??zcl_registerClusterOptionList?relay         6
     ??zcl_registerValidateAttrData?relay          6
     ??zcl_registerForMsg?relay                    6
     ??zcl_DeviceOperational?relay                 6
     ??zcl_SendCommand?relay                       6
     ??zcl_SendRead?relay                          6
     ??zcl_SendReadRsp?relay                       6
     ??zcl_SendWriteRequest?relay                  6
     ??zcl_SendWriteRsp?relay                      6
     ??zcl_SendDefaultRspCmd?relay                 6
     ??zclProcessMessageMSG?relay                  6
     ??zclParseHdr?relay                           6
     ??zclBuildHdr?relay                           6
     ??zclFindAttrRec?relay                        6
     ??zclFindClusterOption?relay                  6
     ??zclGetClusterOption?relay                   6
     ??zclSetSecurityOption?relay                  6
     ??zclSerializeData?relay                      6
     ??zclGetDataTypeLength?relay                  6
     ??zclGetAttrDataLength?relay                  6
     ??zclReadAttrData?relay                       6
     ??zclWriteAttrData?relay                      6
     ??zclParseInReadCmd?relay                     6
     ??zclParseInReadRspCmd?relay                  6
     ??zclParseInWriteCmd?relay                    6
     ??zclParseInWriteRspCmd?relay                 6
     ??zclParseInDefaultRspCmd?relay               6
     ??zclProcessInReadCmd?relay                   6
     ??zclProcessInWriteCmd?relay                  6
     ??zclProcessInWriteUndividedCmd?relay         6
     ??zclSendMsg?relay                            6

 
 7 975 bytes in segment BANKED_CODE
   210 bytes in segment BANK_RELAYS
    56 bytes in segment CODE_C
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
    11 bytes in segment XDATA_Z
 
 8 242 bytes of CODE  memory
    12 bytes of XDATA memory

Errors: none
Warnings: none
