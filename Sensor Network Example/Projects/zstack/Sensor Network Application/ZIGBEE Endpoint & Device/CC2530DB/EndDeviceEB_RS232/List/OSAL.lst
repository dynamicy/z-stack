###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                27/Aug/2010  09:58:55 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeRouter\X #
#                          T200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\Componen #
#                          ts\osal\common\OSAL.c                              #
#    Command line       =  -f "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeRout #
#                          er\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\Proj #
#                          ects\zstack\Sensor Network Application\ZIGBEE      #
#                          Endpoint & Device\CC2530DB\..\..\..\Tools\CC2530DB #
#                          \f8wEndev.cfg" (-DCPU32MHZ -DROOT=__near_func      #
#                          -DBLINK_LEDS) -f "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-St #
#                          ack_ZigbeeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\Sensor Network           #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig. #
#                          cfg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0             #
#                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800          #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440)   #
#                          -f "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeRout #
#                          er\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\Proj #
#                          ects\zstack\Sensor Network Application\ZIGBEE      #
#                          Endpoint & Device\CC2530DB\..\..\..\Tools\CC2530DB #
#                          \f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC   #
#                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH    #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING) -DZCL_MESSAGE                       #
#                          D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeRouter\X #
#                          T200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\Componen #
#                          ts\osal\common\OSAL.c -D LCD_SUPPORTED=DEBUG -D    #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_APP_FUNC -D        #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D MT_TASK -D           #
#                          xPOWER_SAVING -D xNV_RESTORE -D End_Device -D      #
#                          xHAL_KEYPAD -D xPA2591 -lC                         #
#                          "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeRouter\ #
#                          XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\Project #
#                          s\zstack\Sensor Network Application\ZIGBEE         #
#                          Endpoint & Device\CC2530DB\EndDeviceEB_RS232\List\ #
#                          " -lA "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeR #
#                          outer\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\P #
#                          rojects\zstack\Sensor Network Application\ZIGBEE   #
#                          Endpoint & Device\CC2530DB\EndDeviceEB_RS232\List\ #
#                          " --diag_suppress Pe001,Pa010 -o                   #
#                          "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeRouter\ #
#                          XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\Project #
#                          s\zstack\Sensor Network Application\ZIGBEE         #
#                          Endpoint & Device\CC2530DB\EndDeviceEB_RS232\Obj\" #
#                           -e --require_prototypes --debug --core=plain      #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì #
#                          ¤j_Z-Stack_ZigbeeRouter\XT200_PA_Z-Stack\ZStack-CC #
#                          2530-2.3.0-1.4.0\Projects\zstack\Sensor Network    #
#                          Application\ZIGBEE Endpoint & Device\CC2530DB\"    #
#                          -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeRout #
#                          er\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\Proj #
#                          ects\zstack\Sensor Network Application\ZIGBEE      #
#                          Endpoint & Device\CC2530DB\..\SOURCE\" -I          #
#                          "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeRouter\ #
#                          XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\Project #
#                          s\zstack\Sensor Network Application\ZIGBEE         #
#                          Endpoint & Device\CC2530DB\..\..\SOURCE\" -I       #
#                          "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeRouter\ #
#                          XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\Project #
#                          s\zstack\Sensor Network Application\ZIGBEE         #
#                          Endpoint & Device\CC2530DB\..\..\..\ZMAIN\TI2530DB #
#                          \" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeR #
#                          outer\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\P #
#                          rojects\zstack\Sensor Network Application\ZIGBEE   #
#                          Endpoint & Device\CC2530DB\..\..\..\..\..\COMPONEN #
#                          TS\MT\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_Zi #
#                          gbeeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1. #
#                          4.0\Projects\zstack\Sensor Network                 #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCL #
#                          UDE\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_Zigb #
#                          eeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4. #
#                          0\Projects\zstack\Sensor Network                   #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\MODU #
#                          LE\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_Zigbe #
#                          eRouter\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0 #
#                          \Projects\zstack\Sensor Network                    #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARG #
#                          ET\CC2530EB\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-St #
#                          ack_ZigbeeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\Sensor Network           #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU #
#                          \CCSOC\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_Z #
#                          igbeeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1 #
#                          .4.0\Projects\zstack\Sensor Network                #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INC #
#                          LUDE\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_Zig #
#                          beeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4 #
#                          .0\Projects\zstack\Sensor Network                  #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF #
#                          \" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeR #
#                          outer\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\P #
#                          rojects\zstack\Sensor Network Application\ZIGBEE   #
#                          Endpoint & Device\CC2530DB\..\..\..\..\..\COMPONEN #
#                          TS\STACK\NWK\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-S #
#                          tack_ZigbeeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2 #
#                          .3.0-1.4.0\Projects\zstack\Sensor Network          #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SE #
#                          C\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_Zigbee #
#                          Router\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ #
#                          Projects\zstack\Sensor Network Application\ZIGBEE  #
#                          Endpoint & Device\CC2530DB\..\..\..\..\..\COMPONEN #
#                          TS\STACK\SAPI\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z- #
#                          Stack_ZigbeeRouter\XT200_PA_Z-Stack\ZStack-CC2530- #
#                          2.3.0-1.4.0\Projects\zstack\Sensor Network         #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SY #
#                          S\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_Zigbee #
#                          Router\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ #
#                          Projects\zstack\Sensor Network Application\ZIGBEE  #
#                          Endpoint & Device\CC2530DB\..\..\..\..\..\COMPONEN #
#                          TS\STACK\ZCL\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-S #
#                          tack_ZigbeeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2 #
#                          .3.0-1.4.0\Projects\zstack\Sensor Network          #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZD #
#                          O\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_Zigbee #
#                          Router\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ #
#                          Projects\zstack\Sensor Network Application\ZIGBEE  #
#                          Endpoint & Device\CC2530DB\..\..\..\..\..\COMPONEN #
#                          TS\ZMAC\F8W\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-St #
#                          ack_ZigbeeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\Sensor Network           #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\"   #
#                          -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeRout #
#                          er\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\Proj #
#                          ects\zstack\Sensor Network Application\ZIGBEE      #
#                          Endpoint & Device\CC2530DB\..\..\..\..\..\COMPONEN #
#                          TS\SERVICES\SADDR\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤ #
#                          j_Z-Stack_ZigbeeRouter\XT200_PA_Z-Stack\ZStack-CC2 #
#                          530-2.3.0-1.4.0\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SDATA\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_Z #
#                          igbeeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1 #
#                          .4.0\Projects\zstack\Sensor Network                #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCL #
#                          UDE\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_Zigb #
#                          eeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4. #
#                          0\Projects\zstack\Sensor Network                   #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH #
#                          _LEVEL\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_Z #
#                          igbeeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1 #
#                          .4.0\Projects\zstack\Sensor Network                #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\" -I "D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-St #
#                          ack_ZigbeeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2. #
#                          3.0-1.4.0\Projects\zstack\Sensor Network           #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\SINGLE_CHIP\" -I "C:\IAR               #
#                          Systems\Embedded Workbench MCS 51\8051\INC\" -I    #
#                          "C:\IAR Systems\Embedded Workbench MCS             #
#                          51\8051\INC\CLIB\" -Ohz                            #
#    List file          =  D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeRouter\X #
#                          T200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\Projects #
#                          \zstack\Sensor Network Application\ZIGBEE          #
#                          Endpoint & Device\CC2530DB\EndDeviceEB_RS232\List\ #
#                          OSAL.lst                                           #
#    Object file        =  D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeRouter\X #
#                          T200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\Projects #
#                          \zstack\Sensor Network Application\ZIGBEE          #
#                          Endpoint & Device\CC2530DB\EndDeviceEB_RS232\Obj\O #
#                          SAL.r51                                            #
#                                                                             #
#                                                                             #
###############################################################################

D:\Z-Stack¾ã²zCode\«n¶}¬ì¤j_Z-Stack_ZigbeeRouter\XT200_PA_Z-Stack\ZStack-CC2530-2.3.0-1.4.0\Components\osal\common\OSAL.c
      1          /**************************************************************************************************
      2            Filename:       OSAL.c
      3            Revised:        $Date: 2009-12-04 08:04:20 -0800 (Fri, 04 Dec 2009) $
      4            Revision:       $Revision: 21276 $
      5          
      6            Description:    This API allows the software components in the Z-stack to be written
      7                            independently of the specifics of the operating system, kernel or tasking
      8                            environment (including control loops or connect-to-interrupt systems).
      9          **************************************************************************************************/
     10          
     11          /*********************************************************************
     12           * INCLUDES
     13           */
     14          #include <string.h>
     15          #include "comdef.h"
     16          
     17          /* OSAL */
     18          #include "OSAL.h"
     19          #include "OSAL_Clock.h" 
     20          #include "OSAL_Tasks.h"
     21          #include "OSAL_Memory.h"
     22          #include "OSAL_PwrMgr.h"
     23          
     24          /* APP */
     25          #if defined(Coor_receiver)||(Router_receiver)
     26            #include "zcl_zigbee receiver.h"
     27          #endif
     28          #if defined(End_Device)
     29            #include "zcl_zigbee device.h"
     30          #endif
     31          
     32          
     33          /* HAL */
     34          #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     35          #include "hal_lcd.h"
     36          #include "hal_keypad.h"
     37          #include "hal_drivers.h"
     38          
     39          /*********************************************************************
     40           * MACROS
     41           */
     42          /*********************************************************************
     43           * CONSTANTS
     44           */
     45          /*********************************************************************
     46           * TYPEDEFS
     47           */
     48          /*********************************************************************
     49           * GLOBAL VARIABLES
     50           */
     51          // Message Pool Definitions

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     52          osal_msg_q_t osal_qHead;
   \                     osal_qHead:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     53          
     54          /*********************************************************************
     55           * EXTERNAL VARIABLES
     56           */
     57          /*********************************************************************
     58           * EXTERNAL FUNCTIONS
     59           */
     60          /*********************************************************************
     61           * LOCAL VARIABLES
     62           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     63           uint8 ch;
   \                     ch:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     64           
     65          /*********************************************************************
     66           * LOCAL FUNCTION PROTOTYPES
     67           */
     68          /*********************************************************************
     69           * HELPER FUNCTIONS
     70           */
     71          /* very ugly stub so Keil can compile */
     72          #ifdef __KEIL__
     73          char *  itoa ( int value, char * buffer, int radix )
     74          {
     75            return(buffer);
     76          }
     77          #endif
     78          
     79          /*********************************************************************
     80           * @fn      osal_strlen
     81           * @brief   Calculates the length of a string.  The string must be null
     82           *          terminated.
     83           * @param   char *pString - pointer to text string
     84           * @return  int - number of characters
     85           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     86          int osal_strlen( char *pString )
   \                     osal_strlen:
     87          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
     88            return (int)( strlen( pString ) );
   \   000004                ; Setup parameters for call to function strlen
   \   000004   12....       LCALL   ??strlen?relay
   \   000007   02....       LJMP    ?Subroutine22 & 0xFFFF
     89          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
     90          
     91          /*********************************************************************
     92           * @fn      osal_memcpy
     93           * @brief   Generic memory copy.
     94           *
     95           *   Note: This function differs from the standard memcpy(), since
     96           *         it returns the pointer to the next destination uint8. The
     97           *         standard memcpy() returns the original destination address.
     98           *
     99           * @param   dst - destination address
    100           *          src - source address
    101           *          len - number of bytes to copy
    102           * @return  pointer to end of destination buffer
    103           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    104          void *osal_memcpy( void *dst, const void GENERIC *src, unsigned int len )
   \                     osal_memcpy:
    105          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   740B         MOV     A,#0xb
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
    106            uint8 *pDst;
    107            const uint8 GENERIC *pSrc;
    108          
    109            pSrc = src;
   \   000013   A9..         MOV     R1,?V0 + 0
   \   000015   AA..         MOV     R2,?V0 + 1
   \   000017   FB           MOV     R3,A
    110            pDst = dst;
   \   000018   8E82         MOV     DPL,R6
   \   00001A   8F83         MOV     DPH,R7
   \   00001C   800D         SJMP    ??osal_memcpy_0
    111          
    112            while ( len-- )
    113              *pDst++ = *pSrc++;
   \                     ??osal_memcpy_1:
   \   00001E   12....       LCALL   ?C_GPTR_LOAD
   \   000021   F0           MOVX    @DPTR,A
   \   000022   E9           MOV     A,R1
   \   000023   2401         ADD     A,#0x1
   \   000025   09           INC     R1
   \   000026   EA           MOV     A,R2
   \   000027   3400         ADDC    A,#0x0
   \   000029   FA           MOV     R2,A
   \   00002A   A3           INC     DPTR
   \                     ??osal_memcpy_0:
   \   00002B   EC           MOV     A,R4
   \   00002C   FE           MOV     R6,A
   \   00002D   ED           MOV     A,R5
   \   00002E   FF           MOV     R7,A
   \   00002F   74FF         MOV     A,#-0x1
   \   000031   2E           ADD     A,R6
   \   000032   1C           DEC     R4
   \   000033   74FF         MOV     A,#-0x1
   \   000035   3F           ADDC    A,R7
   \   000036   FD           MOV     R5,A
   \   000037   EE           MOV     A,R6
   \   000038   7001         JNZ     ??osal_memcpy_2
   \   00003A   EF           MOV     A,R7
   \                     ??osal_memcpy_2:
   \   00003B   70E1         JNZ     ??osal_memcpy_1
    114          
    115            return ( pDst );
   \   00003D   AA82         MOV     R2,DPL
   \   00003F   AB83         MOV     R3,DPH
   \   000041                REQUIRE ?Subroutine23
   \   000041                ; // Fall through to label ?Subroutine23
    116          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   7F03         MOV     R7,#0x3
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007   22           RET
    117          
    118          /*********************************************************************
    119           * @fn      osal_revmemcpy
    120           * @brief   Generic reverse memory copy.  Starts at the end of the 
    121           *          source buffer, by taking the source address pointer and moving 
    122           *          pointer ahead "len" bytes, then decrementing the pointer.
    123           *
    124           *   Note: This function differs from the standard memcpy(), since
    125           *         it returns the pointer to the next destination uint8. The
    126           *         standard memcpy() returns the original destination address.
    127           *
    128           * @param   dst - destination address
    129           *          src - source address
    130           *          len - number of bytes to copy
    131           * @return  pointer to end of destination buffer
    132           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    133          void *osal_revmemcpy( void *dst, const void GENERIC *src, unsigned int len )
   \                     osal_revmemcpy:
    134          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   7409         MOV     A,#0x9
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F9           MOV     R1,A
   \   000010   A3           INC     DPTR
   \   000011   12....       LCALL   ?Subroutine9 & 0xFFFF
    135            uint8 *pDst;
    136            const uint8 GENERIC *pSrc;
    137          
    138            pSrc = src;
    139            pSrc += (len-1);
   \                     ??CrossCallReturnLabel_22:
   \   000014   E9           MOV     A,R1
   \   000015   2C           ADD     A,R4
   \   000016   F9           MOV     R1,A
   \   000017   EA           MOV     A,R2
   \   000018   3D           ADDC    A,R5
   \   000019   FA           MOV     R2,A
   \   00001A   E9           MOV     A,R1
   \   00001B   24FF         ADD     A,#-0x1
   \   00001D   19           DEC     R1
   \   00001E   EA           MOV     A,R2
   \   00001F   34FF         ADDC    A,#-0x1
   \   000021   FA           MOV     R2,A
    140            pDst = dst;
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   800D         SJMP    ??osal_revmemcpy_0
    141          
    142            while ( len-- )
    143              *pDst++ = *pSrc--;
   \                     ??osal_revmemcpy_1:
   \   000028   12....       LCALL   ?C_GPTR_LOAD
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   E9           MOV     A,R1
   \   00002D   24FF         ADD     A,#-0x1
   \   00002F   19           DEC     R1
   \   000030   EA           MOV     A,R2
   \   000031   34FF         ADDC    A,#-0x1
   \   000033   FA           MOV     R2,A
   \   000034   A3           INC     DPTR
   \                     ??osal_revmemcpy_0:
   \   000035   EC           MOV     A,R4
   \   000036   FE           MOV     R6,A
   \   000037   ED           MOV     A,R5
   \   000038   FF           MOV     R7,A
   \   000039   74FF         MOV     A,#-0x1
   \   00003B   2E           ADD     A,R6
   \   00003C   1C           DEC     R4
   \   00003D   74FF         MOV     A,#-0x1
   \   00003F   3F           ADDC    A,R7
   \   000040   FD           MOV     R5,A
   \   000041   EE           MOV     A,R6
   \   000042   7001         JNZ     ??osal_revmemcpy_2
   \   000044   EF           MOV     A,R7
   \                     ??osal_revmemcpy_2:
   \   000045   70E1         JNZ     ??osal_revmemcpy_1
    144          
    145            return ( pDst );
   \   000047   AA82         MOV     R2,DPL
   \   000049   AB83         MOV     R3,DPH
   \   00004B   80..         SJMP    ??Subroutine28_0
    146          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine28_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    147          
    148          /*********************************************************************
    149           * @fn      osal_memdup
    150           * @brief   Allocates a buffer [with osal_mem_alloc()] and copies
    151           *          the src buffer into the newly allocated space.
    152           * @param   src - source address
    153           *          len - number of bytes to copy
    154           * @return  pointer to the new allocated buffer, or NULL if
    155           *          allocation problem.
    156           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    157          void *osal_memdup( const void GENERIC *src, unsigned int len )
   \                     osal_memdup:
    158          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 4,R1
   \   000007   8A..         MOV     ?V0 + 5,R2
   \   000009   8B..         MOV     ?V0 + 6,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
    159            uint8 *pDst;
    160            
    161            pDst = osal_mem_alloc( len );
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   EE           MOV     A,R6
   \   000010   FA           MOV     R2,A
   \   000011   EF           MOV     A,R7
   \   000012   FB           MOV     R3,A
   \   000013   12....       LCALL   ??osal_mem_alloc?relay
   \   000016   8A..         MOV     ?V0 + 0,R2
   \   000018   8B..         MOV     ?V0 + 1,R3
    162            if ( pDst )
   \   00001A   EA           MOV     A,R2
   \   00001B   7001         JNZ     ??osal_memdup_0
   \   00001D   EB           MOV     A,R3
   \                     ??osal_memdup_0:
   \   00001E   6011         JZ      ??osal_memdup_1
    163            {
    164              VOID osal_memcpy( pDst, src, len );
   \   000020                ; Setup parameters for call to function osal_memcpy
   \   000020   78..         MOV     R0,#?V0 + 4
   \   000022   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000025   EE           MOV     A,R6
   \   000026   FC           MOV     R4,A
   \   000027   EF           MOV     A,R7
   \   000028   FD           MOV     R5,A
   \   000029   12....       LCALL   ??osal_memcpy?relay
   \   00002C   7403         MOV     A,#0x3
   \   00002E   12....       LCALL   ?DEALLOC_XSTACK8
    165            }
    166          
    167            return ( (void *)pDst );
   \                     ??osal_memdup_1:
   \   000031   AA..         MOV     R2,?V0 + 0
   \   000033   AB..         MOV     R3,?V0 + 1
   \   000035   7F07         MOV     R7,#0x7
   \   000037   02....       LJMP    ?BANKED_LEAVE_XDATA
    168          }
    169          
    170          /*********************************************************************
    171           * @fn      osal_memcmp
    172           * @brief   Generic memory compare.
    173           * @param   src1 - source 1 addrexx
    174           *          src2 - source 2 address
    175           *          len - number of bytes to compare
    176           * @return  TRUE - same, FALSE - different
    177           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    178          uint8 osal_memcmp( const void GENERIC *src1, const void GENERIC *src2, unsigned int len )
   \                     osal_memcmp:
    179          {
   \   000000   74ED         MOV     A,#-0x13
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 0
   \   000005   7413         MOV     A,#0x13
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F5..         MOV     ?V0 + 8,A
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 9,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 10,A
    180            const uint8 GENERIC *pSrc1;
    181            const uint8 GENERIC *pSrc2;
    182          
    183            pSrc1 = src1;
   \   000015   89..         MOV     ?V0 + 0,R1
   \   000017   8A..         MOV     ?V0 + 1,R2
   \   000019   8B..         MOV     ?V0 + 2,R3
    184            pSrc2 = src2;
   \   00001B   85....       MOV     ?V0 + 4,?V0 + 8
   \   00001E   85....       MOV     ?V0 + 5,?V0 + 9
    185          
    186            while ( len-- )
   \                     ??osal_memcmp_0:
   \   000021   EC           MOV     A,R4
   \   000022   F8           MOV     R0,A
   \   000023   ED           MOV     A,R5
   \   000024   F9           MOV     R1,A
   \   000025   74FF         MOV     A,#-0x1
   \   000027   28           ADD     A,R0
   \   000028   1C           DEC     R4
   \   000029   74FF         MOV     A,#-0x1
   \   00002B   39           ADDC    A,R1
   \   00002C   FD           MOV     R5,A
   \   00002D   E8           MOV     A,R0
   \   00002E   7001         JNZ     ??osal_memcmp_1
   \   000030   E9           MOV     A,R1
   \                     ??osal_memcmp_1:
   \   000031   6036         JZ      ??osal_memcmp_2
    187            {
    188              if( *pSrc1++ != *pSrc2++ )
   \   000033   A9..         MOV     R1,?V0 + 0
   \   000035   AA..         MOV     R2,?V0 + 1
   \   000037   AB..         MOV     R3,?V0 + 2
   \   000039   E9           MOV     A,R1
   \   00003A   2401         ADD     A,#0x1
   \   00003C   F5..         MOV     ?V0 + 0,A
   \   00003E   EA           MOV     A,R2
   \   00003F   3400         ADDC    A,#0x0
   \   000041   F5..         MOV     ?V0 + 1,A
   \   000043   85....       MOV     ?V0 + 8,?V0 + 4
   \   000046   85....       MOV     ?V0 + 9,?V0 + 5
   \   000049   E5..         MOV     A,?V0 + 4
   \   00004B   2401         ADD     A,#0x1
   \   00004D   F5..         MOV     ?V0 + 4,A
   \   00004F   E5..         MOV     A,?V0 + 5
   \   000051   3400         ADDC    A,#0x0
   \   000053   F5..         MOV     ?V0 + 5,A
   \   000055   12....       LCALL   ?C_GPTR_LOAD
   \   000058   FE           MOV     R6,A
   \   000059   A9..         MOV     R1,?V0 + 8
   \   00005B   AA..         MOV     R2,?V0 + 9
   \   00005D   AB..         MOV     R3,?V0 + 10
   \   00005F   12....       LCALL   ?C_GPTR_LOAD
   \   000062   6E           XRL     A,R6
   \   000063   60BC         JZ      ??osal_memcmp_0
    189                return FALSE;
   \   000065   7900         MOV     R1,#0x0
   \   000067   8002         SJMP    ??osal_memcmp_3
    190            }
    191            return TRUE;
   \                     ??osal_memcmp_2:
   \   000069   7901         MOV     R1,#0x1
   \                     ??osal_memcmp_3:
   \   00006B   7F0B         MOV     R7,#0xb
   \   00006D   02....       LJMP    ?BANKED_LEAVE_XDATA
    192          }
    193          
    194          
    195          /*********************************************************************
    196           * @fn      osal_memset
    197           * @brief   Set memory buffer to value.
    198           * @param   dest - pointer to buffer
    199           *          value - what to set each uint8 of the message
    200           *          size - how big
    201           * @return  value of next widget, 0 if no widget found
    202           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    203          void *osal_memset( void *dest, uint8 value, int len )
   \                     osal_memset:
    204          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    205            return memset( dest, value, len );
   \   000005                ; Setup parameters for call to function memset
   \   000005   8C..         MOV     ?V0 + 0,R4
   \   000007   8D..         MOV     ?V0 + 1,R5
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00000E   E9           MOV     A,R1
   \   00000F   FC           MOV     R4,A
   \   000010   7D00         MOV     R5,#0x0
   \   000012   12....       LCALL   ??memset?relay
   \   000015   7402         MOV     A,#0x2
   \   000017   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001A   02....       LJMP    ?Subroutine26 & 0xFFFF
    206          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    207          
    208          /*********************************************************************
    209           * @fn      osal_build_uint16
    210           *
    211           * @brief
    212           *
    213           *   Build a uint16 out of 2 bytes (0 then 1).
    214           *
    215           * @param   swapped - 0 then 1
    216           *
    217           * @return  uint16
    218           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   FB           MOV     R3,A
   \   000001                REQUIRE ??Subroutine28_0
   \   000001                ; // Fall through to label ??Subroutine28_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    219          uint16 osal_build_uint16( uint8 *swapped )
   \                     osal_build_uint16:
    220          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    221            return ( BUILD_UINT16( swapped[0], swapped[1] ) );
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FC           MOV     R4,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   EC           MOV     A,R4
   \   00000F   FA           MOV     R2,A
   \   000010   E9           MOV     A,R1
   \   000011   02....       LJMP    ?Subroutine24 & 0xFFFF
    222          }
    223          
    224          /*********************************************************************
    225           * @fn      osal_build_uint32
    226           * @brief   Build a uint32 out of sequential bytes.
    227           * @param   swapped - sequential bytes
    228           *          len - number of bytes in the uint8 array
    229           * @return  uint32
    230           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    231          uint32 osal_build_uint32( uint8 *swapped, uint8 len )
   \                     osal_build_uint32:
    232          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
    233            if ( len == 2 )
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F5..         MOV     ?V0 + 4,A
   \   00000C   75..00       MOV     ?V0 + 5,#0x0
   \   00000F   75..00       MOV     ?V0 + 6,#0x0
   \   000012   75..00       MOV     ?V0 + 7,#0x0
   \   000015   7402         MOV     A,#0x2
   \   000017   69           XRL     A,R1
   \   000018   7019         JNZ     ??osal_build_uint32_0
    234              return ( BUILD_UINT32( swapped[0], swapped[1], 0L, 0L ) );
   \   00001A   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00001D   78..         MOV     R0,#?V0 + 0
   \   00001F   12....       LCALL   ?L_SHL
   \   000022   78..         MOV     R0,#?V0 + 4
   \   000024   79..         MOV     R1,#?V0 + 0
   \   000026   12....       LCALL   ?L_ADD
   \   000029   AA..         MOV     R2,?V0 + 4
   \   00002B   AB..         MOV     R3,?V0 + 5
   \   00002D   AC..         MOV     R4,?V0 + 6
   \   00002F   AD..         MOV     R5,?V0 + 7
   \   000031   8065         SJMP    ??osal_build_uint32_1
    235            else if ( len == 3 )
   \                     ??osal_build_uint32_0:
   \   000033   7403         MOV     A,#0x3
   \   000035   69           XRL     A,R1
   \   000036   7012         JNZ     ??osal_build_uint32_2
    236              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], 0L ) );
   \   000038   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   00003B   12....       LCALL   ?L_SHL
   \   00003E   78..         MOV     R0,#?V0 + 4
   \   000040   79..         MOV     R1,#?V0 + 0
   \   000042   12....       LCALL   ?L_ADD
   \   000045   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000048   80D3         SJMP    ??CrossCallReturnLabel_41
    237            else if ( len == 4 )
   \                     ??osal_build_uint32_2:
   \   00004A   7404         MOV     A,#0x4
   \   00004C   69           XRL     A,R1
   \   00004D   7041         JNZ     ??osal_build_uint32_3
    238              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], swapped[3] ) );
   \   00004F   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000052   12....       LCALL   ?L_SHL
   \   000055   78..         MOV     R0,#?V0 + 4
   \   000057   79..         MOV     R1,#?V0 + 0
   \   000059   12....       LCALL   ?L_ADD
   \   00005C   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00005F   78..         MOV     R0,#?V0 + 0
   \   000061   12....       LCALL   ?L_SHL
   \   000064   78..         MOV     R0,#?V0 + 4
   \   000066   79..         MOV     R1,#?V0 + 0
   \   000068   12....       LCALL   ?L_ADD
   \   00006B   8A82         MOV     DPL,R2
   \   00006D   8B83         MOV     DPH,R3
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   F5..         MOV     ?V0 + 0,A
   \   000075   75..00       MOV     ?V0 + 2,#0x0
   \   000078   7418         MOV     A,#0x18
   \   00007A   78..         MOV     R0,#?V0 + 0
   \   00007C   12....       LCALL   ?L_SHL
   \   00007F   78..         MOV     R0,#?V0 + 4
   \   000081   79..         MOV     R1,#?V0 + 0
   \   000083   12....       LCALL   ?L_ADD
   \   000086   AA..         MOV     R2,?V0 + 4
   \   000088   AB..         MOV     R3,?V0 + 5
   \   00008A   AC..         MOV     R4,?V0 + 6
   \   00008C   AD..         MOV     R5,?V0 + 7
   \   00008E   8008         SJMP    ??osal_build_uint32_1
    239            else
    240              return ( (uint32)swapped[0] );
   \                     ??osal_build_uint32_3:
   \   000090   AA..         MOV     R2,?V0 + 4
   \   000092   7B00         MOV     R3,#0x0
   \   000094   7C00         MOV     R4,#0x0
   \   000096   7D00         MOV     R5,#0x0
   \                     ??osal_build_uint32_1:
   \   000098   7F08         MOV     R7,#0x8
   \   00009A   02....       LJMP    ?BANKED_LEAVE_XDATA
    241          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V0 + 0,A
   \   000009   75..00       MOV     ?V0 + 1,#0x0
   \   00000C   7410         MOV     A,#0x10
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000003   78..         MOV     R0,#?V0 + 0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   F5..         MOV     ?V0 + 0,A
   \   000004   75..00       MOV     ?V0 + 1,#0x0
   \   000007   75..00       MOV     ?V0 + 2,#0x0
   \   00000A   75..00       MOV     ?V0 + 3,#0x0
   \   00000D   7408         MOV     A,#0x8
   \   00000F   22           RET
    242          
    243          #if !defined ( ZBIT ) && !defined ( ZBIT2 ) && !defined (UBIT)
    244          /*********************************************************************
    245           * @fn      _ltoa
    246           * @brief   convert a long unsigned int to a string.
    247           * @param   l - long to convert
    248           *          buf - buffer to convert to
    249           *          radix - 10 dec, 16 hex
    250           * @return  pointer to buffer
    251           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    252          unsigned char * _ltoa(unsigned long l, unsigned char *buf, unsigned char radix)
   \                     _ltoa:
    253          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 8,R2
   \   00000C   8B..         MOV     ?V0 + 9,R3
   \   00000E   8C..         MOV     ?V0 + 10,R4
   \   000010   8D..         MOV     ?V0 + 11,R5
    254          #if defined( __GNUC__ )
    255            return ( (char*)ltoa( l, buf, radix ) );
    256          #else
    257            unsigned char tmp1[10] = "", tmp2[10] = "", tmp3[10] = "";
   \   000012   7402         MOV     A,#0x2
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   AC82         MOV     R4,DPL
   \   000019   AD83         MOV     R5,DPH
   \   00001B   7583..       MOV     DPH,#((`?<Constant "">` >> 8) & 0xff)
   \   00001E   7582..       MOV     DPL,#(`?<Constant "">` & 0xff)
   \   000021   740A         MOV     A,#0xa
   \   000023   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   000026   7583..       MOV     DPH,#((`?<Constant "">_1` >> 8) & 0xff)
   \   000029   7582..       MOV     DPL,#(`?<Constant "">_1` & 0xff)
   \   00002C   740A         MOV     A,#0xa
   \   00002E   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   000031   7583..       MOV     DPH,#((`?<Constant "">_2` >> 8) & 0xff)
   \   000034   7582..       MOV     DPL,#(`?<Constant "">_2` & 0xff)
   \   000037   740A         MOV     A,#0xa
   \   000039   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    258            unsigned short num1, num2, num3;
    259            unsigned char i;
    260          
    261            buf[0] = '\0';
   \   00003C   7438         MOV     A,#0x38
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000044   E4           CLR     A
   \   000045   F0           MOVX    @DPTR,A
    262          
    263            if ( radix == 10 )
   \   000046   85..82       MOV     DPL,?XSP + 0
   \   000049   85..83       MOV     DPH,?XSP + 1
   \   00004C   74..         MOV     A,#(`?<Constant "0">` & 0xff)
   \   00004E   F0           MOVX    @DPTR,A
   \   00004F   A3           INC     DPTR
   \   000050   74..         MOV     A,#((`?<Constant "0">` >> 8) & 0xff)
   \   000052   F0           MOVX    @DPTR,A
   \   000053   740A         MOV     A,#0xa
   \   000055   69           XRL     A,R1
   \   000056   6003         JZ      $+5
   \   000058   02....       LJMP    ??_ltoa_0 & 0xFFFF
    264            {
    265              num1 = l % 10000;
   \   00005B   8A..         MOV     ?V0 + 0,R2
   \   00005D   8B..         MOV     ?V0 + 1,R3
   \   00005F   85....       MOV     ?V0 + 2,?V0 + 10
   \   000062   85....       MOV     ?V0 + 3,?V0 + 11
   \   000065   90....       MOV     DPTR,#__Constant_2710
   \   000068   78..         MOV     R0,#?V0 + 4
   \   00006A   12....       LCALL   ?L_MOV_X
   \   00006D   78..         MOV     R0,#?V0 + 0
   \   00006F   79..         MOV     R1,#?V0 + 4
   \   000071   12....       LCALL   ?UL_DIV_MOD
   \   000074   85....       MOV     ?V0 + 0,?V0 + 4
   \   000077   85....       MOV     ?V0 + 1,?V0 + 5
    266              num2 = (l / 10000) % 10000;
   \   00007A   8A..         MOV     ?V0 + 4,R2
   \   00007C   8B..         MOV     ?V0 + 5,R3
   \   00007E   85....       MOV     ?V0 + 6,?V0 + 10
   \   000081   85....       MOV     ?V0 + 7,?V0 + 11
   \   000084   90....       MOV     DPTR,#__Constant_2710
   \   000087   78..         MOV     R0,#?V0 + 12
   \   000089   12....       LCALL   ?L_MOV_X
   \   00008C   78..         MOV     R0,#?V0 + 4
   \   00008E   79..         MOV     R1,#?V0 + 12
   \   000090   12....       LCALL   ?UL_DIV_MOD
   \   000093   90....       MOV     DPTR,#__Constant_2710
   \   000096   78..         MOV     R0,#?V0 + 12
   \   000098   12....       LCALL   ?L_MOV_X
   \   00009B   78..         MOV     R0,#?V0 + 4
   \   00009D   79..         MOV     R1,#?V0 + 12
   \   00009F   12....       LCALL   ?UL_DIV_MOD
   \   0000A2   AE..         MOV     R6,?V0 + 12
   \   0000A4   AF..         MOV     R7,?V0 + 13
    267              num3 = (unsigned short)(l / 100000000);
   \   0000A6   90....       MOV     DPTR,#__Constant_5f5e100
   \   0000A9   78..         MOV     R0,#?V0 + 4
   \   0000AB   12....       LCALL   ?L_MOV_X
   \   0000AE   78..         MOV     R0,#?V0 + 8
   \   0000B0   79..         MOV     R1,#?V0 + 4
   \   0000B2   12....       LCALL   ?UL_DIV_MOD
   \   0000B5   85....       MOV     ?V0 + 2,?V0 + 8
   \   0000B8   85....       MOV     ?V0 + 3,?V0 + 9
    268          
    269              if (num3) _itoa(num3, tmp3, 10);
   \   0000BB   E5..         MOV     A,?V0 + 2
   \   0000BD   7002         JNZ     ??_ltoa_1
   \   0000BF   E5..         MOV     A,?V0 + 3
   \                     ??_ltoa_1:
   \   0000C1   6012         JZ      ??_ltoa_2
   \   0000C3                ; Setup parameters for call to function _itoa
   \   0000C3   790A         MOV     R1,#0xa
   \   0000C5   7416         MOV     A,#0x16
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   AC82         MOV     R4,DPL
   \   0000CC   AD83         MOV     R5,DPH
   \   0000CE   AA..         MOV     R2,?V0 + 2
   \   0000D0   AB..         MOV     R3,?V0 + 3
   \   0000D2   12....       LCALL   ??_itoa?relay
    270              if (num2) _itoa(num2, tmp2, 10);
   \                     ??_ltoa_2:
   \   0000D5   EE           MOV     A,R6
   \   0000D6   7001         JNZ     ??_ltoa_3
   \   0000D8   EF           MOV     A,R7
   \                     ??_ltoa_3:
   \   0000D9   6012         JZ      ??_ltoa_4
   \   0000DB                ; Setup parameters for call to function _itoa
   \   0000DB   790A         MOV     R1,#0xa
   \   0000DD   740C         MOV     A,#0xc
   \   0000DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E2   AC82         MOV     R4,DPL
   \   0000E4   AD83         MOV     R5,DPH
   \   0000E6   EE           MOV     A,R6
   \   0000E7   FA           MOV     R2,A
   \   0000E8   EF           MOV     A,R7
   \   0000E9   FB           MOV     R3,A
   \   0000EA   12....       LCALL   ??_itoa?relay
    271              if (num1) _itoa(num1, tmp1, 10);
   \                     ??_ltoa_4:
   \   0000ED   E5..         MOV     A,?V0 + 0
   \   0000EF   7002         JNZ     ??_ltoa_5
   \   0000F1   E5..         MOV     A,?V0 + 1
   \                     ??_ltoa_5:
   \   0000F3   6012         JZ      ??_ltoa_6
   \   0000F5                ; Setup parameters for call to function _itoa
   \   0000F5   790A         MOV     R1,#0xa
   \   0000F7   7402         MOV     A,#0x2
   \   0000F9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FC   AC82         MOV     R4,DPL
   \   0000FE   AD83         MOV     R5,DPH
   \   000100   AA..         MOV     R2,?V0 + 0
   \   000102   AB..         MOV     R3,?V0 + 1
   \   000104   12....       LCALL   ??_itoa?relay
    272          
    273              if (num3)
   \                     ??_ltoa_6:
   \   000107   E5..         MOV     A,?V0 + 2
   \   000109   7002         JNZ     ??_ltoa_7
   \   00010B   E5..         MOV     A,?V0 + 3
   \                     ??_ltoa_7:
   \   00010D   6029         JZ      ??_ltoa_8
    274              {
    275                strcpy((char*)buf, (char const*)tmp3);
   \   00010F                ; Setup parameters for call to function strcpy
   \   00010F   7416         MOV     A,#0x16
   \   000111   12....       LCALL   ?XSTACK_DISP0_8
   \   000114   AC82         MOV     R4,DPL
   \   000116   AD83         MOV     R5,DPH
   \   000118   7438         MOV     A,#0x38
   \   00011A   12....       LCALL   ?XSTACK_DISP0_8
   \   00011D   12....       LCALL   ?Subroutine6 & 0xFFFF
    276                for (i = 0; i < 4 - strlen((char const*)tmp2); i++)
   \                     ??CrossCallReturnLabel_16:
   \   000120   8009         SJMP    ??CrossCallReturnLabel_2
    277                  strcat((char*)buf, "0");
   \                     ??_ltoa_9:
   \   000122                ; Setup parameters for call to function strcat
   \   000122   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000125   12....       LCALL   ?XSTACK_DISP0_8
   \   000128   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   00012B   85....       MOV     ?V0 + 6,?V0 + 4
   \   00012E                ; Setup parameters for call to function strlen
   \   00012E   740C         MOV     A,#0xc
   \   000130   12....       LCALL   ?XSTACK_DISP0_8
   \   000133   12....       LCALL   ?Subroutine0 & 0xFFFF
    278              }
   \                     ??CrossCallReturnLabel_0:
   \   000136   40EA         JC      ??_ltoa_9
    279              strcat((char*)buf, (char const*)tmp2);
   \                     ??_ltoa_8:
   \   000138                ; Setup parameters for call to function strcat
   \   000138   740C         MOV     A,#0xc
   \   00013A   12....       LCALL   ?XSTACK_DISP0_8
   \   00013D   AC82         MOV     R4,DPL
   \   00013F   AD83         MOV     R5,DPH
   \   000141   7438         MOV     A,#0x38
   \   000143   12....       LCALL   ?XSTACK_DISP0_8
   \   000146   12....       LCALL   ?Subroutine8 & 0xFFFF
    280              if (num3 || num2)
   \                     ??CrossCallReturnLabel_20:
   \   000149   7002         JNZ     ??_ltoa_10
   \   00014B   E5..         MOV     A,?V0 + 3
   \                     ??_ltoa_10:
   \   00014D   7006         JNZ     ??_ltoa_11
   \   00014F   EE           MOV     A,R6
   \   000150   7001         JNZ     ??_ltoa_12
   \   000152   EF           MOV     A,R7
   \                     ??_ltoa_12:
   \   000153   601B         JZ      ??_ltoa_13
    281              {
    282                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
   \                     ??_ltoa_11:
   \   000155   75..00       MOV     ?V0 + 4,#0x0
   \   000158   8009         SJMP    ??CrossCallReturnLabel_3
    283                  strcat((char*)buf, "0");
   \                     ??_ltoa_14:
   \   00015A                ; Setup parameters for call to function strcat
   \   00015A   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   00015D   12....       LCALL   ?XSTACK_DISP0_8
   \   000160   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000163   85....       MOV     ?V0 + 6,?V0 + 4
   \   000166                ; Setup parameters for call to function strlen
   \   000166   7402         MOV     A,#0x2
   \   000168   12....       LCALL   ?XSTACK_DISP0_8
   \   00016B   12....       LCALL   ?Subroutine0 & 0xFFFF
    284              }
   \                     ??CrossCallReturnLabel_1:
   \   00016E   40EA         JC      ??_ltoa_14
    285              strcat((char*)buf, (char const*)tmp1);
   \                     ??_ltoa_13:
   \   000170                ; Setup parameters for call to function strcat
   \   000170   7402         MOV     A,#0x2
   \   000172   12....       LCALL   ?XSTACK_DISP0_8
   \   000175   AC82         MOV     R4,DPL
   \   000177   AD83         MOV     R5,DPH
   \   000179   7438         MOV     A,#0x38
   \   00017B   12....       LCALL   ?XSTACK_DISP0_8
   \   00017E   12....       LCALL   ?Subroutine8 & 0xFFFF
    286              if (!num3 && !num2 && !num1)
   \                     ??CrossCallReturnLabel_21:
   \   000181   7002         JNZ     ??_ltoa_15
   \   000183   E5..         MOV     A,?V0 + 3
   \                     ??_ltoa_15:
   \   000185   701A         JNZ     ??_ltoa_16
   \   000187   EE           MOV     A,R6
   \   000188   7001         JNZ     ??_ltoa_17
   \   00018A   EF           MOV     A,R7
   \                     ??_ltoa_17:
   \   00018B   7014         JNZ     ??_ltoa_16
   \                     ??_ltoa_18:
   \   00018D   E5..         MOV     A,?V0 + 0
   \   00018F   7002         JNZ     ??_ltoa_19
   \   000191   E5..         MOV     A,?V0 + 1
   \                     ??_ltoa_19:
   \   000193   700C         JNZ     ??_ltoa_16
    287                strcpy((char*)buf, "0");
   \   000195                ; Setup parameters for call to function strcpy
   \   000195   12....       LCALL   ?Subroutine3 & 0xFFFF
    288            }
   \                     ??CrossCallReturnLabel_9:
   \   000198   12....       LCALL   ?XSTACK_DISP0_8
   \   00019B   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00019E   12....       LCALL   ??strcpy?relay
    289            else if ( radix == 16 )
    290            {
    291              num1 = l & 0x0000FFFF;
    292              num2 = l >> 16;
    293          
    294              if (num2) _itoa(num2, tmp2, 16);
    295              if (num1) _itoa(num1, tmp1, 16);
    296          
    297              if (num2)
    298              {
    299                strcpy((char*)buf,(char const*)tmp2);
    300                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
    301                  strcat((char*)buf, "0");
    302              }
    303              strcat((char*)buf, (char const*)tmp1);
    304              if (!num2 && !num1)
    305                strcpy((char*)buf, "0");
    306            }
    307            else
    308              return NULL;
    309          
    310            return buf;
   \                     ??_ltoa_16:
   \   0001A1   7438         MOV     A,#0x38
   \   0001A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A6   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   0001A9   7420         MOV     A,#0x20
   \   0001AB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001AE   7F10         MOV     R7,#0x10
   \   0001B0   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??_ltoa_0:
   \   0001B3   7410         MOV     A,#0x10
   \   0001B5   69           XRL     A,R1
   \   0001B6   6003         JZ      $+5
   \   0001B8   02....       LJMP    ??_ltoa_20 & 0xFFFF
   \   0001BB   8A..         MOV     ?V0 + 0,R2
   \   0001BD   8B..         MOV     ?V0 + 1,R3
   \   0001BF   7410         MOV     A,#0x10
   \   0001C1   78..         MOV     R0,#?V0 + 8
   \   0001C3   12....       LCALL   ?UL_SHR
   \   0001C6   AE..         MOV     R6,?V0 + 8
   \   0001C8   AF..         MOV     R7,?V0 + 9
   \   0001CA   EE           MOV     A,R6
   \   0001CB   7001         JNZ     ??_ltoa_21
   \   0001CD   EF           MOV     A,R7
   \                     ??_ltoa_21:
   \   0001CE   6012         JZ      ??_ltoa_22
   \   0001D0                ; Setup parameters for call to function _itoa
   \   0001D0   7910         MOV     R1,#0x10
   \   0001D2   740C         MOV     A,#0xc
   \   0001D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D7   AC82         MOV     R4,DPL
   \   0001D9   AD83         MOV     R5,DPH
   \   0001DB   EE           MOV     A,R6
   \   0001DC   FA           MOV     R2,A
   \   0001DD   EF           MOV     A,R7
   \   0001DE   FB           MOV     R3,A
   \   0001DF   12....       LCALL   ??_itoa?relay
   \                     ??_ltoa_22:
   \   0001E2   E5..         MOV     A,?V0 + 0
   \   0001E4   7002         JNZ     ??_ltoa_23
   \   0001E6   E5..         MOV     A,?V0 + 1
   \                     ??_ltoa_23:
   \   0001E8   6012         JZ      ??_ltoa_24
   \   0001EA                ; Setup parameters for call to function _itoa
   \   0001EA   7910         MOV     R1,#0x10
   \   0001EC   7402         MOV     A,#0x2
   \   0001EE   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F1   AC82         MOV     R4,DPL
   \   0001F3   AD83         MOV     R5,DPH
   \   0001F5   AA..         MOV     R2,?V0 + 0
   \   0001F7   AB..         MOV     R3,?V0 + 1
   \   0001F9   12....       LCALL   ??_itoa?relay
   \                     ??_ltoa_24:
   \   0001FC   EE           MOV     A,R6
   \   0001FD   7001         JNZ     ??_ltoa_25
   \   0001FF   EF           MOV     A,R7
   \                     ??_ltoa_25:
   \   000200   6041         JZ      ??_ltoa_26
   \   000202                ; Setup parameters for call to function strcpy
   \   000202   740C         MOV     A,#0xc
   \   000204   12....       LCALL   ?XSTACK_DISP0_8
   \   000207   AC82         MOV     R4,DPL
   \   000209   AD83         MOV     R5,DPH
   \   00020B   7438         MOV     A,#0x38
   \   00020D   12....       LCALL   ?XSTACK_DISP0_8
   \   000210   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000213   8009         SJMP    ??CrossCallReturnLabel_4
   \                     ??_ltoa_27:
   \   000215                ; Setup parameters for call to function strcat
   \   000215   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000218   12....       LCALL   ?XSTACK_DISP0_8
   \   00021B   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00021E   85....       MOV     ?V0 + 2,?V0 + 4
   \   000221                ; Setup parameters for call to function strlen
   \   000221   7402         MOV     A,#0x2
   \   000223   12....       LCALL   ?XSTACK_DISP0_8
   \   000226   AA82         MOV     R2,DPL
   \   000228   AB83         MOV     R3,DPH
   \   00022A   12....       LCALL   ??strlen?relay
   \   00022D   8A..         MOV     ?V0 + 6,R2
   \   00022F   8B..         MOV     ?V0 + 7,R3
   \   000231   7404         MOV     A,#0x4
   \   000233   C3           CLR     C
   \   000234   95..         SUBB    A,?V0 + 6
   \   000236   F8           MOV     R0,A
   \   000237   E4           CLR     A
   \   000238   95..         SUBB    A,?V0 + 7
   \   00023A   F9           MOV     R1,A
   \   00023B   C3           CLR     C
   \   00023C   E5..         MOV     A,?V0 + 2
   \   00023E   98           SUBB    A,R0
   \   00023F   E4           CLR     A
   \   000240   99           SUBB    A,R1
   \   000241   40D2         JC      ??_ltoa_27
   \                     ??_ltoa_26:
   \   000243                ; Setup parameters for call to function strcat
   \   000243   7402         MOV     A,#0x2
   \   000245   12....       LCALL   ?XSTACK_DISP0_8
   \   000248   AC82         MOV     R4,DPL
   \   00024A   AD83         MOV     R5,DPH
   \   00024C   7438         MOV     A,#0x38
   \   00024E   12....       LCALL   ?XSTACK_DISP0_8
   \   000251   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000254   12....       LCALL   ??strcat?relay
   \   000257   EE           MOV     A,R6
   \   000258   7001         JNZ     ??_ltoa_28
   \   00025A   EF           MOV     A,R7
   \                     ??_ltoa_28:
   \   00025B   6003         JZ      $+5
   \   00025D   02....       LJMP    ??_ltoa_16 & 0xFFFF
   \   000260   02....       LJMP    ??_ltoa_18 & 0xFFFF
   \                     ??_ltoa_20:
   \   000263   7A00         MOV     R2,#0x0
   \   000265   7B00         MOV     R3,#0x0
   \   000267   02....       LJMP    ??CrossCallReturnLabel_24 & 0xFFFF
    311          #endif
    312          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000003   E5..         MOV     A,?V0 + 2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   12....       LCALL   ??strcpy?relay
   \   000008   75..00       MOV     ?V0 + 4,#0x0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FC           MOV     R4,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FD           MOV     R5,A
   \   00000B   7438         MOV     A,#0x38
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000003   05..         INC     ?V0 + 4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   12....       LCALL   ??strcat?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004   12....       LCALL   ??strlen?relay
   \   000007   8A..         MOV     ?V0 + 8,R2
   \   000009   8B..         MOV     ?V0 + 9,R3
   \   00000B   7404         MOV     A,#0x4
   \   00000D   C3           CLR     C
   \   00000E   95..         SUBB    A,?V0 + 8
   \   000010   F8           MOV     R0,A
   \   000011   E4           CLR     A
   \   000012   95..         SUBB    A,?V0 + 9
   \   000014   F9           MOV     R1,A
   \   000015   C3           CLR     C
   \   000016   E5..         MOV     A,?V0 + 6
   \   000018   98           SUBB    A,R0
   \   000019   E4           CLR     A
   \   00001A   99           SUBB    A,R1
   \   00001B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
    313          #endif // !defined(ZBIT) && !defined(ZBIT2)
    314          
    315          /*********************************************************************
    316           * @fn        osal_rand
    317           * @brief     Random number generator
    318           * @param     none
    319           * @return    uint16 - new random number
    320           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    321          uint16 osal_rand( void )
   \                     osal_rand:
    322          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    323            return ( Onboard_rand() );
   \   000004                ; Setup parameters for call to function Onboard_rand
   \   000004   12....       LCALL   ??Onboard_rand?relay
   \   000007   80..         SJMP    ?Subroutine22
    324          }
    325          
    326          /*********************************************************************
    327           * API FUNCTIONS
    328           *********************************************************************/
    329          
    330          /*********************************************************************
    331           * @fn      osal_msg_allocate
    332           *
    333           * @brief   This function is called by a task to allocate a message buffer
    334           *          into which the task will encode the particular message it wishes
    335           *          to send.  This common buffer scheme is used to strictly limit the
    336           *          creation of message buffers within the system due to RAM size
    337           *          limitations on the microprocessor.   Note that all message buffers
    338           *          are a fixed size (at least initially).  The parameter len is kept
    339           *          in case a message pool with varying fixed message sizes is later
    340           *          created (for example, a pool of message buffers of size LARGE,
    341           *          MEDIUM and SMALL could be maintained and allocated based on request
    342           *          from the tasks).
    343           * @param   uint8 len  - wanted buffer length
    344           * @return  pointer to allocated buffer or NULL if allocation failed.
    345           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    346          uint8 * osal_msg_allocate( uint16 len )
   \                     osal_msg_allocate:
    347          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    348            osal_msg_hdr_t *hdr;
    349          
    350            if ( len == 0 )
   \   000009   EE           MOV     A,R6
   \   00000A   7001         JNZ     ??osal_msg_allocate_0
   \   00000C   EF           MOV     A,R7
   \                     ??osal_msg_allocate_0:
   \   00000D   7006         JNZ     ??osal_msg_allocate_1
    351              return ( NULL );
   \                     ??osal_msg_allocate_2:
   \   00000F   7A00         MOV     R2,#0x0
   \   000011   7B00         MOV     R3,#0x0
   \   000013   803E         SJMP    ??osal_msg_allocate_3
    352          
    353            hdr = (osal_msg_hdr_t *) osal_mem_alloc( (short)(len + sizeof( osal_msg_hdr_t )) );
   \                     ??osal_msg_allocate_1:
   \   000015                ; Setup parameters for call to function osal_mem_alloc
   \   000015   7405         MOV     A,#0x5
   \   000017   2E           ADD     A,R6
   \   000018   FA           MOV     R2,A
   \   000019   E4           CLR     A
   \   00001A   3F           ADDC    A,R7
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   ??osal_mem_alloc?relay
   \   00001F   8A..         MOV     ?V0 + 0,R2
   \   000021   8B..         MOV     ?V0 + 1,R3
   \   000023   A8..         MOV     R0,?V0 + 0
   \   000025   A9..         MOV     R1,?V0 + 1
    354            if ( hdr )
   \   000027   E8           MOV     A,R0
   \   000028   7001         JNZ     ??osal_msg_allocate_4
   \   00002A   E9           MOV     A,R1
   \                     ??osal_msg_allocate_4:
   \   00002B   60E2         JZ      ??osal_msg_allocate_2
    355            {
    356              hdr->next = NULL;
   \   00002D   8882         MOV     DPL,R0
   \   00002F   8983         MOV     DPH,R1
   \   000031   E4           CLR     A
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   F0           MOVX    @DPTR,A
    357              hdr->len = len;
   \   000035   8882         MOV     DPL,R0
   \   000037   8983         MOV     DPH,R1
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   EE           MOV     A,R6
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   A3           INC     DPTR
   \   00003E   EF           MOV     A,R7
   \   00003F   F0           MOVX    @DPTR,A
    358              hdr->dest_id = TASK_NO_TASK;
   \   000040   74FF         MOV     A,#-0x1
   \   000042   8882         MOV     DPL,R0
   \   000044   8983         MOV     DPH,R1
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   F0           MOVX    @DPTR,A
    359              return ( (uint8 *) (hdr + 1) );
   \   00004B   E8           MOV     A,R0
   \   00004C   2405         ADD     A,#0x5
   \   00004E   FA           MOV     R2,A
   \   00004F   E9           MOV     A,R1
   \   000050   3400         ADDC    A,#0x0
   \   000052   FB           MOV     R3,A
    360            }
   \                     ??osal_msg_allocate_3:
   \   000053   02....       LJMP    ?Subroutine26 & 0xFFFF
    361            else
    362              return ( NULL );
    363          }
    364          
    365          /*********************************************************************
    366           * @fn      osal_msg_deallocate
    367           * @brief   This function is used to deallocate a message buffer. This function
    368           *          is called by a task (or processing element) after it has finished
    369           *          processing a received message.
    370           * @param   uint8 *msg_ptr - pointer to new message buffer
    371           * @return  SUCCESS, INVALID_MSG_POINTER
    372           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    373          uint8 osal_msg_deallocate( uint8 *msg_ptr )
   \                     osal_msg_deallocate:
    374          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    375            uint8 *x;
    376          
    377            if ( msg_ptr == NULL )
   \   000004   EA           MOV     A,R2
   \   000005   7001         JNZ     ??osal_msg_deallocate_0
   \   000007   EB           MOV     A,R3
   \                     ??osal_msg_deallocate_0:
   \   000008   7004         JNZ     ??osal_msg_deallocate_1
    378              return ( INVALID_MSG_POINTER );
   \   00000A   7905         MOV     R1,#0x5
   \   00000C   8016         SJMP    ??osal_msg_deallocate_2
    379          
    380            // don't deallocate queued buffer
    381            if ( OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_deallocate_1:
   \   00000E   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000011   6004         JZ      ??osal_msg_deallocate_3
    382              return ( MSG_BUFFER_NOT_AVAIL );
   \   000013   7904         MOV     R1,#0x4
   \   000015   800D         SJMP    ??osal_msg_deallocate_2
    383          
    384            x = (uint8 *)((uint8 *)msg_ptr - sizeof( osal_msg_hdr_t ));
    385          
    386            osal_mem_free( (void *)x );
   \                     ??osal_msg_deallocate_3:
   \   000017                ; Setup parameters for call to function osal_mem_free
   \   000017   EA           MOV     A,R2
   \   000018   24FB         ADD     A,#-0x5
   \   00001A   FA           MOV     R2,A
   \   00001B   EB           MOV     A,R3
   \   00001C   34FF         ADDC    A,#-0x1
   \   00001E   FB           MOV     R3,A
   \   00001F   12....       LCALL   ??osal_mem_free?relay
    387          
    388            return ( SUCCESS );
   \   000022   7900         MOV     R1,#0x0
   \                     ??osal_msg_deallocate_2:
   \   000024                REQUIRE ?Subroutine22
   \   000024                ; // Fall through to label ?Subroutine22
    389          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   EA           MOV     A,R2
   \   000001   24FF         ADD     A,#-0x1
   \   000003   F582         MOV     DPL,A
   \   000005   EB           MOV     A,R3
   \   000006   34FF         ADDC    A,#-0x1
   \   000008   F583         MOV     DPH,A
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   64FF         XRL     A,#0xff
   \   00000D   22           RET
    390          
    391          /*********************************************************************
    392           * @fn      osal_msg_send
    393           * @brief   This function is called by a task to send a command message to
    394           *          another task or processing element.  The sending_task field must
    395           *          refer to a valid task, since the task ID will be used
    396           *          for the response message.  This function will also set a message
    397           *          ready event in the destination tasks event list.
    398           * @param   uint8 destination task - Send msg to?  Task ID
    399           *          uint8 *msg_ptr - pointer to new message buffer
    400           *          uint8 len - length of data in message
    401           * @return  SUCCESS, INVALID_TASK, INVALID_MSG_POINTER
    402           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    403          uint8 osal_msg_send( uint8 destination_task, uint8 *msg_ptr )
   \                     osal_msg_send:
    404          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    405            if ( msg_ptr == NULL )
   \   000007   EA           MOV     A,R2
   \   000008   7001         JNZ     ??osal_msg_send_0
   \   00000A   EB           MOV     A,R3
   \                     ??osal_msg_send_0:
   \   00000B   7004         JNZ     ??osal_msg_send_1
    406              return ( INVALID_MSG_POINTER );
   \                     ??osal_msg_send_2:
   \   00000D   7905         MOV     R1,#0x5
   \   00000F   8043         SJMP    ??osal_msg_send_3
    407          
    408            if ( destination_task >= tasksCnt )
   \                     ??osal_msg_send_1:
   \   000011   90....       MOV     DPTR,#tasksCnt
   \   000014   E0           MOVX    A,@DPTR
   \   000015   FC           MOV     R4,A
   \   000016   E9           MOV     A,R1
   \   000017   C3           CLR     C
   \   000018   9C           SUBB    A,R4
   \   000019   4007         JC      ??osal_msg_send_4
    409            {
    410              osal_msg_deallocate( msg_ptr );
   \   00001B                ; Setup parameters for call to function osal_msg_deallocate
   \   00001B   12....       LCALL   ??osal_msg_deallocate?relay
    411              return ( INVALID_TASK );
   \   00001E   7903         MOV     R1,#0x3
   \   000020   8032         SJMP    ??osal_msg_send_3
    412            }
    413          
    414            // Check the message header
    415            if ( OSAL_MSG_NEXT( msg_ptr ) != NULL ||
    416                 OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_send_4:
   \   000022   EA           MOV     A,R2
   \   000023   24FB         ADD     A,#-0x5
   \   000025   F582         MOV     DPL,A
   \   000027   EB           MOV     A,R3
   \   000028   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   7002         JNZ     ??osal_msg_send_5
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \                     ??osal_msg_send_5:
   \   000030   7005         JNZ     ??osal_msg_send_6
   \   000032   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000035   6005         JZ      ??osal_msg_send_7
    417            {
    418              osal_msg_deallocate( msg_ptr );
   \                     ??osal_msg_send_6:
   \   000037                ; Setup parameters for call to function osal_msg_deallocate
   \   000037   12....       LCALL   ??osal_msg_deallocate?relay
    419              return ( INVALID_MSG_POINTER );
   \   00003A   80D1         SJMP    ??osal_msg_send_2
    420            }
    421          
    422            OSAL_MSG_ID( msg_ptr ) = destination_task;
   \                     ??osal_msg_send_7:
   \   00003C   EE           MOV     A,R6
   \   00003D   F0           MOVX    @DPTR,A
    423          
    424            // queue message
    425            osal_msg_enqueue( &osal_qHead, msg_ptr );
   \   00003E                ; Setup parameters for call to function osal_msg_enqueue
   \   00003E   EA           MOV     A,R2
   \   00003F   FC           MOV     R4,A
   \   000040   EB           MOV     A,R3
   \   000041   FD           MOV     R5,A
   \   000042   7A..         MOV     R2,#(osal_qHead & 0xff)
   \   000044   7B..         MOV     R3,#((osal_qHead >> 8) & 0xff)
   \   000046   12....       LCALL   ??osal_msg_enqueue?relay
    426          
    427            // Signal the task that a message is waiting
    428            osal_set_event( destination_task, SYS_EVENT_MSG );
   \   000049                ; Setup parameters for call to function osal_set_event
   \   000049   7A00         MOV     R2,#0x0
   \   00004B   7B80         MOV     R3,#-0x80
   \   00004D   EE           MOV     A,R6
   \   00004E   F9           MOV     R1,A
   \   00004F   12....       LCALL   ??osal_set_event?relay
    429          
    430            return ( SUCCESS );
   \   000052   7900         MOV     R1,#0x0
   \                     ??osal_msg_send_3:
   \   000054   02....       LJMP    ??Subroutine28_0 & 0xFFFF
    431          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine32_0:
   \   000000   34FF         ADDC    A,#-0x1
   \   000002   F583         MOV     DPH,A
   \   000004   22           RET
    432          
    433          /*********************************************************************
    434           * @fn      osal_msg_receive
    435           * @brief   This function is called by a task to retrieve a received command
    436           *          message. The calling task must deallocate the message buffer after
    437           *          processing the message using the osal_msg_deallocate() call.
    438           * @param   uint8 task_id - receiving tasks ID
    439           * @return  *uint8 - message information or NULL if no message
    440           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    441          uint8 *osal_msg_receive( uint8 task_id )
   \                     osal_msg_receive:
    442          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
    443            osal_msg_hdr_t *listHdr;
    444            osal_msg_hdr_t *prevHdr = NULL;
   \   000005   75..00       MOV     ?V0 + 4,#0x0
   \   000008   75..00       MOV     ?V0 + 5,#0x0
    445            osal_msg_hdr_t *foundHdr = NULL;
   \   00000B   7E00         MOV     R6,#0x0
   \   00000D   7F00         MOV     R7,#0x0
    446            halIntState_t   intState;
    447          
    448            // Hold off interrupts
    449            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000F   A2AF         MOV     C,0xa8.7
   \   000011   E4           CLR     A
   \   000012   92E0         MOV     0xE0 /* A   */.0,C
   \   000014   F5..         MOV     ?V0 + 2,A
   \   000016   C2AF         CLR     0xa8.7
    450          
    451            // Point to the top of the queue
    452            listHdr = osal_qHead;
   \   000018   90....       MOV     DPTR,#osal_qHead
   \   00001B   8017         SJMP    ??CrossCallReturnLabel_54
    453          
    454            // Look through the queue for a message that belongs to the asking task
    455            while ( listHdr != NULL )
    456            {
    457              if ( (listHdr - 1)->dest_id == task_id )
    458              {
    459                if ( foundHdr == NULL )
    460                {
    461                  // Save the first one
    462                  foundHdr = listHdr;
    463                }
    464                else
    465                {
    466                  // Second msg found, stop looking
    467                  break;
    468                }
    469              }
    470              if ( foundHdr == NULL )
   \                     ??osal_msg_receive_0:
   \   00001D   EE           MOV     A,R6
   \   00001E   7001         JNZ     ??osal_msg_receive_1
   \   000020   EF           MOV     A,R7
   \                     ??osal_msg_receive_1:
   \   000021   7006         JNZ     ??osal_msg_receive_2
    471              {
    472                prevHdr = listHdr;
   \   000023   85....       MOV     ?V0 + 4,?V0 + 0
   \   000026   85....       MOV     ?V0 + 5,?V0 + 1
    473              }
    474              listHdr = OSAL_MSG_NEXT( listHdr );
   \                     ??osal_msg_receive_2:
   \   000029   E5..         MOV     A,?V0 + 0
   \   00002B   24FB         ADD     A,#-0x5
   \   00002D   F582         MOV     DPL,A
   \   00002F   E5..         MOV     A,?V0 + 1
   \   000031   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000034   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000037   E5..         MOV     A,?V0 + 0
   \   000039   7002         JNZ     ??osal_msg_receive_3
   \   00003B   E5..         MOV     A,?V0 + 1
   \                     ??osal_msg_receive_3:
   \   00003D   6024         JZ      ??osal_msg_receive_4
   \   00003F   E5..         MOV     A,?V0 + 0
   \   000041   24FF         ADD     A,#-0x1
   \   000043   F582         MOV     DPL,A
   \   000045   E5..         MOV     A,?V0 + 1
   \   000047   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   69           XRL     A,R1
   \   00004C   70CF         JNZ     ??osal_msg_receive_0
   \   00004E   EE           MOV     A,R6
   \   00004F   7001         JNZ     ??osal_msg_receive_5
   \   000051   EF           MOV     A,R7
   \                     ??osal_msg_receive_5:
   \   000052   7006         JNZ     ??osal_msg_receive_6
   \   000054   AE..         MOV     R6,?V0 + 0
   \   000056   AF..         MOV     R7,?V0 + 1
   \   000058   80CF         SJMP    ??osal_msg_receive_2
    475            }
    476            
    477            // Is there more than one?
    478            if ( listHdr != NULL )
    479            {
    480              // Yes, Signal the task that a message is waiting
    481              osal_set_event( task_id, SYS_EVENT_MSG );
   \                     ??osal_msg_receive_6:
   \   00005A                ; Setup parameters for call to function osal_set_event
   \   00005A   7A00         MOV     R2,#0x0
   \   00005C   7B80         MOV     R3,#-0x80
   \   00005E   12....       LCALL   ??osal_set_event?relay
   \   000061   800D         SJMP    ??osal_msg_receive_7
    482            }
    483            else
    484            {
    485              // No more
    486              osal_clear_event( task_id, SYS_EVENT_MSG );
   \                     ??osal_msg_receive_4:
   \   000063                ; Setup parameters for call to function osal_clear_event
   \   000063   7A00         MOV     R2,#0x0
   \   000065   7B80         MOV     R3,#-0x80
   \   000067   12....       LCALL   ??osal_clear_event?relay
    487            }
    488          
    489            // Did we find a message?
    490            if ( foundHdr != NULL )
   \   00006A   EE           MOV     A,R6
   \   00006B   7001         JNZ     ??osal_msg_receive_8
   \   00006D   EF           MOV     A,R7
   \                     ??osal_msg_receive_8:
   \   00006E   6015         JZ      ??osal_msg_receive_9
    491            {
    492              // Take out of the link list
    493              osal_msg_extract( &osal_qHead, foundHdr, prevHdr );
   \                     ??osal_msg_receive_7:
   \   000070                ; Setup parameters for call to function osal_msg_extract
   \   000070   78..         MOV     R0,#?V0 + 4
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000075   EE           MOV     A,R6
   \   000076   FC           MOV     R4,A
   \   000077   EF           MOV     A,R7
   \   000078   FD           MOV     R5,A
   \   000079   7A..         MOV     R2,#(osal_qHead & 0xff)
   \   00007B   7B..         MOV     R3,#((osal_qHead >> 8) & 0xff)
   \   00007D   12....       LCALL   ??osal_msg_extract?relay
   \   000080   7402         MOV     A,#0x2
   \   000082   12....       LCALL   ?DEALLOC_XSTACK8
    494            }
    495          
    496            // Release interrupts
    497            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_receive_9:
   \   000085   E5..         MOV     A,?V0 + 2
   \   000087   A2E0         MOV     C,0xE0 /* A   */.0
   \   000089   92AF         MOV     0xa8.7,C
    498          
    499            return ( (uint8*) foundHdr );
   \   00008B   EE           MOV     A,R6
   \   00008C   FA           MOV     R2,A
   \   00008D   EF           MOV     A,R7
   \   00008E   FB           MOV     R3,A
   \   00008F   7F06         MOV     R7,#0x6
   \   000091   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000094                REQUIRE _A_IEN0
    500          }
    501          
    502          /**************************************************************************************************
    503           * @fn          osal_msg_find
    504           * @brief       This function finds in place an OSAL message matching the task_id and event
    505           *              parameters.
    506           * input parameters
    507           * @param       task_id - The OSAL task id that the enqueued OSAL message must match.
    508           *              event - The OSAL event id that the enqueued OSAL message must match.
    509           * output parameters
    510           * None.
    511           * @return      NULL if no match, otherwise an in place pointer to the matching OSAL message.
    512           **************************************************************************************************
    513           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    514          osal_event_hdr_t *osal_msg_find(uint8 task_id, uint8 event)
   \                     osal_msg_find:
    515          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    516            osal_msg_hdr_t *pHdr;
    517            halIntState_t intState;
    518          
    519            HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   92E0         MOV     0xE0 /* A   */.0,C
   \   00000A   FB           MOV     R3,A
   \   00000B   C2AF         CLR     0xa8.7
    520          
    521            pHdr = osal_qHead;  // Point to the top of the queue.
   \   00000D   90....       MOV     DPTR,#osal_qHead
   \   000010   8003         SJMP    ??CrossCallReturnLabel_60
    522          
    523            // Look through the queue for a message that matches the task_id and event parameters.
    524            while (pHdr != NULL)
    525            {
    526              if (((pHdr-1)->dest_id == task_id) && (((osal_event_hdr_t *)pHdr)->event == event))
    527              {
    528                break;
    529              }
    530          
    531              pHdr = OSAL_MSG_NEXT(pHdr);
   \                     ??osal_msg_find_0:
   \   000012   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FC           MOV     R4,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FD           MOV     R5,A
   \   00001A   EC           MOV     A,R4
   \   00001B   7001         JNZ     ??osal_msg_find_1
   \   00001D   ED           MOV     A,R5
   \                     ??osal_msg_find_1:
   \   00001E   6012         JZ      ??osal_msg_find_2
   \   000020   EC           MOV     A,R4
   \   000021   24FF         ADD     A,#-0x1
   \   000023   12....       LCALL   ??Subroutine31_0 & 0xFFFF
    532            }
   \                     ??CrossCallReturnLabel_58:
   \   000026   E0           MOVX    A,@DPTR
   \   000027   69           XRL     A,R1
   \   000028   70E8         JNZ     ??osal_msg_find_0
   \   00002A   8C82         MOV     DPL,R4
   \   00002C   8D83         MOV     DPH,R5
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   6A           XRL     A,R2
   \   000030   70E0         JNZ     ??osal_msg_find_0
    533            
    534            HAL_EXIT_CRITICAL_SECTION(intState);  // Release interrupts.
   \                     ??osal_msg_find_2:
   \   000032   EB           MOV     A,R3
   \   000033   A2E0         MOV     C,0xE0 /* A   */.0
   \   000035   92AF         MOV     0xa8.7,C
    535          
    536            return (osal_event_hdr_t *)pHdr;
   \   000037   EC           MOV     A,R4
   \   000038   FA           MOV     R2,A
   \   000039   ED           MOV     A,R5
   \   00003A   02....       LJMP    ?Subroutine24 & 0xFFFF
   \   00003D                REQUIRE _A_IEN0
    537          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   EC           MOV     A,R4
   \   000001   24FB         ADD     A,#-0x5
   \   000003                REQUIRE ??Subroutine31_0
   \   000003                ; // Fall through to label ??Subroutine31_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine31_0:
   \   000000   F582         MOV     DPL,A
   \   000002   ED           MOV     A,R5
   \   000003                REQUIRE ??Subroutine32_0
   \   000003                ; // Fall through to label ??Subroutine32_0
    538          
    539          /*********************************************************************
    540           * @fn      osal_msg_enqueue
    541           *
    542           * @brief
    543           *
    544           *    This function enqueues an OSAL message into an OSAL queue.
    545           *
    546           * @param   osal_msg_q_t *q_ptr - OSAL queue
    547           * @param   void *msg_ptr  - OSAL message
    548           *
    549           * @return  none
    550           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    551          void osal_msg_enqueue( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_enqueue:
    552          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    553            void *list;
    554            halIntState_t intState;
    555          
    556            // Hold off interrupts
    557            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   92E0         MOV     0xE0 /* A   */.0,C
   \   00000A   FE           MOV     R6,A
   \   00000B   C2AF         CLR     0xa8.7
    558          
    559            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   00000D   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   F0           MOVX    @DPTR,A
    560            // If first message in queue
    561            if ( *q_ptr == NULL )
   \   000014   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000017   7001         JNZ     ??osal_msg_enqueue_0
   \   000019   E9           MOV     A,R1
   \                     ??osal_msg_enqueue_0:
   \   00001A   7009         JNZ     ??CrossCallReturnLabel_28
    562            {
    563              *q_ptr = msg_ptr;
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \   000020   8010         SJMP    ??osal_msg_enqueue_1
    564            }
    565            else
    566            {
    567              // Find end of queue
    568              for ( list = *q_ptr; OSAL_MSG_NEXT( list ) != NULL; list = OSAL_MSG_NEXT( list ) );
   \                     ??osal_msg_enqueue_2:
   \   000022   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000025   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000028   7002         JNZ     ??osal_msg_enqueue_3
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_3:
   \   00002C   8882         MOV     DPL,R0
   \   00002E   8983         MOV     DPH,R1
   \   000030   70F0         JNZ     ??osal_msg_enqueue_2
    569          
    570              // Add message to end of queue
    571              OSAL_MSG_NEXT( list ) = msg_ptr;
    572            }
   \                     ??osal_msg_enqueue_1:
   \   000032                REQUIRE ?Subroutine25
   \   000032                REQUIRE _A_IEN0
   \   000032                ; // Fall through to label ?Subroutine25
    573          
    574            // Re-enable interrupts
    575            HAL_EXIT_CRITICAL_SECTION(intState);
    576          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000003   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E8           MOV     A,R0
   \   000001   24FB         ADD     A,#-0x5
   \   000003   F8           MOV     R0,A
   \   000004   E9           MOV     A,R1
   \   000005                REQUIRE ??Subroutine29_0
   \   000005                ; // Fall through to label ??Subroutine29_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine29_0:
   \   000000   34FF         ADDC    A,#-0x1
   \   000002   F9           MOV     R1,A
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004                REQUIRE ??Subroutine30_0
   \   000004                ; // Fall through to label ??Subroutine30_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine30_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   EC           MOV     A,R4
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   ED           MOV     A,R5
   \   000004   F0           MOVX    @DPTR,A
   \   000005   EE           MOV     A,R6
   \   000006   A2E0         MOV     C,0xE0 /* A   */.0
   \   000008   92AF         MOV     0xa8.7,C
   \   00000A   7F01         MOV     R7,#0x1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    577          
    578          /*********************************************************************
    579           * @fn      osal_msg_dequeue
    580           *
    581           * @brief
    582           *
    583           *    This function dequeues an OSAL message from an OSAL queue.
    584           *
    585           * @param   osal_msg_q_t *q_ptr - OSAL queue
    586           *
    587           * @return  void * - pointer to OSAL message or NULL of queue is empty.
    588           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    589          void *osal_msg_dequeue( osal_msg_q_t *q_ptr )
   \                     osal_msg_dequeue:
    590          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FC           MOV     R4,A
   \   000007   EB           MOV     A,R3
   \   000008   FD           MOV     R5,A
    591            void *msg_ptr = NULL;
   \   000009   7A00         MOV     R2,#0x0
   \   00000B   7B00         MOV     R3,#0x0
    592            halIntState_t intState;
    593          
    594            // Hold off interrupts
    595            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000D   A2AF         MOV     C,0xa8.7
   \   00000F   E4           CLR     A
   \   000010   92E0         MOV     0xE0 /* A   */.0,C
   \   000012   F5..         MOV     ?V0 + 0,A
   \   000014   C2AF         CLR     0xa8.7
    596          
    597            if ( *q_ptr != NULL )
   \   000016   8C82         MOV     DPL,R4
   \   000018   8D83         MOV     DPH,R5
   \   00001A   12....       LCALL   ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00001D   7001         JNZ     ??osal_msg_dequeue_0
   \   00001F   E9           MOV     A,R1
   \                     ??osal_msg_dequeue_0:
   \   000020   602D         JZ      ??osal_msg_dequeue_1
    598            {
    599              // Dequeue message
    600              msg_ptr = *q_ptr;
   \   000022   E8           MOV     A,R0
   \   000023   FA           MOV     R2,A
   \   000024   E9           MOV     A,R1
   \   000025   FB           MOV     R3,A
    601              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \   000026   EA           MOV     A,R2
   \   000027   24FB         ADD     A,#-0x5
   \   000029   F8           MOV     R0,A
   \   00002A   EB           MOV     A,R3
   \   00002B   12....       LCALL   ??Subroutine29_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   00002E   FE           MOV     R6,A
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   FF           MOV     R7,A
   \   000032   8C82         MOV     DPL,R4
   \   000034   8D83         MOV     DPH,R5
   \   000036   EE           MOV     A,R6
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   EF           MOV     A,R7
   \   00003A   F0           MOVX    @DPTR,A
    602              OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   00003B   8882         MOV     DPL,R0
   \   00003D   8983         MOV     DPH,R1
   \   00003F   E4           CLR     A
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   F0           MOVX    @DPTR,A
    603              OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   000043   EA           MOV     A,R2
   \   000044   24FF         ADD     A,#-0x1
   \   000046   F582         MOV     DPL,A
   \   000048   EB           MOV     A,R3
   \   000049   12....       LCALL   ??Subroutine32_0 & 0xFFFF
    604            }
   \                     ??CrossCallReturnLabel_56:
   \   00004C   74FF         MOV     A,#-0x1
   \   00004E   F0           MOVX    @DPTR,A
    605          
    606            // Re-enable interrupts
    607            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_dequeue_1:
   \   00004F   E5..         MOV     A,?V0 + 0
   \   000051   A2E0         MOV     C,0xE0 /* A   */.0
   \   000053   92AF         MOV     0xa8.7,C
    608          
    609            return msg_ptr;
   \   000055                REQUIRE ?Subroutine26
   \   000055                REQUIRE _A_IEN0
   \   000055                ; // Fall through to label ?Subroutine26
    610          }
    611          
    612          /*********************************************************************
    613           * @fn      osal_msg_push
    614           *
    615           * @brief
    616           *
    617           *    This function pushes an OSAL message to the head of an OSAL
    618           *    queue.
    619           *
    620           * @param   osal_msg_q_t *q_ptr - OSAL queue
    621           * @param   void *msg_ptr  - OSAL message
    622           *
    623           * @return  none
    624           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    625          void osal_msg_push( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_push:
    626          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    627            halIntState_t intState;
    628          
    629            // Hold off interrupts
    630            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   92E0         MOV     0xE0 /* A   */.0,C
   \   00000A   FE           MOV     R6,A
   \   00000B   C2AF         CLR     0xa8.7
    631          
    632            // Push message to head of queue
    633            OSAL_MSG_NEXT( msg_ptr ) = *q_ptr;
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000014   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000017   E8           MOV     A,R0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   E9           MOV     A,R1
   \   00001B   F0           MOVX    @DPTR,A
    634            *q_ptr = msg_ptr;
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \   000020   02....       LJMP    ?Subroutine25 & 0xFFFF
   \   000023                REQUIRE _A_IEN0
    635          
    636            // Re-enable interrupts
    637            HAL_EXIT_CRITICAL_SECTION(intState);
    638          }
    639          
    640          /*********************************************************************
    641           * @fn      osal_msg_extract
    642           *
    643           * @brief
    644           *
    645           *    This function extracts and removes an OSAL message from the
    646           *    middle of an OSAL queue.
    647           *
    648           * @param   osal_msg_q_t *q_ptr - OSAL queue
    649           * @param   void *msg_ptr  - OSAL message to be extracted
    650           * @param   void *prev_ptr  - OSAL message before msg_ptr in queue
    651           *
    652           * @return  none
    653           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    654          void osal_msg_extract( osal_msg_q_t *q_ptr, void *msg_ptr, void *prev_ptr )
   \                     osal_msg_extract:
    655          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   740B         MOV     A,#0xb
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ?Subroutine11 & 0xFFFF
    656            halIntState_t intState;
    657          
    658            // Hold off interrupts
    659            HAL_ENTER_CRITICAL_SECTION(intState);
   \                     ??CrossCallReturnLabel_30:
   \   00000D   A2AF         MOV     C,0xa8.7
   \   00000F   E4           CLR     A
   \   000010   92E0         MOV     0xE0 /* A   */.0,C
   \   000012   F5..         MOV     ?V0 + 2,A
   \   000014   C2AF         CLR     0xa8.7
    660          
    661            if ( msg_ptr == *q_ptr )
   \   000016   EC           MOV     A,R4
   \   000017   24FB         ADD     A,#-0x5
   \   000019   FE           MOV     R6,A
   \   00001A   ED           MOV     A,R5
   \   00001B   34FF         ADDC    A,#-0x1
   \   00001D   FF           MOV     R7,A
   \   00001E   8A82         MOV     DPL,R2
   \   000020   8B83         MOV     DPH,R3
   \   000022   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000025   EC           MOV     A,R4
   \   000026   65..         XRL     A,?V0 + 0
   \   000028   7003         JNZ     ??osal_msg_extract_0
   \   00002A   ED           MOV     A,R5
   \   00002B   65..         XRL     A,?V0 + 1
   \                     ??osal_msg_extract_0:
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   700D         JNZ     ??osal_msg_extract_1
    662            {
    663              // remove from first
    664              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \   000033   12....       LCALL   ?Subroutine11 & 0xFFFF
    665            }
   \                     ??CrossCallReturnLabel_31:
   \   000036   8A82         MOV     DPL,R2
   \   000038   8B83         MOV     DPH,R3
   \   00003A   E8           MOV     A,R0
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   E9           MOV     A,R1
   \   00003E   8010         SJMP    ??osal_msg_extract_2
    666            else
    667            {
    668              // remove from middle
    669              OSAL_MSG_NEXT( prev_ptr ) = OSAL_MSG_NEXT( msg_ptr );
   \                     ??osal_msg_extract_1:
   \   000040   12....       LCALL   ?Subroutine9 & 0xFFFF
    670            }
   \                     ??CrossCallReturnLabel_26:
   \   000043   E8           MOV     A,R0
   \   000044   24FB         ADD     A,#-0x5
   \   000046   F582         MOV     DPL,A
   \   000048   E9           MOV     A,R1
   \   000049   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00004C   EA           MOV     A,R2
   \   00004D   F0           MOVX    @DPTR,A
   \   00004E   A3           INC     DPTR
   \   00004F   EB           MOV     A,R3
   \                     ??osal_msg_extract_2:
   \   000050   F0           MOVX    @DPTR,A
    671            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   000051   8E82         MOV     DPL,R6
   \   000053   8F83         MOV     DPH,R7
   \   000055   E4           CLR     A
   \   000056   F0           MOVX    @DPTR,A
   \   000057   A3           INC     DPTR
   \   000058   F0           MOVX    @DPTR,A
    672            OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   000059   EC           MOV     A,R4
   \   00005A   24FF         ADD     A,#-0x1
   \   00005C   12....       LCALL   ??Subroutine31_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   00005F   74FF         MOV     A,#-0x1
   \   000061   F0           MOVX    @DPTR,A
    673          
    674            // Re-enable interrupts
    675            HAL_EXIT_CRITICAL_SECTION(intState);
   \   000062   E5..         MOV     A,?V0 + 2
   \   000064   A2E0         MOV     C,0xE0 /* A   */.0
   \   000066   92AF         MOV     0xa8.7,C
    676          }
   \   000068   02....       LJMP    ?Subroutine23 & 0xFFFF
   \   00006B                REQUIRE _A_IEN0
    677          
    678          /*********************************************************************
    679           * @fn      osal_msg_enqueue_max
    680           *
    681           * @brief
    682           *
    683           *    This function enqueues an OSAL message into an OSAL queue if
    684           *    the length of the queue is less than max.
    685           *
    686           * @param   osal_msg_q_t *q_ptr - OSAL queue
    687           * @param   void *msg_ptr  - OSAL message
    688           * @param   uint8 max - maximum length of queue
    689           *
    690           * @return  TRUE if message was enqueued, FALSE otherwise
    691           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    692          uint8 osal_msg_enqueue_max( osal_msg_q_t *q_ptr, void *msg_ptr, uint8 max )
   \                     osal_msg_enqueue_max:
    693          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    694            void *list;
    695            uint8 ret = FALSE;
   \   000007   75..00       MOV     ?V0 + 0,#0x0
    696            halIntState_t intState;
    697          
    698            // Hold off interrupts
    699            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000A   A2AF         MOV     C,0xa8.7
   \   00000C   E4           CLR     A
   \   00000D   92E0         MOV     0xE0 /* A   */.0,C
   \   00000F   FF           MOV     R7,A
   \   000010   C2AF         CLR     0xa8.7
    700          
    701            // If first message in queue
    702            if ( *q_ptr == NULL )
   \   000012   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000015   7001         JNZ     ??osal_msg_enqueue_max_0
   \   000017   E9           MOV     A,R1
   \                     ??osal_msg_enqueue_max_0:
   \   000018   7010         JNZ     ??CrossCallReturnLabel_32
    703            {
    704              *q_ptr = msg_ptr;
   \   00001A   8A82         MOV     DPL,R2
   \   00001C   8B83         MOV     DPH,R3
   \   00001E   801B         SJMP    ??osal_msg_enqueue_max_1
    705              ret = TRUE;
    706            }
    707            else
    708            {
    709              // Find end of queue or max
    710              list = *q_ptr;
    711              max--;
    712              while ( (OSAL_MSG_NEXT( list ) != NULL) && (max > 0) )
   \                     ??osal_msg_enqueue_max_2:
   \   000020   EE           MOV     A,R6
   \   000021   6020         JZ      ??osal_msg_enqueue_max_3
    713              {
    714                list = OSAL_MSG_NEXT( list );
   \   000023   8882         MOV     DPL,R0
   \   000025   8983         MOV     DPH,R1
   \   000027   12....       LCALL   ?Subroutine11 & 0xFFFF
    715                max--;
   \                     ??CrossCallReturnLabel_32:
   \   00002A   1E           DEC     R6
    716              }
   \   00002B   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   00002E   7002         JNZ     ??osal_msg_enqueue_max_4
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_max_4:
   \   000032   70EC         JNZ     ??osal_msg_enqueue_max_2
    717          
    718              // Add message to end of queue if max not reached
    719              if ( max != 0 )
   \   000034   EE           MOV     A,R6
   \   000035   600C         JZ      ??osal_msg_enqueue_max_3
    720              {
    721                OSAL_MSG_NEXT( list ) = msg_ptr;
   \   000037   8882         MOV     DPL,R0
   \   000039   8983         MOV     DPH,R1
   \                     ??osal_msg_enqueue_max_1:
   \   00003B   EC           MOV     A,R4
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   A3           INC     DPTR
   \   00003E   ED           MOV     A,R5
   \   00003F   F0           MOVX    @DPTR,A
    722                ret = TRUE;
   \   000040   75..01       MOV     ?V0 + 0,#0x1
    723              }
    724            }
    725          
    726            // Re-enable interrupts
    727            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_enqueue_max_3:
   \   000043   EF           MOV     A,R7
   \   000044   A2E0         MOV     C,0xE0 /* A   */.0
   \   000046   92AF         MOV     0xa8.7,C
    728          
    729            return ret;
   \   000048   A9..         MOV     R1,?V0 + 0
   \   00004A   02....       LJMP    ?Subroutine26 & 0xFFFF
   \   00004D                REQUIRE _A_IEN0
    730          }
    731          
    732          /*********************************************************************
    733           * @fn      osal_set_event
    734           *
    735           * @brief
    736           *
    737           *    This function is called to set the event flags for a task.  The
    738           *    event passed in is OR'd into the task's event variable.
    739           *
    740           * @param   uint8 task_id - receiving tasks ID
    741           * @param   uint8 event_flag - what event to set
    742           *
    743           * @return  SUCCESS, INVALID_TASK
    744           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    745          uint8 osal_set_event( uint8 task_id, uint16 event_flag )
   \                     osal_set_event:
    746          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    747            if ( task_id < tasksCnt )
   \   000004   90....       MOV     DPTR,#tasksCnt
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FC           MOV     R4,A
   \   000009   E9           MOV     A,R1
   \   00000A   C3           CLR     C
   \   00000B   9C           SUBB    A,R4
   \   00000C   501F         JNC     ??osal_set_event_0
    748            {
    749              halIntState_t   intState;
    750              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   00000E   A2AF         MOV     C,0xa8.7
   \   000010   E4           CLR     A
   \   000011   92E0         MOV     0xE0 /* A   */.0,C
   \   000013   FD           MOV     R5,A
   \   000014   C2AF         CLR     0xa8.7
    751              tasksEvents[task_id] |= event_flag;  // Stuff the event bit(s)
   \   000016   E9           MOV     A,R1
   \   000017   C3           CLR     C
   \   000018   33           RLC     A
   \   000019   F8           MOV     R0,A
   \   00001A   E4           CLR     A
   \   00001B   33           RLC     A
   \   00001C   F9           MOV     R1,A
   \   00001D   90....       MOV     DPTR,#tasksEvents
   \   000020   E0           MOVX    A,@DPTR
   \   000021   28           ADD     A,R0
   \   000022   FC           MOV     R4,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   39           ADDC    A,R1
   \   000026   12....       LCALL   ?Subroutine4 & 0xFFFF
    752              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
    753              return ( SUCCESS );
   \                     ??CrossCallReturnLabel_11:
   \   000029   7900         MOV     R1,#0x0
   \   00002B   8002         SJMP    ??osal_set_event_1
    754            }
    755             else
    756            {
    757              return ( INVALID_TASK );
   \                     ??osal_set_event_0:
   \   00002D   7903         MOV     R1,#0x3
    758            }
   \                     ??osal_set_event_1:
   \   00002F   02....       LJMP    ?Subroutine22 & 0xFFFF
   \   000032                REQUIRE _A_IEN0
    759          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   8C82         MOV     DPL,R4
   \   000002   F583         MOV     DPH,A
   \   000004   E0           MOVX    A,@DPTR
   \   000005   4A           ORL     A,R2
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   4B           ORL     A,R3
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   ED           MOV     A,R5
   \   00000C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000E   92AF         MOV     0xa8.7,C
   \   000010   22           RET
    760          
    761          /*********************************************************************
    762           * @fn      osal_clear_event
    763           *
    764           * @brief
    765           *
    766           *    This function is called to clear the event flags for a task.  The
    767           *    event passed in is masked out of the task's event variable.
    768           *
    769           * @param   uint8 task_id - receiving tasks ID
    770           * @param   uint8 event_flag - what event to set
    771           *
    772           * @return  SUCCESS, INVALID_TASK
    773           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    774          uint8 osal_clear_event( uint8 task_id, uint16 event_flag )
   \                     osal_clear_event:
    775          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    776            if ( task_id < tasksCnt )
   \   000005   90....       MOV     DPTR,#tasksCnt
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FC           MOV     R4,A
   \   00000A   E9           MOV     A,R1
   \   00000B   C3           CLR     C
   \   00000C   9C           SUBB    A,R4
   \   00000D   5021         JNC     ??osal_clear_event_0
    777            {
    778              halIntState_t   intState;
    779              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   00000F   A2AF         MOV     C,0xa8.7
   \   000011   E4           CLR     A
   \   000012   92E0         MOV     0xE0 /* A   */.0,C
   \   000014   FE           MOV     R6,A
   \   000015   C2AF         CLR     0xa8.7
    780              tasksEvents[task_id] &= ~(event_flag);   // clear the event bit(s)
   \   000017   EA           MOV     A,R2
   \   000018   F4           CPL     A
   \   000019   FC           MOV     R4,A
   \   00001A   EB           MOV     A,R3
   \   00001B   F4           CPL     A
   \   00001C   FD           MOV     R5,A
   \   00001D   E9           MOV     A,R1
   \   00001E   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000021   5C           ANL     A,R4
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   5D           ANL     A,R5
   \   000026   F0           MOVX    @DPTR,A
    781              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
   \   000027   EE           MOV     A,R6
   \   000028   A2E0         MOV     C,0xE0 /* A   */.0
   \   00002A   92AF         MOV     0xa8.7,C
    782              return ( SUCCESS );
   \   00002C   7900         MOV     R1,#0x0
   \   00002E   8002         SJMP    ??osal_clear_event_1
    783            }
    784             else
    785            {
    786              return ( INVALID_TASK );
   \                     ??osal_clear_event_0:
   \   000030   7903         MOV     R1,#0x3
    787            }
   \                     ??osal_clear_event_1:
   \   000032   02....       LJMP    ??Subroutine28_0 & 0xFFFF
   \   000035                REQUIRE _A_IEN0
    788          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   C3           CLR     C
   \   000001   33           RLC     A
   \   000002   F8           MOV     R0,A
   \   000003   E4           CLR     A
   \   000004   33           RLC     A
   \   000005   F9           MOV     R1,A
   \   000006   90....       MOV     DPTR,#tasksEvents
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   28           ADD     A,R0
   \   00000B   FA           MOV     R2,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   39           ADDC    A,R1
   \   00000F   8A82         MOV     DPL,R2
   \   000011   F583         MOV     DPH,A
   \   000013   E0           MOVX    A,@DPTR
   \   000014   22           RET
    789          
    790          /*********************************************************************
    791           * @fn      osal_isr_register
    792           *
    793           * @brief
    794           *
    795           *   This function is called to register a service routine with an
    796           *   interrupt. When the interrupt occurs, this service routine is called.
    797           *
    798           * @param   uint8 interrupt_id - Interrupt number
    799           * @param   void (*isr_ptr)( uint8* ) - function pointer to ISR
    800           *
    801           * @return  SUCCESS, INVALID_INTERRUPT_ID,
    802           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    803          uint8 osal_isr_register( uint8 interrupt_id, void (*isr_ptr)( uint8* ) )
   \                     osal_isr_register:
    804          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    805            // Remove these statements when functionality is complete
    806            (void)interrupt_id;
    807            (void)isr_ptr;
    808            return ( SUCCESS );
   \   000000   7900         MOV     R1,#0x0
   \   000002   02....       LJMP    ?BRET
    809          }
    810          
    811          /*********************************************************************
    812           * @fn      osal_int_enable
    813           *
    814           * @brief
    815           *
    816           *   This function is called to enable an interrupt. Once enabled,
    817           *   occurrence of the interrupt causes the service routine associated
    818           *   with that interrupt to be called.
    819           *
    820           *   If INTS_ALL is the interrupt_id, interrupts (in general) are enabled.
    821           *   If a single interrupt is passed in, then interrupts still have
    822           *   to be enabled with another call to INTS_ALL.
    823           *
    824           * @param   uint8 interrupt_id - Interrupt number
    825           *
    826           * @return  SUCCESS or INVALID_INTERRUPT_ID
    827           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    828          uint8 osal_int_enable( uint8 interrupt_id )
   \                     osal_int_enable:
    829          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    830          
    831            if ( interrupt_id == INTS_ALL )
   \   000000   74FF         MOV     A,#-0x1
   \   000002   69           XRL     A,R1
   \   000003   7006         JNZ     ??osal_int_enable_0
    832            {
    833              HAL_ENABLE_INTERRUPTS();
   \   000005   D2AF         SETB    0xa8.7
    834              return ( SUCCESS );
   \   000007   7900         MOV     R1,#0x0
   \   000009   8002         SJMP    ??osal_int_enable_1
    835            }
    836            else
    837            {
    838              return ( INVALID_INTERRUPT_ID );
   \                     ??osal_int_enable_0:
   \   00000B   7907         MOV     R1,#0x7
   \                     ??osal_int_enable_1:
   \   00000D   02....       LJMP    ?BRET
   \   000010                REQUIRE _A_IEN0
    839            }
    840          }
    841          
    842          /*********************************************************************
    843           * @fn      osal_int_disable
    844           *
    845           * @brief
    846           *
    847           *   This function is called to disable an interrupt. When a disabled
    848           *   interrupt occurs, the service routine associated with that
    849           *   interrupt is not called.
    850           *
    851           *   If INTS_ALL is the interrupt_id, interrupts (in general) are disabled.
    852           *   If a single interrupt is passed in, then just that interrupt is disabled.
    853           *
    854           * @param   uint8 interrupt_id - Interrupt number
    855           *
    856           * @return  SUCCESS or INVALID_INTERRUPT_ID
    857           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    858          uint8 osal_int_disable( uint8 interrupt_id )
   \                     osal_int_disable:
    859          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    860          
    861            if ( interrupt_id == INTS_ALL )
   \   000000   74FF         MOV     A,#-0x1
   \   000002   69           XRL     A,R1
   \   000003   7006         JNZ     ??osal_int_disable_0
    862            {
    863              HAL_DISABLE_INTERRUPTS();
   \   000005   C2AF         CLR     0xa8.7
    864              return ( SUCCESS );
   \   000007   7900         MOV     R1,#0x0
   \   000009   8002         SJMP    ??osal_int_disable_1
    865            }
    866            else
    867            {
    868              return ( INVALID_INTERRUPT_ID );
   \                     ??osal_int_disable_0:
   \   00000B   7907         MOV     R1,#0x7
   \                     ??osal_int_disable_1:
   \   00000D   02....       LJMP    ?BRET
   \   000010                REQUIRE _A_IEN0
    869            }
    870          }
    871          
    872          /*********************************************************************
    873           * @fn      osal_init_system
    874           *
    875           * @brief
    876           *
    877           *   This function initializes the "task" system by creating the
    878           *   tasks defined in the task table (OSAL_Tasks.h).
    879           *
    880           * @param   void
    881           *
    882           * @return  SUCCESS
    883           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    884          uint8 osal_init_system( void )
   \                     osal_init_system:
    885          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    886            // Initialize the Memory Allocation System
    887            osal_mem_init();
   \   000004                ; Setup parameters for call to function osal_mem_init
   \   000004   12....       LCALL   ??osal_mem_init?relay
    888          
    889            // Initialize the message queue
    890            osal_qHead = NULL;
   \   000007   90....       MOV     DPTR,#osal_qHead
   \   00000A   E4           CLR     A
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   F0           MOVX    @DPTR,A
    891          
    892            // Initialize the timers
    893            osalTimerInit();
   \   00000E                ; Setup parameters for call to function osalTimerInit
   \   00000E   12....       LCALL   ??osalTimerInit?relay
    894          
    895            // Initialize the Power Management System
    896            osal_pwrmgr_init();
   \   000011                ; Setup parameters for call to function osal_pwrmgr_init
   \   000011   12....       LCALL   ??osal_pwrmgr_init?relay
    897          
    898            // Initialize the system tasks.
    899            osalInitTasks();
   \   000014                ; Setup parameters for call to function osalInitTasks
   \   000014   12....       LCALL   ??osalInitTasks?relay
    900          
    901            // Setup efficient search for the first free block of heap.
    902            osal_mem_kick();
   \   000017                ; Setup parameters for call to function osal_mem_kick
   \   000017   12....       LCALL   ??osal_mem_kick?relay
    903          
    904            return ( SUCCESS );
   \   00001A   7900         MOV     R1,#0x0
   \   00001C   02....       LJMP    ?Subroutine22 & 0xFFFF
    905          }
    906          
    907          /*********************************************************************
    908           * @fn      osal_start_system
    909           *
    910           * @brief
    911           *
    912           *   This function is the main loop function of the task system.  It
    913           *   will look through all task events and call the task_event_processor()
    914           *   function for the task with the event.  If there are no events (for
    915           *   all tasks), this function puts the processor into Sleep.
    916           *   This Function doesn't return.
    917           *
    918           * @param   void
    919           *
    920           * @return  none
    921           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    922          void osal_start_system( void )
   \                     osal_start_system:
    923          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    924          #if !defined ( ZBIT ) && !defined ( UBIT )
    925            for(;;)  // Forever Loop
    926          #endif
    927            { 
    928              
    929            #ifdef HAL_KEYPAD
    930              ch = halKeypadPushed();
    931              if(ch > 0)
    932              { 
    933              #if defined (End_Device)
    934                osal_set_event( zclZigbeeDevice_TaskID , KEYPAD_MSG_EVT ); // Set the keypad event
    935              #endif
    936              #if defined(Coor_receiver)||(Router_receiver)
    937                osal_set_event( zclZigbeeReceiver_TaskID , KEYPAD_MSG_EVT ); // Set the keypad event
    938              #endif
    939              }
    940            #endif    
    941          
    942              uint8 idx = 0;
   \                     ??osal_start_system_0:
   \   000005   75..00       MOV     ?V0 + 0,#0x0
    943              osalTimeUpdate();
   \   000008                ; Setup parameters for call to function osalTimeUpdate
   \   000008   12....       LCALL   ??osalTimeUpdate?relay
    944              Hal_ProcessPoll();  // This replaces MT_SerialPoll() and osal_check_timer().
   \   00000B                ; Setup parameters for call to function Hal_ProcessPoll
   \   00000B   12....       LCALL   ??Hal_ProcessPoll?relay
    945              
    946          /*********¡@The under is task array, check the task have happen ************/
    947              do 
    948              {
    949                if (tasksEvents[idx])  // Task is highest priority that is ready.
   \                     ??osal_start_system_1:
   \   00000E   E5..         MOV     A,?V0 + 0
   \   000010   12....       LCALL   ?Subroutine7 & 0xFFFF
    950                 {
    951                   break;
    952                 }
    953              }while (++idx < tasksCnt);
   \                     ??CrossCallReturnLabel_19:
   \   000013   7002         JNZ     ??osal_start_system_2
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \                     ??osal_start_system_2:
   \   000017   700D         JNZ     ??osal_start_system_3
   \   000019   05..         INC     ?V0 + 0
   \   00001B   90....       MOV     DPTR,#tasksCnt
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   FA           MOV     R2,A
   \   000020   E5..         MOV     A,?V0 + 0
   \   000022   C3           CLR     C
   \   000023   9A           SUBB    A,R2
   \   000024   40E8         JC      ??osal_start_system_1
    954          
    955              if (idx < tasksCnt)
   \                     ??osal_start_system_3:
   \   000026   90....       MOV     DPTR,#tasksCnt
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   FA           MOV     R2,A
   \   00002B   E5..         MOV     A,?V0 + 0
   \   00002D   C3           CLR     C
   \   00002E   9A           SUBB    A,R2
   \   00002F   50D4         JNC     ??osal_start_system_0
    956              {
    957                uint16 events;
    958                halIntState_t intState;
    959          
    960                HAL_ENTER_CRITICAL_SECTION(intState); //enter critical section,°õ¦æHAL_DISABLE_INTERRUPT();
   \   000031   A2AF         MOV     C,0xa8.7
   \   000033   E4           CLR     A
   \   000034   92E0         MOV     0xE0 /* A   */.0,C
   \   000036   FD           MOV     R5,A
   \   000037   C2AF         CLR     0xa8.7
    961                  events = tasksEvents[idx]; //²Äidx­Ó¥ô°Èµo¥Í¨Æ¥ó, ³B²z²Äidxªº¥ô°È¨Æ¥ó
   \   000039   E5..         MOV     A,?V0 + 0
   \   00003B   C3           CLR     C
   \   00003C   33           RLC     A
   \   00003D   FE           MOV     R6,A
   \   00003E   E4           CLR     A
   \   00003F   33           RLC     A
   \   000040   FF           MOV     R7,A
   \   000041   90....       MOV     DPTR,#tasksEvents
   \   000044   E0           MOVX    A,@DPTR
   \   000045   2E           ADD     A,R6
   \   000046   F8           MOV     R0,A
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   3F           ADDC    A,R7
   \   00004A   F9           MOV     R1,A
   \   00004B   8882         MOV     DPL,R0
   \   00004D   8983         MOV     DPH,R1
   \   00004F   12....       LCALL   ?Subroutine9 & 0xFFFF
    962                  tasksEvents[idx] = 0;  // Clear the Events for this task.
   \                     ??CrossCallReturnLabel_27:
   \   000052   8882         MOV     DPL,R0
   \   000054   8983         MOV     DPH,R1
   \   000056   E4           CLR     A
   \   000057   F0           MOVX    @DPTR,A
   \   000058   A3           INC     DPTR
   \   000059   F0           MOVX    @DPTR,A
    963                HAL_EXIT_CRITICAL_SECTION(intState); //exit critical section
   \   00005A   ED           MOV     A,R5
   \   00005B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00005D   92AF         MOV     0xa8.7,C
    964          
    965                events = (tasksArr[idx])( idx, events );
   \   00005F                ; Setup parameters for indirect call
   \   00005F   A9..         MOV     R1,?V0 + 0
   \   000061   EE           MOV     A,R6
   \   000062   24..         ADD     A,#(tasksArr & 0xff)
   \   000064   F582         MOV     DPL,A
   \   000066   EF           MOV     A,R7
   \   000067   34..         ADDC    A,#((tasksArr >> 8) & 0xff)
   \   000069   F583         MOV     DPH,A
   \   00006B   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   00006E   12....       LCALL   ?CALL_IND
    966          
    967                HAL_ENTER_CRITICAL_SECTION(intState);
   \   000071   A2AF         MOV     C,0xa8.7
   \   000073   E4           CLR     A
   \   000074   92E0         MOV     0xE0 /* A   */.0,C
   \   000076   FD           MOV     R5,A
   \   000077   C2AF         CLR     0xa8.7
    968                tasksEvents[idx] |= events;  // Add back unprocessed events to the current task.
   \   000079   90....       MOV     DPTR,#tasksEvents
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   2E           ADD     A,R6
   \   00007E   FC           MOV     R4,A
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   3F           ADDC    A,R7
   \   000082   12....       LCALL   ?Subroutine4 & 0xFFFF
    969                HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??CrossCallReturnLabel_12:
   \   000085   02....       LJMP    ??osal_start_system_0 & 0xFFFF
   \   000088                REQUIRE _A_IEN0
    970              }
    971          #if defined( POWER_SAVING )
    972              else  // Complete pass through all task events with no activity?
    973              {
    974                osal_pwrmgr_powerconserve();  // Put the processor/system into sleep
    975              }
    976          #endif
    977            }
    978          }
    979          
    980          /*********************************************************************
    981           * @fn      osal_buffer_uint32
    982           *
    983           * @brief
    984           *
    985           *   Buffer an uint32 value - LSB first.
    986           *
    987           * @param   buf - buffer
    988           * @param   val - uint32 value
    989           *
    990           * @return  pointer to end of destination buffer
    991           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    992          uint8* osal_buffer_uint32( uint8 *buf, uint32 val )
   \                     osal_buffer_uint32:
    993          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   7410         MOV     A,#0x10
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   78..         MOV     R0,#?V0 + 4
   \   00000C   12....       LCALL   ?L_MOV_X
    994            *buf++ = BREAK_UINT32( val, 0 );
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   \   000013   E5..         MOV     A,?V0 + 4
   \   000015   12....       LCALL   ?Subroutine18 & 0xFFFF
    995            *buf++ = BREAK_UINT32( val, 1 );
    996            *buf++ = BREAK_UINT32( val, 2 );
   \                     ??CrossCallReturnLabel_39:
   \   000018   85....       MOV     ?V0 + 0,?V0 + 4
   \   00001B   85....       MOV     ?V0 + 2,?V0 + 6
   \   00001E   85....       MOV     ?V0 + 3,?V0 + 7
   \   000021   7410         MOV     A,#0x10
   \   000023   78..         MOV     R0,#?V0 + 0
   \   000025   12....       LCALL   ?UL_SHR
   \   000028   E5..         MOV     A,?V0 + 0
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
    997            *buf++ = BREAK_UINT32( val, 3 );
   \   00002C   7418         MOV     A,#0x18
   \   00002E                REQUIRE ?Subroutine27
   \   00002E                ; // Fall through to label ?Subroutine27
    998          
    999            return buf;
   1000          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   78..         MOV     R0,#?V0 + 4
   \   000002   12....       LCALL   ?UL_SHR
   \   000005   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000008   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   E5..         MOV     A,?V0 + 4
   \   000002   F0           MOVX    @DPTR,A
   \   000003   A3           INC     DPTR
   \   000004   AA82         MOV     R2,DPL
   \   000006   AB83         MOV     R3,DPH
   \   000008   7F08         MOV     R7,#0x8
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   85....       MOV     ?V0 + 1,?V0 + 5
   \   000005   E5..         MOV     A,?V0 + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   22           RET
   1001          
   1002          /*********************************************************************
   1003           * @fn      osal_buffer_uint24
   1004           *
   1005           * @brief
   1006           *
   1007           *   Buffer an uint24 value - LSB first. Note that type uint24 is
   1008           *   typedef to uint32 in comdef.h
   1009           *
   1010           * @param   buf - buffer
   1011           * @param   val - uint24 value
   1012           *
   1013           * @return  pointer to end of destination buffer
   1014           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1015          uint8* osal_buffer_uint24( uint8 *buf, uint24 val )
   \                     osal_buffer_uint24:
   1016          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   7410         MOV     A,#0x10
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   78..         MOV     R0,#?V0 + 4
   \   00000C   12....       LCALL   ?L_MOV_X
   1017            *buf++ = BREAK_UINT32( val, 0 );
   \   00000F   85....       MOV     ?V0 + 0,?V0 + 4
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   E5..         MOV     A,?V0 + 0
   \   000018   12....       LCALL   ?Subroutine18 & 0xFFFF
   1018            *buf++ = BREAK_UINT32( val, 1 );
   1019            *buf++ = BREAK_UINT32( val, 2 );
   \                     ??CrossCallReturnLabel_40:
   \   00001B   7410         MOV     A,#0x10
   \   00001D   80..         SJMP    ?Subroutine27
   1020          
   1021            return buf;
   1022          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_strlen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_strlen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memcpy?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memcpy

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_revmemcpy?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_revmemcpy

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memdup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memdup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memcmp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memcmp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_build_uint16?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_build_uint16

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_build_uint32?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_build_uint32

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??_ltoa?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    _ltoa

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_rand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_rand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_allocate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_allocate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_deallocate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_deallocate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_send?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_send

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_receive?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_receive

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_find?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_find

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_enqueue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_dequeue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_dequeue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_push?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_push

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_extract?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_extract

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_enqueue_max?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue_max

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_set_event?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_set_event

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_clear_event?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_clear_event

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_isr_register?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_isr_register

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_int_enable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_int_enable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_int_disable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_int_disable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_init_system?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_init_system

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_start_system?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_start_system

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_buffer_uint32?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_buffer_uint32

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_buffer_uint24?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_buffer_uint24

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">_1`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">_2`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "0">`:
   \   000000   3000         DB "0"

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_2710:
   \   000000   10270000     DD 10000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_5f5e100:
   \   000000   00E1F505     DD 100000000
   1023          /*********************************************************************
   1024          *********************************************************************/

   Maximum stack usage in bytes:

     Function                 ISTACK PSTACK XSTACK
     --------                 ------ ------ ------
     _ltoa                        2      0     58
       -> _itoa                   0      0    112
       -> _itoa                   0      0    112
       -> _itoa                   0      0    112
       -> strcpy                  0      0    112
       -> strcat                  0      0    112
       -> strlen                  0      0    112
       -> strcat                  0      0    112
       -> strcat                  0      0    112
       -> strlen                  0      0    112
       -> strcat                  0      0    112
       -> strcpy                  0      0    112
       -> _itoa                   0      0    112
       -> _itoa                   0      0    112
       -> strcpy                  0      0    112
       -> strcat                  0      0    112
       -> strlen                  0      0    112
       -> strcat                  0      0    112
     osal_buffer_uint24           1      0     20
     osal_buffer_uint32           1      0     20
     osal_build_uint16            0      0      9
     osal_build_uint32            0      0     16
     osal_clear_event             1      0     23
     osal_init_system             2      0      0
       -> osal_mem_init           4      0      0
       -> osalTimerInit           4      0      0
       -> osal_pwrmgr_init        4      0      0
       -> osalInitTasks           4      0      0
       -> osal_mem_kick           4      0      0
     osal_int_disable             0      0      0
     osal_int_enable              0      0      0
     osal_isr_register            0      0      0
     osal_memcmp                  0      0     22
     osal_memcpy                  1      0     29
     osal_memdup                  0      0     18
       -> osal_mem_alloc          0      0     30
       -> osal_memcpy             0      0     36
     osal_memset                  0      0     12
       -> memset                  0      0     24
     osal_msg_allocate            1      0     10
       -> osal_mem_alloc          0      0     20
     osal_msg_deallocate          2      0      9
       -> osal_mem_free           4      0      0
     osal_msg_dequeue             1      0     10
     osal_msg_enqueue             0      0     18
     osal_msg_enqueue_max         0      0     10
     osal_msg_extract             1      0     27
     osal_msg_find                0      0      9
     osal_msg_push                0      0      9
     osal_msg_receive             0      0     16
       -> osal_set_event          0      0     28
       -> osal_clear_event        0      0     28
       -> osal_msg_extract        0      0     32
     osal_msg_send                1      0      9
       -> osal_msg_deallocate     0      0     18
       -> osal_msg_deallocate     0      0     18
       -> osal_msg_enqueue        0      0     18
       -> osal_set_event          0      0     18
     osal_rand                    2      0      0
       -> Onboard_rand            4      0      0
     osal_revmemcpy               1      0     12
     osal_set_event               3      0     14
     osal_start_system            1      0     10
       -> osalTimeUpdate          0      0     20
       -> Hal_ProcessPoll         0      0     20
     osal_strlen                  2      0      0
       -> strlen                  4      0      0


   Segment part sizes:

     Function/Label               Bytes
     --------------               -----
     _A_IEN0                         1
     osal_qHead                      2
     ch                              1
     osal_strlen                    10
     ?Subroutine22                   7
     osal_memcpy                    65
     ?Subroutine23                   5
     ?Subroutine5                    8
     osal_revmemcpy                 77
     ??Subroutine28_0                5
     ?Subroutine9                    6
     osal_memdup                    58
     osal_memcmp                   112
     osal_memset                    29
     ?Subroutine26                   5
     ?Subroutine24                   1
     osal_build_uint16              20
     osal_build_uint32             157
     ?Subroutine12                  15
     ?Subroutine2                    6
     ?Subroutine20                  16
     _ltoa                         618
     ?Subroutine8                    6
     ?Subroutine6                   12
     ?Subroutine3                   14
     ?Subroutine1                    6
     ?Subroutine21                   9
     ?Subroutine0                   28
     ?Subroutine13                   9
     osal_rand                       9
     osal_msg_allocate              86
     osal_msg_deallocate            36
     ?Subroutine15                  14
     osal_msg_send                  87
     ??Subroutine32_0                5
     osal_msg_receive              148
     osal_msg_find                  61
     ?Subroutine16                   3
     ??Subroutine31_0                3
     osal_msg_enqueue               50
     ?Subroutine25                   6
     ?Subroutine14                   5
     ??Subroutine29_0                9
     ?Subroutine10                   4
     ??Subroutine30_0                7
     ?Subroutine17                  13
     ?Subroutine11                   6
     osal_msg_dequeue               85
     osal_msg_push                  35
     osal_msg_extract              107
     osal_msg_enqueue_max           77
     osal_set_event                 50
     ?Subroutine4                   17
     osal_clear_event               53
     ?Subroutine7                   21
     osal_isr_register               5
     osal_int_enable                16
     osal_int_disable               16
     osal_init_system               31
     osal_start_system             136
     osal_buffer_uint32             46
     ?Subroutine27                  11
     ?Subroutine19                  11
     ?Subroutine18                  10
     osal_buffer_uint24             31
     ??osal_strlen?relay             6
     ??osal_memcpy?relay             6
     ??osal_revmemcpy?relay          6
     ??osal_memdup?relay             6
     ??osal_memcmp?relay             6
     ??osal_memset?relay             6
     ??osal_build_uint16?relay       6
     ??osal_build_uint32?relay       6
     ??_ltoa?relay                   6
     ??osal_rand?relay               6
     ??osal_msg_allocate?relay       6
     ??osal_msg_deallocate?relay     6
     ??osal_msg_send?relay           6
     ??osal_msg_receive?relay        6
     ??osal_msg_find?relay           6
     ??osal_msg_enqueue?relay        6
     ??osal_msg_dequeue?relay        6
     ??osal_msg_push?relay           6
     ??osal_msg_extract?relay        6
     ??osal_msg_enqueue_max?relay    6
     ??osal_set_event?relay          6
     ??osal_clear_event?relay        6
     ??osal_isr_register?relay       6
     ??osal_int_enable?relay         6
     ??osal_int_disable?relay        6
     ??osal_init_system?relay        6
     ??osal_start_system?relay       6
     ??osal_buffer_uint32?relay      6
     ??osal_buffer_uint24?relay      6
     ?<Constant "">                 10
     ?<Constant "">_1               10
     ?<Constant "">_2               10
     ?<Constant "0">                 2
     __Constant_2710                 4
     __Constant_5f5e100              4

 
 2 614 bytes in segment BANKED_CODE
   174 bytes in segment BANK_RELAYS
     1 byte  in segment SFR_AN
    40 bytes in segment XDATA_ROM_C
     3 bytes in segment XDATA_Z
 
 2 788 bytes of CODE  memory
    32 bytes of CONST memory (+ 8 bytes shared)
     0 bytes of DATA  memory (+ 1 byte  shared)
     3 bytes of XDATA memory

Errors: none
Warnings: none
