///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V7.51A/W32 for 8051               08/Jun/2010  11:24:09 /
// Copyright 2004-2009 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//    Source file        =  D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3.0 /
//                          -1.4.0\ZStack-CC2530-2.3.0-1.4.0\Components\stack /
//                          \zcl\zcl_general.c                                /
//    Command line       =  -f "D:\µ{¦¡¶}µo\TI Zigbee                         /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\Tools\CC2530DB\f8wRouter. /
//                          cfg" (-DCPU32MHZ -DROOT=__near_func               /
//                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE -DRTR_NWK        /
//                          -DBLINK_LEDS) -f "D:\µ{¦¡¶}µo\TI Zigbee           /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig. /
//                          cfg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0            /
//                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800         /
//                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3   /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40          /
//                          -DNWK_MAX_BINDING_ENTRIES=4                       /
//                          -DMAX_BINDING_CLUSTER_IDS=4                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DMAC_MAX_FRAME_SIZE=116       /
//                          "-DCONST=const __code" -DGENERIC=__generic        /
//                          -DRFD_RCVC_ALWAYS_ON=TRUE -DPOLL_RATE=1000        /
//                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100   /
//                          -DREJOIN_POLL_RATE=440) -f "D:\µ{¦¡¶}µo\TI        /
//                          Zigbee Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-C /
//                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\ /
//                          SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8w /
//                          ZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC      /
//                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH   /
//                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING          /
//                          -DZCL_PRICING) -DZCL_MESSAGE "D:\µ{¦¡¶}µo\TI      /
//                          Zigbee Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-C /
//                          C2530-2.3.0-1.4.0\Components\stack\zcl\zcl_genera /
//                          l.c" -D ZTOOL_P1 -D MT_TASK -D MT_APP_FUNC -D     /
//                          MT_SYS_FUNC -D MT_ZDO_FUNC -D                     /
//                          LCD_SUPPORTED=DEBUG -lC "D:\µ{¦¡¶}µo\TI Zigbee    /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\RouterKB\List\" -lA                /
//                          "D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3. /
//                          0-1.4.0\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack /
//                          \HomeAutomation\SampleSwitch\CC2530DB\RouterKB\Li /
//                          st\" --diag_suppress Pe001,Pa010 -o               /
//                          "D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3. /
//                          0-1.4.0\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack /
//                          \HomeAutomation\SampleSwitch\CC2530DB\RouterKB\Ob /
//                          j\" -e --require_prototypes --debug --core=plain  /
//                          --dptr=16,1 --data_model=large                    /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data_rom                /
//                          --nr_virtual_regs 16 -I "D:\µ{¦¡¶}µo\TI Zigbee    /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\" -I "D:\µ{¦¡¶}µo\TI Zigbee        /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\SOURCE\" -I "D:\µ{¦¡¶}µo\TI     /
//                          Zigbee Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-C /
//                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\ /
//                          SampleSwitch\CC2530DB\..\..\SOURCE\" -I           /
//                          "D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3. /
//                          0-1.4.0\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack /
//                          \HomeAutomation\SampleSwitch\CC2530DB\..\..\..\ZM /
//                          AIN\TI2530DB\" -I "D:\µ{¦¡¶}µo\TI Zigbee          /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I  /
//                          "D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3. /
//                          0-1.4.0\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack /
//                          \HomeAutomation\SampleSwitch\CC2530DB\..\..\..\.. /
//                          \..\COMPONENTS\HAL\INCLUDE\" -I "D:\µ{¦¡¶}µo\TI   /
//                          Zigbee Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-C /
//                          C2530-2.3.0-1.4.0\Projects\zstack\HomeAutomation\ /
//                          SampleSwitch\CC2530DB\..\..\..\..\..\COMPONENTS\H /
//                          AL\TARGET\CC2530EB\" -I "D:\µ{¦¡¶}µo\TI Zigbee    /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU /
//                          \CCSOC\" -I "D:\µ{¦¡¶}µo\TI Zigbee                /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INC /
//                          LUDE\" -I "D:\µ{¦¡¶}µo\TI Zigbee                  /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF /
//                          \" -I "D:\µ{¦¡¶}µo\TI Zigbee                      /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NW /
//                          K\" -I "D:\µ{¦¡¶}µo\TI Zigbee                     /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SE /
//                          C\" -I "D:\µ{¦¡¶}µo\TI Zigbee                     /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SA /
//                          PI\" -I "D:\µ{¦¡¶}µo\TI Zigbee                    /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SY /
//                          S\" -I "D:\µ{¦¡¶}µo\TI Zigbee                     /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZC /
//                          L\" -I "D:\µ{¦¡¶}µo\TI Zigbee                     /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZD /
//                          O\" -I "D:\µ{¦¡¶}µo\TI Zigbee                     /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W /
//                          \" -I "D:\µ{¦¡¶}µo\TI Zigbee                      /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\"   /
//                          -I "D:\µ{¦¡¶}µo\TI Zigbee                         /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES /
//                          \SADDR\" -I "D:\µ{¦¡¶}µo\TI Zigbee                /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES /
//                          \SDATA\" -I "D:\µ{¦¡¶}µo\TI Zigbee                /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCL /
//                          UDE\" -I "D:\µ{¦¡¶}µo\TI Zigbee                   /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH /
//                          _LEVEL\" -I "D:\µ{¦¡¶}µo\TI Zigbee                /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ /
//                          LEVEL\srf04\" -I "D:\µ{¦¡¶}µo\TI Zigbee           /
//                          Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2 /
//                          .3.0-1.4.0\Projects\zstack\HomeAutomation\SampleS /
//                          witch\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ /
//                          LEVEL\srf04\SINGLE_CHIP\" -I "C:\IAR              /
//                          Systems\Embedded Workbench 5.3\8051\INC\" -I      /
//                          "C:\IAR Systems\Embedded Workbench                /
//                          5.3\8051\INC\CLIB\" -Ohz                          /
//    List file          =  D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3.0 /
//                          -1.4.0\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\ /
//                          HomeAutomation\SampleSwitch\CC2530DB\RouterKB\Lis /
//                          t\zcl_general.s51                                 /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME zcl_general

        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ??zclGeneral_HdlInSpecificCommands?relay
        EXTERN ??zclGeneral_HdlIncoming?relay
        EXTERN ??zclGeneral_ProcessInIdentity?relay
        EXTERN ??zclGeneral_SendIdentifyQueryResponse?relay
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?CALL_IND
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?PUSH_XSTACK_I_ONE
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?UC_SWITCH_SPARSE
        EXTERN ?V0
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN __INIT_XDATA_Z

        FUNCTION ??zclGeneral_HdlInSpecificCommands?relay,0203H
        FUNCTION ??zclGeneral_HdlIncoming?relay,0203H
        FUNCTION ??zclGeneral_ProcessInIdentity?relay,0203H
        PUBLIC ??zclGeneral_RegisterCmdCallbacks?relay
        FUNCTION ??zclGeneral_RegisterCmdCallbacks?relay,0203H
        PUBLIC ??zclGeneral_SendIdentify?relay
        FUNCTION ??zclGeneral_SendIdentify?relay,0203H
        PUBLIC ??zclGeneral_SendIdentifyQueryResponse?relay
        FUNCTION ??zclGeneral_SendIdentifyQueryResponse?relay,0203H
        FUNCTION zclGeneral_HdlInSpecificCommands,0a1203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        FUNCTION zclGeneral_HdlIncoming,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        FUNCTION zclGeneral_ProcessInIdentity,021203H
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 28, STACK
        PUBLIC zclGeneral_RegisterCmdCallbacks
        FUNCTION zclGeneral_RegisterCmdCallbacks,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC zclGeneral_SendIdentify
        FUNCTION zclGeneral_SendIdentify,021203H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 23, STACK
        PUBLIC zclGeneral_SendIdentifyQueryResponse
        FUNCTION zclGeneral_SendIdentifyQueryResponse,021203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 23, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-2
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B SameValue
        CFI A SameValue
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 SameValue
        CFI R1 SameValue
        CFI R2 SameValue
        CFI R3 SameValue
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT SameValue
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon1
        
zcl_registerPlugin  SYMBOL "zcl_registerPlugin"
osal_mem_alloc      SYMBOL "osal_mem_alloc"
zcl_SendCommand     SYMBOL "zcl_SendCommand"
zclFindAttrRec      SYMBOL "zclFindAttrRec"
zclReadAttrData     SYMBOL "zclReadAttrData"
??osal_mem_alloc?relay SYMBOL "?relay", osal_mem_alloc
??zclFindAttrRec?relay SYMBOL "?relay", zclFindAttrRec
??zclReadAttrData?relay SYMBOL "?relay", zclReadAttrData
??zcl_SendCommand?relay SYMBOL "?relay", zcl_SendCommand
??zcl_registerPlugin?relay SYMBOL "?relay", zcl_registerPlugin
zclGeneral_RegisterCmdCallbacks SYMBOL "zclGeneral_RegisterCmdCallbacks"
??zclGeneral_RegisterCmdCallbacks?relay SYMBOL "?relay", zclGeneral_RegisterCmdCallbacks
zclGeneral_SendIdentify SYMBOL "zclGeneral_SendIdentify"
??zclGeneral_SendIdentify?relay SYMBOL "?relay", zclGeneral_SendIdentify
zclGeneral_SendIdentifyQueryResponse SYMBOL "zclGeneral_SendIdentifyQueryResponse"
??zclGeneral_SendIdentifyQueryResponse?relay SYMBOL "?relay", zclGeneral_SendIdentifyQueryResponse

        EXTERN zcl_registerPlugin
        FUNCTION zcl_registerPlugin,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_mem_alloc
        FUNCTION osal_mem_alloc,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN zcl_SendCommand
        FUNCTION zcl_SendCommand,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN zclFindAttrRec
        FUNCTION zclFindAttrRec,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN zclReadAttrData
        FUNCTION zclReadAttrData,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ??osal_mem_alloc?relay
        FUNCTION ??osal_mem_alloc?relay,00H
        EXTERN ??zclFindAttrRec?relay
        FUNCTION ??zclFindAttrRec?relay,00H
        EXTERN ??zclReadAttrData?relay
        FUNCTION ??zclReadAttrData?relay,00H
        EXTERN ??zcl_SendCommand?relay
        FUNCTION ??zcl_SendCommand?relay,00H
        EXTERN ??zcl_registerPlugin?relay
        FUNCTION ??zcl_registerPlugin?relay,00H

// D:\µ{¦¡¶}µo\TI Zigbee Z-Stack\ZStack-CC2530-2.3.0-1.4.0\ZStack-CC2530-2.3.0-1.4.0\Components\stack\zcl\zcl_general.c
//    1 /**************************************************************************************************
//    2   Filename:       zcl_general.c
//    3   Revised:        $Date: 2009-10-26 15:51:02 -0700 (Mon, 26 Oct 2009) $
//    4   Revision:       $Revision: 20979 $
//    5 
//    6   Description:    Zigbee Cluster Library - General.  This application receives all
//    7                   ZCL messages and initially parses them before passing to application.
//    8 
//    9 
//   10   Copyright 2006-2008 Texas Instruments Incorporated. All rights reserved.
//   11 
//   12   IMPORTANT: Your use of this Software is limited to those specific rights
//   13   granted under the terms of a software license agreement between the user
//   14   who downloaded the software, his/her employer (which must be your employer)
//   15   and Texas Instruments Incorporated (the "License").  You may not use this
//   16   Software unless you agree to abide by the terms of the License. The License
//   17   limits your use, and you acknowledge, that the Software may not be modified,
//   18   copied or distributed unless embedded on a Texas Instruments microcontroller
//   19   or used solely and exclusively in conjunction with a Texas Instruments radio
//   20   frequency transceiver, which is integrated into your product.  Other than for
//   21   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   22   works of, modify, distribute, perform, display or sell this Software and/or
//   23   its documentation for any purpose.
//   24 
//   25   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   26   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   27   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   28   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   29   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   30   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   31   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   32   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   33   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   34   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   35   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   36 
//   37   Should you have any questions regarding your right to use this Software,
//   38   contact Texas Instruments Incorporated at www.TI.com.
//   39 **************************************************************************************************/
//   40 
//   41 /*********************************************************************
//   42  * INCLUDES
//   43  */
//   44 #include "ZComDef.h"
//   45 #include "OSAL.h"
//   46 #include "OSAL_Nv.h"
//   47 #include "zcl.h"
//   48 #include "zcl_general.h"
//   49 #include "ZDApp.h"
//   50 
//   51 #if defined ( INTER_PAN )
//   52   #include "stub_aps.h"
//   53 #endif
//   54 
//   55 /*********************************************************************
//   56  * MACROS
//   57  */
//   58 #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
//   59 #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
//   60 #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
//   61 
//   62 #ifdef ZCL_SCENES
//   63 #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
//   64 #endif // ZCL_SCENES
//   65 
//   66 /*********************************************************************
//   67  * CONSTANTS
//   68  */
//   69 
//   70 /*********************************************************************
//   71  * TYPEDEFS
//   72  */
//   73 typedef struct zclGenCBRec
//   74 {
//   75   struct zclGenCBRec        *next;
//   76   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   77   zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
//   78 } zclGenCBRec_t;
//   79 
//   80 typedef struct zclGenSceneItem
//   81 {
//   82   struct zclGenSceneItem    *next;
//   83   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   84   zclGeneral_Scene_t        scene;    // Scene info
//   85 } zclGenSceneItem_t;
//   86 
//   87 typedef struct zclGenAlarmItem
//   88 {
//   89   struct zclGenAlarmItem    *next;
//   90   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   91   zclGeneral_Alarm_t        alarm;    // Alarm info
//   92 } zclGenAlarmItem_t;
//   93 
//   94 // Scene NV types
//   95 typedef struct
//   96 {
//   97   uint16                    numRecs;
//   98 } nvGenScenesHdr_t;
//   99 
//  100 typedef struct zclGenSceneNVItem
//  101 {
//  102   uint8                     endpoint;
//  103   zclGeneral_Scene_t        scene;
//  104 } zclGenSceneNVItem_t;
//  105 
//  106 /*********************************************************************
//  107  * GLOBAL VARIABLES
//  108  */
//  109 
//  110 /*********************************************************************
//  111  * GLOBAL FUNCTIONS
//  112  */
//  113 
//  114 /*********************************************************************
//  115  * LOCAL VARIABLES
//  116  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  117 static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
zclGenCBs:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  118 static uint8 zclGenPluginRegisted = FALSE;
zclGenPluginRegisted:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  119 #ifdef ZCL_SCENES
//  120 static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
//  121 #endif // ZCL_SCENES
//  122 #ifdef ZCL_ALARMS
//  123 static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
//  124 #endif // ZCL_ALARMS
//  125 
//  126 /*********************************************************************
//  127  * LOCAL FUNCTIONS
//  128  */
//  129 static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
//  130 static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
//  131 static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
//  132 
//  133 // Device Configuration and Installation clusters
//  134 #ifdef ZCL_BASIC
//  135 static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  136 #endif // ZCL_BASIC
//  137 
//  138 #ifdef ZCL_IDENTIFY
//  139 static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  140 #endif // ZCL_IDENTIFY
//  141 
//  142 // Groups and Scenes clusters
//  143 #ifdef ZCL_GROUPS
//  144 static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
//  145 static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  146 static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
//  147 #endif // ZCL_GROUPS
//  148 
//  149 #ifdef ZCL_SCENES
//  150 static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  151 static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  152 #endif // ZCL_SCENES
//  153 
//  154 // On/Off and Level Control Configuration clusters
//  155 #ifdef ZCL_ON_OFF
//  156 static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  157 #endif // ZCL_ONOFF
//  158 
//  159 #ifdef ZCL_LEVEL_CTRL
//  160 static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  161 #endif // ZCL_LEVEL_CTRL
//  162 
//  163 // Alarms cluster
//  164 #ifdef ZCL_ALARMS
//  165 static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  166 static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  167 #endif // ZCL_ALARMS
//  168 
//  169 // Location cluster
//  170 #ifdef ZCL_LOCATION
//  171 static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  172 static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  173 #endif // ZCL_LOCATION
//  174 
//  175 #ifdef ZCL_SCENES
//  176 static uint8 zclGeneral_ScenesInitNV( void );
//  177 static void zclGeneral_ScenesSetDefaultNV( void );
//  178 static void zclGeneral_ScenesWriteNV( void );
//  179 static uint16 zclGeneral_ScenesRestoreFromNV( void );
//  180 #endif // ZCL_SCENES
//  181 
//  182 /*********************************************************************
//  183  * @fn      zclGeneral_RegisterCmdCallbacks
//  184  *
//  185  * @brief   Register an applications command callbacks
//  186  *
//  187  * @param   endpoint - application's endpoint
//  188  * @param   callbacks - pointer to the callback record.
//  189  *
//  190  * @return  ZMemError if not able to allocate
//  191  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  192 ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
zclGeneral_RegisterCmdCallbacks:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function zclGeneral_RegisterCmdCallbacks
//  193 {
        FUNCALL zclGeneral_RegisterCmdCallbacks, zcl_registerPlugin
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclGeneral_RegisterCmdCallbacks, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0 + 0,R1
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  194   zclGenCBRec_t *pNewItem;
//  195   zclGenCBRec_t *pLoop;
//  196 
//  197   // Register as a ZCL Plugin
//  198   if ( zclGenPluginRegisted == FALSE )
        MOV     DPTR,#zclGenPluginRegisted
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_RegisterCmdCallbacks_0
//  199   {
//  200     zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
//  201                         ZCL_CLUSTER_ID_GEN_LOCATION,
//  202                         zclGeneral_HdlIncoming );
        ; Setup parameters for call to function zcl_registerPlugin
        MOV     ?V0 + 2,#(??zclGeneral_HdlIncoming?relay & 0xff)
        MOV     ?V0 + 3,#((??zclGeneral_HdlIncoming?relay >> 8) & 0xff)
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     R4,#0xb
        MOV     R5,#0x0
        MOV     R2,#0x0
        MOV     R3,#0x0
        LCALL   ??zcl_registerPlugin?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
//  203 
//  204 #ifdef ZCL_SCENES
//  205     // Initialize NV items
//  206     zclGeneral_ScenesInitNV();
//  207 
//  208     // Restore the Scene table
//  209     zclGeneral_ScenesRestoreFromNV();
//  210 #endif // ZCL_SCENES
//  211 
//  212     zclGenPluginRegisted = TRUE;
        MOV     A,#0x1
        MOV     DPTR,#zclGenPluginRegisted
        MOVX    @DPTR,A
//  213   }
//  214 
//  215   // Fill in the new profile list
//  216   pNewItem = osal_mem_alloc( sizeof( zclGenCBRec_t ) );
??zclGeneral_RegisterCmdCallbacks_0:
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,#0x5
        MOV     R3,#0x0
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R0,?V0 + 2
        MOV     R1,?V0 + 3
//  217   if ( pNewItem == NULL )
        MOV     A,R0
        JNZ     ??zclGeneral_RegisterCmdCallbacks_1
        MOV     A,R1
??zclGeneral_RegisterCmdCallbacks_1:
        JNZ     ??zclGeneral_RegisterCmdCallbacks_2
//  218     return (ZMemError);
        MOV     R1,#0x10
        SJMP    ??zclGeneral_RegisterCmdCallbacks_3
//  219 
//  220   pNewItem->next = (zclGenCBRec_t *)NULL;
??zclGeneral_RegisterCmdCallbacks_2:
        MOV     DPL,R0
        MOV     DPH,R1
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  221   pNewItem->endpoint = endpoint;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
//  222   pNewItem->CBs = callbacks;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
//  223 
//  224   // Find spot in list
//  225   if (  zclGenCBs == NULL )
        MOV     DPTR,#zclGenCBs
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_RegisterCmdCallbacks_4
        INC     DPTR
        MOVX    A,@DPTR
??zclGeneral_RegisterCmdCallbacks_4:
        MOV     DPTR,#zclGenCBs
        JZ      ??zclGeneral_RegisterCmdCallbacks_5
//  226   {
//  227     zclGenCBs = pNewItem;
//  228   }
//  229   else
//  230   {
//  231     // Look for end of list
//  232     pLoop = zclGenCBs;
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        SJMP    ??zclGeneral_RegisterCmdCallbacks_6
//  233     while ( pLoop->next != NULL )
//  234       pLoop = pLoop->next;
??zclGeneral_RegisterCmdCallbacks_7:
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
??zclGeneral_RegisterCmdCallbacks_6:
        MOV     R5,A
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        JNZ     ??zclGeneral_RegisterCmdCallbacks_8
        MOV     A,R3
??zclGeneral_RegisterCmdCallbacks_8:
        JNZ     ??zclGeneral_RegisterCmdCallbacks_7
//  235 
//  236     // Put new item at end of list
//  237     pLoop->next = pNewItem;
        MOV     DPL,R4
        MOV     DPH,R5
??zclGeneral_RegisterCmdCallbacks_5:
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  238   }
//  239 
//  240   return ( ZSuccess );
        MOV     R1,#0x0
        CFI EndBlock cfiBlock0
??zclGeneral_RegisterCmdCallbacks_3:
        REQUIRE ?Subroutine9
        ; // Fall through to label ?Subroutine9
//  241 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine9:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock1
//  242 
//  243 #ifdef ZCL_IDENTIFY
//  244 /*********************************************************************
//  245  * @fn      zclGeneral_SendIdentify
//  246  *
//  247  * @brief   Call to send out an Identify Command
//  248  *
//  249  * @param   srcEP - Sending application's endpoint
//  250  * @param   dstAddr - where you want the message to go
//  251  * @param   identifyTime - how long the device will continue to identify itself (in seconds)
//  252  * @param   seqNum - identification number for the transaction
//  253  *
//  254  * @return  ZStatus_t
//  255  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  256 ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
zclGeneral_SendIdentify:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function zclGeneral_SendIdentify
//  257                       uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
//  258 {
        FUNCALL zclGeneral_SendIdentify, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine1 & 0xFFFF
//  259   uint8 buf[2];
//  260 
//  261   buf[0] = LO_UINT16( identifyTime );
//  262   buf[1] = HI_UINT16( identifyTime );
??CrossCallReturnLabel_2:
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine0 & 0xFFFF
//  263 
//  264   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
//  265                           COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  266                           disableDefaultRsp, 0, seqNum, 2, buf );
??CrossCallReturnLabel_0:
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     ?V0 + 0,#0x2
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R7
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 17)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 19)
        MOV     A,R6
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 21)
        MOV     ?V0 + 0,#0x1
        CFI EndBlock cfiBlock2
        REQUIRE ?Subroutine10
        ; // Fall through to label ?Subroutine10

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine10:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 21)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 23)
        MOV     R4,#0x3
        MOV     R5,#0x0
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI EndBlock cfiBlock3
        REQUIRE ??Subroutine11_0
        ; // Fall through to label ??Subroutine11_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine11_0:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock4
//  267 }
//  268 
//  269 /*********************************************************************
//  270  * @fn      zclGeneral_SendIdentifyQueryResponse
//  271  *
//  272  * @brief   Call to send out an Identify Query Response Command
//  273  *
//  274  * @param   srcEP - Sending application's endpoint
//  275  * @param   dstAddr - where you want the message to go
//  276  * @param   timeout - how long the device will continue to identify itself (in seconds)
//  277  * @param   seqNum - identification number for the transaction
//  278  *
//  279  * @return  ZStatus_t
//  280  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  281 ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
zclGeneral_SendIdentifyQueryResponse:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function zclGeneral_SendIdentifyQueryResponse
//  282                             uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
//  283 {
        FUNCALL zclGeneral_SendIdentifyQueryResponse, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine1 & 0xFFFF
//  284   uint8 buf[2];
//  285 
//  286   buf[0] = LO_UINT16( timeout );
//  287   buf[1] = HI_UINT16( timeout );
??CrossCallReturnLabel_3:
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine0 & 0xFFFF
//  288 
//  289   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
//  290                           COMMAND_IDENTIFY_QUERY_RSP, TRUE,
//  291                           ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
??CrossCallReturnLabel_1:
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     ?V0 + 0,#0x2
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R7
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 17)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 19)
        MOV     A,R6
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     ?V0 + 0,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 21)
        SJMP    ?Subroutine10
        CFI EndBlock cfiBlock5

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine1:
        CFI Block cfiCond6 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_2
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond7 Using cfiCommon0
        CFI (cfiCond7) NoFunction
        CFI (cfiCond7) Conditional ??CrossCallReturnLabel_3
        CFI (cfiCond7) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond7) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond7) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond7) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond7) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond7) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond7) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond7) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond7) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond7) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond7) CFA_SP SP+0
        CFI (cfiCond7) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker8 Using cfiCommon1
        CFI (cfiPicker8) NoFunction
        CFI (cfiPicker8) Picker
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,R4
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
        MOV     A,#0x1
        RET
        CFI EndBlock cfiCond6
        CFI EndBlock cfiCond7
        CFI EndBlock cfiPicker8

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine0:
        CFI Block cfiCond9 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_0
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond10 Using cfiCommon0
        CFI (cfiCond10) NoFunction
        CFI (cfiCond10) Conditional ??CrossCallReturnLabel_1
        CFI (cfiCond10) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond10) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond10) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond10) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond10) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond10) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond10) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond10) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond10) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond10) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond10) CFA_SP SP+0
        CFI (cfiCond10) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker11 Using cfiCommon1
        CFI (cfiPicker11) NoFunction
        CFI (cfiPicker11) Picker
        MOV     A,R5
        MOVX    @DPTR,A
        ; Setup parameters for call to function zcl_SendCommand
        ; Setup parameters for call to function zcl_SendCommand
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        RET
        CFI EndBlock cfiCond9
        CFI EndBlock cfiCond10
        CFI EndBlock cfiPicker11
//  292 }
//  293 #endif // ZCL_IDENTIFY
//  294 
//  295 #ifdef ZCL_GROUPS
//  296 /*********************************************************************
//  297  * @fn      zclGeneral_SendGroupRequest
//  298  *
//  299  * @brief   Send a Group Request to a device.  You can also use the
//  300  *          appropriate macro.
//  301  *
//  302  * @param   srcEP - Sending Apps endpoint
//  303  * @param   dstAddr - where to send the request
//  304  * @param   cmd - one of the following:
//  305  *              COMMAND_GROUP_VIEW
//  306  *              COMMAND_GROUP_REMOVE
//  307  * @param   groupID -
//  308  *
//  309  * @return  ZStatus_t
//  310  */
//  311 ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  312                      uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
//  313 {
//  314   uint8 buf[2];
//  315 
//  316   buf[0] = LO_UINT16( groupID );
//  317   buf[1] = HI_UINT16( groupID );
//  318 
//  319   return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  320                             cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  321                             disableDefaultRsp, 0, seqNum, 2, buf ) );
//  322 }
//  323 
//  324 /*********************************************************************
//  325  * @fn      zclGeneral_SendAddGroupRequest
//  326  *
//  327  * @brief   Send the Add Group Request to a device
//  328  *
//  329  * @param   srcEP - Sending Apps endpoint
//  330  * @param   dstAddr - where to send the request
//  331  * @param   cmd - one of the following:
//  332  *                COMMAND_GROUP_ADD
//  333  *                COMMAND_GROUP_ADD_IF_IDENTIFYING
//  334  * @param   groupID - pointer to the group structure
//  335  * @param   groupName - pointer to Group Name.  This is a Zigbee
//  336  *          string data type, so the first byte is the length of the
//  337  *          name (in bytes), then the name.
//  338  *
//  339  * @return  ZStatus_t
//  340  */
//  341 ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  342                                           uint8 cmd, uint16 groupID, uint8 *groupName,
//  343                                           uint8 disableDefaultRsp, uint8 seqNum )
//  344 {
//  345   uint8 *buf;
//  346   uint8 *pBuf;
//  347   uint8 len;
//  348   ZStatus_t status;
//  349 
//  350   len = 2;    // Group ID
//  351   len += groupName[0] + 1;  // String + 1 for length
//  352 
//  353   buf = osal_mem_alloc( len );
//  354   if ( buf )
//  355   {
//  356     pBuf = buf;
//  357     *pBuf++ = LO_UINT16( groupID );
//  358     *pBuf++ = HI_UINT16( groupID );
//  359     *pBuf++ = groupName[0]; // string length
//  360     osal_memcpy( pBuf, &(groupName[1]), groupName[0] );
//  361 
//  362     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  363                               cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  364                               disableDefaultRsp, 0, seqNum, len, buf );
//  365     osal_mem_free( buf );
//  366   }
//  367   else
//  368     status = ZMemError;
//  369 
//  370   return ( status );
//  371 }
//  372 
//  373 /*********************************************************************
//  374  * @fn      zclGeneral_SendGroupGetMembershipRequest
//  375  *
//  376  * @brief   Send a Get Group Membership (Resposne) Command to a device
//  377  *
//  378  * @param   srcEP - Sending Apps endpoint
//  379  * @param   dstAddr - where to send the request
//  380  * @param   cmd - one of the following:
//  381  *                COMMAND_GROUP_GET_MEMBERSHIP
//  382  *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
//  383  * @param   groupID - pointer to the group structure
//  384  * @param   groupName - pointer to Group Name.  This is a Zigbee
//  385  *          string data type, so the first byte is the length of the
//  386  *          name (in bytes), then the name.
//  387  *
//  388  * @return  ZStatus_t
//  389  */
//  390 ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  391                               uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
//  392                               uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
//  393 {
//  394   uint8 *buf;
//  395   uint8 *pBuf;
//  396   uint8 len = 0;
//  397   uint8 i;
//  398   ZStatus_t status;
//  399 
//  400   if ( rspCmd )
//  401     len++;  // Capacity
//  402 
//  403   len++;  // Group Count
//  404   len += sizeof ( uint16 ) * grpCnt;  // Group List
//  405 
//  406   buf = osal_mem_alloc( len );
//  407   if ( buf )
//  408   {
//  409     pBuf = buf;
//  410     if ( rspCmd )
//  411       *pBuf++ = capacity;
//  412 
//  413     *pBuf++ = grpCnt;
//  414     for ( i = 0; i < grpCnt; i++ )
//  415     {
//  416       *pBuf++ = LO_UINT16( grpList[i] );
//  417       *pBuf++ = HI_UINT16( grpList[i] );
//  418     }
//  419 
//  420     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  421                               cmd, TRUE, direction,
//  422                               disableDefaultRsp, 0, seqNum, len, buf );
//  423     osal_mem_free( buf );
//  424   }
//  425   else
//  426     status = ZMemError;
//  427 
//  428   return ( status );
//  429 }
//  430 
//  431 /*********************************************************************
//  432  * @fn      zclGeneral_SendGroupResponse
//  433  *
//  434  * @brief   Send Group Response (not Group View Response)
//  435  *
//  436  * @param   srcEP - Sending application's endpoint
//  437  * @param   dstAddr - where you want the message to go
//  438  * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
//  439  * @param   status - group command status
//  440  * @param   groupID - what group
//  441  *
//  442  * @return  ZStatus_t
//  443  */
//  444 ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  445                                         uint8 cmd, uint8 status, uint16 groupID,
//  446                                         uint8 disableDefaultRsp, uint8 seqNum )
//  447 {
//  448   uint8 buf[3];
//  449 
//  450   buf[0] = status;
//  451   buf[1] = LO_UINT16( groupID );
//  452   buf[2] = HI_UINT16( groupID );
//  453 
//  454   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  455                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  456                           disableDefaultRsp, 0, seqNum, 3, buf );
//  457 }
//  458 
//  459 /*********************************************************************
//  460  * @fn      zclGeneral_SendGroupViewResponse
//  461  *
//  462  * @brief   Call to send Group Response Command
//  463  *
//  464  * @param   srcEP - Sending application's endpoint
//  465  * @param   dstAddr - where you want the message to go
//  466  * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
//  467  * @param   status - group command status
//  468  * @param   grp - group info
//  469  *
//  470  * @return  ZStatus_t
//  471  */
//  472 ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  473                  uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
//  474 {
//  475   uint8 *buf;
//  476   uint8 len;
//  477   ZStatus_t stat;
//  478 
//  479   len = 1 + 2; // Status + Group ID
//  480 
//  481   if ( status == ZCL_STATUS_SUCCESS )
//  482     len += grp->name[0] + 1;  // String + 1 for length
//  483 
//  484   buf = osal_mem_alloc( len );
//  485   if ( buf )
//  486   {
//  487     buf[0] = status;
//  488     buf[1] = LO_UINT16( grp->ID );
//  489     buf[2] = HI_UINT16( grp->ID );
//  490 
//  491     if ( status == ZCL_STATUS_SUCCESS )
//  492     {
//  493       buf[3] = grp->name[0]; // string length
//  494       osal_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
//  495     }
//  496 
//  497     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  498                             COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  499                             disableDefaultRsp, 0, seqNum, len, buf );
//  500     osal_mem_free( buf );
//  501   }
//  502   else
//  503     stat = ZMemError;
//  504 
//  505   return ( stat );
//  506 }
//  507 #endif // ZCL_GROUPS
//  508 
//  509 #ifdef ZCL_SCENES
//  510 /*********************************************************************
//  511  * @fn      zclGeneral_SendAddScene
//  512  *
//  513  * @brief   Send the Add Scene Request to a device
//  514  *
//  515  * @param   srcEP - Sending Apps endpoint
//  516  * @param   dstAddr - where to send the request
//  517  * @param   scene - pointer to the scene structure
//  518  *
//  519  * @return  ZStatus_t
//  520  */
//  521 ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
//  522                       zclGeneral_Scene_t *scene, uint8 disableDefaultRsp, uint8 seqNum )
//  523 {
//  524   uint8 *buf;
//  525   uint8 *pBuf;
//  526   uint8 len;
//  527   ZStatus_t status;
//  528 
//  529   len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
//  530   len += scene->name[0] + 1; // String + 1 for length
//  531 
//  532   // Add something for the extension field length
//  533   len += scene->extLen;
//  534 
//  535   buf = osal_mem_alloc( len );
//  536   if ( buf )
//  537   {
//  538     pBuf = buf;
//  539     *pBuf++ = LO_UINT16( scene->groupID );
//  540     *pBuf++ = HI_UINT16( scene->groupID );
//  541     *pBuf++ = scene->ID;
//  542     *pBuf++ = LO_UINT16( scene->transTime );
//  543     *pBuf++ = HI_UINT16( scene->transTime );
//  544     *pBuf++ = scene->name[0]; // string length
//  545     osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
//  546     pBuf += scene->name[0]; // move pass name
//  547 
//  548     // Add the extension fields
//  549     if ( scene->extLen > 0 )
//  550       osal_memcpy( pBuf, scene->extField, scene->extLen );
//  551 
//  552     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  553                               COMMAND_SCENE_ADD, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  554                               disableDefaultRsp, 0, seqNum, len, buf );
//  555     osal_mem_free( buf );
//  556   }
//  557   else
//  558     status = ZMemError;
//  559 
//  560   return ( status );
//  561 }
//  562 
//  563 /*********************************************************************
//  564  * @fn      zclGeneral_SendSceneRequest
//  565  *
//  566  * @brief   Send a Scene Request to a device.  You can also use the
//  567  *          appropriate macro.
//  568  *
//  569  * @param   srcEP - Sending Apps endpoint
//  570  * @param   dstAddr - where to send the request
//  571  * @param   cmd - one of the following:
//  572  *              COMMAND_SCENE_VIEW
//  573  *              COMMAND_SCENE_REMOVE
//  574  *              COMMAND_SCENE_REMOVE_ALL
//  575  *              COMMAND_SCENE_STORE
//  576  *              COMMAND_SCENE_RECALL
//  577  *              COMMAND_SCENE_GET_MEMBERSHIP
//  578  * @param   groupID - group ID
//  579  * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
//  580  *                    COMMAND_SCENE_GET_MEMBERSHIP)
//  581  * @return  ZStatus_t
//  582  */
//  583 ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  584                                        uint8 cmd, uint16 groupID, uint8 sceneID,
//  585                                        uint8 disableDefaultRsp, uint8 seqNum )
//  586 {
//  587   uint8 buf[3];
//  588   uint8 len = 2;
//  589 
//  590   buf[0] = LO_UINT16( groupID );
//  591   buf[1] = HI_UINT16( groupID );
//  592 
//  593   if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
//  594   {
//  595     buf[2] = sceneID;
//  596     len++;
//  597   }
//  598 
//  599   return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  600                             cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  601                             disableDefaultRsp, 0, seqNum, len, buf ) );
//  602 }
//  603 
//  604 /*********************************************************************
//  605  * @fn      zclGeneral_SendSceneResponse
//  606  *
//  607  * @brief   Send Group Response (not Group View Response)
//  608  *
//  609  * @param   srcEP - Sending application's endpoint
//  610  * @param   dstAddr - where you want the message to go
//  611  * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
//  612  *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
//  613  * @param   status - scene command status
//  614  * @param   groupID - what group
//  615  * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
//  616  *
//  617  * @return  ZStatus_t
//  618  */
//  619 ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  620                                   uint8 cmd, uint8 status, uint16 groupID,
//  621                                   uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
//  622 {
//  623   uint8 buf[4];
//  624   uint8 len = 1 + 2; // Status + Group ID
//  625 
//  626   buf[0] = status;
//  627   buf[1] = LO_UINT16( groupID );
//  628   buf[2] = HI_UINT16( groupID );
//  629 
//  630   if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
//  631   {
//  632     buf[3] = sceneID;
//  633     len++;
//  634   }
//  635 
//  636   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  637                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  638                           disableDefaultRsp, 0, seqNum, len, buf );
//  639 }
//  640 
//  641 /*********************************************************************
//  642  * @fn      zclGeneral_SendSceneViewResponse
//  643  *
//  644  * @brief   Call to send Scene Response Command
//  645  *
//  646  * @param   srcEP - Sending application's endpoint
//  647  * @param   dstAddr - where you want the message to go
//  648  * @param   status - scene command status
//  649  * @param   scene - scene info
//  650  *
//  651  * @return  ZStatus_t
//  652  */
//  653 ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  654                                        uint8 status, zclGeneral_Scene_t *scene,
//  655                                        uint8 disableDefaultRsp, uint8 seqNum )
//  656 {
//  657   uint8 *buf;
//  658   uint8 *pBuf;
//  659   uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
//  660   ZStatus_t stat;
//  661 
//  662   if ( status == ZCL_STATUS_SUCCESS )
//  663   {
//  664     len += 2; // Transition Time
//  665     len += scene->name[0] + 1; // string + 1 for length
//  666 
//  667     // Add something for the extension field length
//  668     len += scene->extLen;
//  669   }
//  670 
//  671   buf = osal_mem_alloc( len );
//  672   if ( buf )
//  673   {
//  674     pBuf = buf;
//  675     *pBuf++ = status;
//  676     *pBuf++ = LO_UINT16( scene->groupID );
//  677     *pBuf++ = HI_UINT16( scene->groupID );
//  678     *pBuf++ = scene->ID;
//  679     if ( status == ZCL_STATUS_SUCCESS )
//  680     {
//  681       *pBuf++ = LO_UINT16( scene->transTime );
//  682       *pBuf++ = HI_UINT16( scene->transTime );
//  683       *pBuf++ = scene->name[0]; // string length
//  684       if ( scene->name[0] != 0 )
//  685       {
//  686         osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
//  687         pBuf += scene->name[0]; // move pass name
//  688       }
//  689 
//  690       // Add the extension fields
//  691       if ( scene->extLen > 0 )
//  692         osal_memcpy( pBuf, scene->extField, scene->extLen );
//  693     }
//  694 
//  695     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  696                             COMMAND_SCENE_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  697                             disableDefaultRsp, 0, seqNum, len, buf );
//  698     osal_mem_free( buf );
//  699   }
//  700   else
//  701     stat = ZMemError;
//  702 
//  703   return ( stat );
//  704 }
//  705 
//  706 /*********************************************************************
//  707  * @fn      zclGeneral_SendSceneGetMembershipResponse
//  708  *
//  709  * @brief   Call to send Scene Get Membership Response Command
//  710  *
//  711  * @param   srcEP - Sending application's endpoint
//  712  * @param   dstAddr - where you want the message to go
//  713  * @param   status - scene command status
//  714  * @param   capacity - remaining capacity of the scene table
//  715  * @param   sceneCnt - number of scenes in the scene list
//  716  * @param   sceneList - list of scene IDs
//  717  * @param   groupID - group ID that scene belongs to
//  718  * @param   seqNum - sequence number
//  719  *
//  720  * @return  ZStatus_t
//  721  */
//  722 ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  723                        uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
//  724                        uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
//  725 {
//  726   uint8 *buf;
//  727   uint8 *pBuf;
//  728   uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
//  729   uint8 i;
//  730   ZStatus_t stat;
//  731 
//  732   if ( status == ZCL_STATUS_SUCCESS )
//  733   {
//  734     len++; // Scene Count
//  735     len += sceneCnt; // Scene List (Scene ID is a single octet)
//  736   }
//  737 
//  738   buf = osal_mem_alloc( len );
//  739   if ( buf )
//  740   {
//  741     pBuf = buf;
//  742     *pBuf++ = status;
//  743     *pBuf++ = capacity;
//  744     *pBuf++ = LO_UINT16( groupID );
//  745     *pBuf++ = HI_UINT16( groupID );
//  746     if ( status == ZCL_STATUS_SUCCESS )
//  747     {
//  748       *pBuf++ = sceneCnt;
//  749       for ( i = 0; i < sceneCnt; i++ )
//  750         *pBuf++ = sceneList[i];
//  751     }
//  752 
//  753     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  754                             COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
//  755                             ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
//  756     osal_mem_free( buf );
//  757   }
//  758   else
//  759     stat = ZMemError;
//  760 
//  761   return ( stat );
//  762 }
//  763 #endif // ZCL_SCENES
//  764 
//  765 #ifdef ZCL_LEVEL_CTRL
//  766 /*********************************************************************
//  767  * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
//  768  *
//  769  * @brief   Call to send out a Level Control Request. You can also use
//  770  *          the appropriate macro.
//  771  *
//  772  * @param   srcEP - Sending application's endpoint
//  773  * @param   dstAddr - where you want the message to go
//  774  * @param   cmd - one of the following:
//  775  *              COMMAND_LEVEL_MOVE_TO_LEVEL or
//  776  *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
//  777  * @param   level - what level to move to
//  778  * @param   transitionTime - how long to take to get to the level (in seconds)
//  779  *
//  780  * @return  ZStatus_t
//  781  */
//  782 ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  783                                                          uint8 cmd, uint8 level, uint16 transTime,
//  784                                                          uint8 disableDefaultRsp, uint8 seqNum )
//  785 {
//  786   uint8 buf[3];
//  787 
//  788   buf[0] = level;
//  789   buf[1] = LO_UINT16( transTime );
//  790   buf[2] = HI_UINT16( transTime );
//  791 
//  792   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
//  793                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  794                           disableDefaultRsp, 0, seqNum, 3, buf );
//  795 }
//  796 
//  797 /*********************************************************************
//  798  * @fn      zclGeneral_SendLevelControlMoveRequest
//  799  *
//  800  * @brief   Call to send out a Level Control Request. You can also use
//  801  *          the appropriate macro.
//  802  *
//  803  * @param   srcEP - Sending application's endpoint
//  804  * @param   dstAddr - where you want the message to go
//  805  * @param   cmd - one of the following:
//  806  *              COMMAND_LEVEL_MOVE or
//  807  *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
//  808  * @param   moveMode - LEVEL_MOVE_UP or
//  809  *                     LEVEL_MOVE_DOWN
//  810  * @param   rate - number of steps to take per second
//  811  *
//  812  * @return  ZStatus_t
//  813  */
//  814 ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  815                                                   uint8 cmd, uint8 moveMode, uint8 rate,
//  816                                                   uint8 disableDefaultRsp, uint8 seqNum )
//  817 {
//  818   uint8 buf[2];
//  819 
//  820   buf[0] = moveMode;
//  821   buf[1] = rate;
//  822 
//  823   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
//  824                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  825                           disableDefaultRsp, 0, seqNum, 2, buf );
//  826 }
//  827 
//  828 /*********************************************************************
//  829  * @fn      zclGeneral_SendLevelControlStepRequest
//  830  *
//  831  * @brief   Call to send out a Level Control Request. You can also use
//  832  *          the appropriate macro.
//  833  *
//  834  * @param   srcEP - Sending application's endpoint
//  835  * @param   dstAddr - where you want the message to go
//  836  * @param   cmd - one of the following:
//  837  *              COMMAND_LEVEL_STEP
//  838  *              COMMAND_LEVEL_STEP_WITH_ON_OFF
//  839  * @param   stepMode - LEVEL_STEP_UP or
//  840  *                     LEVEL_STEP_DOWN
//  841  * @param   amount - number of levels to step
//  842  * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
//  843  *
//  844  * @return  ZStatus_t
//  845  */
//  846 ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  847                          uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
//  848                          uint8 disableDefaultRsp, uint8 seqNum )
//  849 {
//  850   uint8 buf[4];
//  851 
//  852   buf[0] = stepMode;
//  853   buf[1] = stepSize;
//  854   buf[2] = LO_UINT16( transTime );
//  855   buf[3] = HI_UINT16( transTime );
//  856 
//  857   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
//  858                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  859                           disableDefaultRsp, 0, seqNum, 4, buf );
//  860 }
//  861 #endif // ZCL_LEVEL_CTRL
//  862 
//  863 #ifdef ZCL_ALARMS
//  864 /*********************************************************************
//  865  * @fn      zclGeneral_SendAlarmRequest
//  866  *
//  867  * @brief   Call to send out an Alarm Request Command
//  868  *
//  869  * @param   srcEP - Sending application's endpoint
//  870  * @param   dstAddr - where you want the message to go
//  871  * @param   cmd - either COMMAND_ALARMS_RESET or COMMAND_ALARMS_ALARM
//  872  * @param   alarmCode - code for the cause of the alarm
//  873  * @param   clusterID - cluster whose attribute generate the alarm
//  874  *
//  875  * @return  ZStatus_t
//  876  */
//  877 ZStatus_t zclGeneral_SendAlarmRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  878                                        uint8 cmd, uint8 alarmCode, uint16 clusterID,
//  879                                        uint8 disableDefaultRsp, uint8 seqNum )
//  880 {
//  881   uint8 buf[3];
//  882 
//  883   buf[0] = alarmCode;
//  884   buf[1] = LO_UINT16( clusterID );
//  885   buf[2] = HI_UINT16( clusterID );
//  886 
//  887   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
//  888                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  889                           disableDefaultRsp, 0, seqNum, 3, buf );
//  890 }
//  891 
//  892 /*********************************************************************
//  893  * @fn      zclGeneral_SendAlarmGetRespnose
//  894  *
//  895  * @brief   Call to send out an Alarm Get Response Command
//  896  *
//  897  * @param   srcEP - Sending application's endpoint
//  898  * @param   dstAddr - where you want the message to go
//  899  * @param   status - SUCCESS or NOT_FOUND
//  900  * @param   alarmCode - code for the cause of the alarm
//  901  * @param   clusterID - cluster whose attribute generate the alarm
//  902  * @param   timeStamp - time at which the alarm occured
//  903  *
//  904  * @return  ZStatus_t
//  905  */
//  906 ZStatus_t zclGeneral_SendAlarmGetRespnose( uint8 srcEP, afAddrType_t *dstAddr,
//  907                               uint8 status, uint8 alarmCode, uint16 clusterID,
//  908                               uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
//  909 {
//  910   uint8 buf[8];
//  911   uint8 len = 1; // Status
//  912 
//  913   buf[0] = status;
//  914   if ( status == ZCL_STATUS_SUCCESS )
//  915   {
//  916     len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
//  917     buf[1] = alarmCode;
//  918     buf[2] = LO_UINT16( clusterID );
//  919     buf[3] = HI_UINT16( clusterID );
//  920     osal_buffer_uint32( &buf[4], timeStamp );
//  921   }
//  922 
//  923   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
//  924                           COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  925                           disableDefaultRsp, 0, seqNum, len, buf );
//  926 }
//  927 #endif // ZCL_ALARMS
//  928 
//  929 #ifdef ZCL_LOCATION
//  930 /*********************************************************************
//  931  * @fn      zclGeneral_SendLocationSetAbsolute
//  932  *
//  933  * @brief   Call to send out a Set Absolute Location Command
//  934  *
//  935  * @param   srcEP - Sending application's endpoint
//  936  * @param   dstAddr - where you want the message to go
//  937  * @param   absLoc - absolute location info
//  938  *
//  939  * @return  ZStatus_t
//  940  */
//  941 ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
//  942                                               zclLocationAbsolute_t *absLoc,
//  943                                               uint8 disableDefaultRsp, uint8 seqNum )
//  944 {
//  945    uint8 buf[10]; // 5 fields (2 octects each)
//  946 
//  947    buf[0] = LO_UINT16( absLoc->coordinate1 );
//  948    buf[1] = HI_UINT16( absLoc->coordinate1 );
//  949    buf[2] = LO_UINT16( absLoc->coordinate2 );
//  950    buf[3] = HI_UINT16( absLoc->coordinate2 );
//  951    buf[4] = LO_UINT16( absLoc->coordinate3 );
//  952    buf[5] = HI_UINT16( absLoc->coordinate3 );
//  953    buf[6] = LO_UINT16( absLoc->power );
//  954    buf[7] = HI_UINT16( absLoc->power );
//  955    buf[8] = LO_UINT16( absLoc->pathLossExponent );
//  956    buf[9] = HI_UINT16( absLoc->pathLossExponent );
//  957 
//  958    return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
//  959                            COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
//  960                            ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
//  961 }
//  962 
//  963 /*********************************************************************
//  964  * @fn      zclGeneral_SendLocationSetDevCfg
//  965  *
//  966  * @brief   Call to send out a Set Device Configuration Command
//  967  *
//  968  * @param   srcEP - Sending application's endpoint
//  969  * @param   dstAddr - where you want the message to go
//  970  * @param   devCfg - device configuration info
//  971  *
//  972  * @return  ZStatus_t
//  973  */
//  974 ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
//  975                                             zclLocationDevCfg_t *devCfg,
//  976                                             uint8 disableDefaultRsp, uint8 seqNum )
//  977 {
//  978    uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
//  979 
//  980    buf[0] = LO_UINT16( devCfg->power );
//  981    buf[1] = HI_UINT16( devCfg->power );
//  982    buf[2] = LO_UINT16( devCfg->pathLossExponent );
//  983    buf[3] = HI_UINT16( devCfg->pathLossExponent );
//  984    buf[4] = LO_UINT16( devCfg->calcPeriod );
//  985    buf[5] = HI_UINT16( devCfg->calcPeriod );
//  986    buf[6] = devCfg->numMeasurements;
//  987    buf[7] = LO_UINT16( devCfg->reportPeriod );
//  988    buf[8] = HI_UINT16( devCfg->reportPeriod );
//  989 
//  990    return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
//  991                            COMMAND_LOCATION_SET_DEV_CFG, TRUE,
//  992                            ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
//  993 }
//  994 
//  995 /*********************************************************************
//  996  * @fn      zclGeneral_SendLocationGetDevCfg
//  997  *
//  998  * @brief   Call to send out a Get Device Configuration Command
//  999  *
// 1000  * @param   srcEP - Sending application's endpoint
// 1001  * @param   dstAddr - where you want the message to go
// 1002  * @param   targetAddr - device for which location parameters are being requested
// 1003  *
// 1004  * @return  ZStatus_t
// 1005  */
// 1006 ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
// 1007                        uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
// 1008 {
// 1009   uint8 buf[8];
// 1010 
// 1011   osal_cpyExtAddr( buf, targetAddr );
// 1012 
// 1013   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1014                           COMMAND_LOCATION_GET_DEV_CFG, TRUE,
// 1015                           ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
// 1016 }
// 1017 
// 1018 /*********************************************************************
// 1019  * @fn      zclGeneral_SendLocationGetData
// 1020  *
// 1021  * @brief   Call to send out a Get Location Data Command
// 1022  *
// 1023  * @param   srcEP - Sending application's endpoint
// 1024  * @param   dstAddr - where you want the message to go
// 1025  * @param   locaData - location information and channel parameters that are requested.
// 1026  *
// 1027  * @return  ZStatus_t
// 1028  */
// 1029 ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
// 1030                                           zclLocationGetData_t *locData,
// 1031                                           uint8 disableDefaultRsp, uint8 seqNum )
// 1032 {
// 1033   uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
// 1034   uint8 *pBuf = buf;
// 1035   uint8 len = 2; // bitmap + number responses
// 1036 
// 1037   *pBuf  = locData->absoluteOnly;
// 1038   *pBuf |= locData->recalculate << 1;
// 1039   *pBuf |= locData->brdcastIndicator << 2;
// 1040   *pBuf |= locData->brdcastResponse << 3;
// 1041   *pBuf |= locData->compactResponse << 4;
// 1042   pBuf++;  // move past the bitmap field
// 1043 
// 1044   *pBuf++ = locData->numResponses;
// 1045 
// 1046   if ( locData->brdcastIndicator == 0 )
// 1047   {
// 1048     osal_cpyExtAddr( pBuf, locData->targetAddr );
// 1049     len += 8; // ieee addr
// 1050   }
// 1051 
// 1052   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1053                           COMMAND_LOCATION_GET_DATA, TRUE,
// 1054                           ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
// 1055 }
// 1056 
// 1057 /*********************************************************************
// 1058  * @fn      zclGeneral_SendLocationDevCfgResponse
// 1059  *
// 1060  * @brief   Call to send out a Device Configuration Response Command
// 1061  *
// 1062  * @param   srcEP - Sending application's endpoint
// 1063  * @param   dstAddr - where you want the message to go
// 1064  * @param   devCfg - device's location parameters that are requested
// 1065  *
// 1066  * @return  ZStatus_t
// 1067  */
// 1068 ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
// 1069                                                  zclLocationDevCfgRsp_t *devCfg,
// 1070                                                  uint8 disableDefaultRsp, uint8 seqNum )
// 1071 {
// 1072   uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
// 1073   uint8 len = 1; // Status
// 1074 
// 1075   buf[0] = devCfg->status;
// 1076   if ( devCfg->status == ZCL_STATUS_SUCCESS )
// 1077   {
// 1078     buf[1] = LO_UINT16( devCfg->data.power );
// 1079     buf[2] = HI_UINT16( devCfg->data.power );
// 1080     buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
// 1081     buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
// 1082     buf[5] = LO_UINT16( devCfg->data.calcPeriod );
// 1083     buf[6] = HI_UINT16( devCfg->data.calcPeriod );
// 1084     buf[7] = devCfg->data.numMeasurements;
// 1085     buf[8] = LO_UINT16( devCfg->data.reportPeriod );
// 1086     buf[9] = HI_UINT16( devCfg->data.reportPeriod );
// 1087     len += 9;
// 1088   }
// 1089 
// 1090   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1091                           COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
// 1092                           ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
// 1093 }
// 1094 
// 1095 /*********************************************************************
// 1096  * @fn      zclGeneral_SendLocationData
// 1097  *
// 1098  * @brief   Call to send out location data
// 1099  *
// 1100  * @param   srcEP - Sending application's endpoint
// 1101  * @param   dstAddr - where you want the message to go
// 1102  * @param   status - indicates whether response to request was successful or not
// 1103  * @param   locData - location information and channel parameters being sent
// 1104  *
// 1105  * @return  ZStatus_t
// 1106  */
// 1107 ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
// 1108                                        uint8 status, zclLocationData_t *locData,
// 1109                                        uint8 disableDefaultRsp, uint8 seqNum )
// 1110 {
// 1111   uint8 buf[16];
// 1112   uint8 *pBuf = buf;
// 1113   uint8 len = 0;
// 1114 
// 1115   if ( cmd == COMMAND_LOCATION_DATA_RSP )
// 1116   {
// 1117     // Only response command includes a status field
// 1118     *pBuf++ = status;
// 1119     len++;
// 1120   }
// 1121 
// 1122   if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
// 1123   {
// 1124     // Notification or Response with successful status
// 1125     *pBuf++ = locData->type;
// 1126     *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
// 1127     *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
// 1128     *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
// 1129     *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
// 1130     len += 5;
// 1131 
// 1132     if ( locationType2D(locData->type) == 0 )
// 1133     {
// 1134       // 2D location doesn't have coordinate 3
// 1135       *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
// 1136       *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
// 1137       len += 2;
// 1138     }
// 1139 
// 1140     if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 1141     {
// 1142       // Compact notification doesn't include these fields
// 1143       *pBuf++ = LO_UINT16( locData->absLoc.power );
// 1144       *pBuf++ = HI_UINT16( locData->absLoc.power );
// 1145       *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
// 1146       *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
// 1147       len += 4;
// 1148     }
// 1149 
// 1150     if ( locationTypeAbsolute(locData->type) == 0 )
// 1151     {
// 1152       // Absolute location doesn't include these fields
// 1153       if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 1154       {
// 1155         // Compact notification doesn't include this field
// 1156         *pBuf++ = locData->calcLoc.locationMethod;
// 1157         len++;
// 1158       }
// 1159 
// 1160       *pBuf++ = locData->calcLoc.qualityMeasure;
// 1161       *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
// 1162       *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
// 1163       len += 3;
// 1164     }
// 1165   }
// 1166 
// 1167   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1168                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
// 1169                           disableDefaultRsp, 0, seqNum, len, buf );
// 1170 }
// 1171 #endif // ZCL_LOCATION
// 1172 
// 1173 /*********************************************************************
// 1174  * @fn      zclGeneral_FindCallbacks
// 1175  *
// 1176  * @brief   Find the callbacks for an endpoint
// 1177  *
// 1178  * @param   endpoint - endpoint to find the application callbacks for
// 1179  *
// 1180  * @return  pointer to the callbacks
// 1181  */
// 1182 static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
// 1183 {
// 1184   zclGenCBRec_t *pCBs;
// 1185 
// 1186   pCBs = zclGenCBs;
// 1187   while ( pCBs )
// 1188   {
// 1189     if ( pCBs->endpoint == endpoint )
// 1190       return ( pCBs->CBs );
// 1191     pCBs = pCBs->next;
// 1192   }
// 1193   return ( (zclGeneral_AppCallbacks_t *)NULL );
// 1194 }
// 1195 
// 1196 /*********************************************************************
// 1197  * @fn      zclGeneral_HdlIncoming
// 1198  *
// 1199  * @brief   Callback from ZCL to process incoming Commands specific
// 1200  *          to this cluster library or Profile commands for attributes
// 1201  *          that aren't in the attribute list
// 1202  *
// 1203  *
// 1204  * @param   pInMsg - pointer to the incoming message
// 1205  *
// 1206  * @return  ZStatus_t
// 1207  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1208 static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
zclGeneral_HdlIncoming:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function zclGeneral_HdlIncoming
// 1209 {
        FUNCALL zclGeneral_HdlIncoming, zclGeneral_HdlInSpecificCommands
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1210   ZStatus_t stat = ZSuccess;
// 1211 
// 1212 #if defined ( INTER_PAN )
// 1213   if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
// 1214     return ( stat ); // Cluster not supported thru Inter-PAN
// 1215 #endif
// 1216   if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        ANL     A,#0x3
        XRL     A,#0x1
        JNZ     ??zclGeneral_HdlIncoming_0
// 1217   {
// 1218     // Is this a manufacturer specific command?
// 1219     if ( pInMsg->hdr.fc.manuSpecific == 0 )
        MOV     A,R0
        ANL     A,#0x4
        JNZ     ??zclGeneral_HdlIncoming_0
// 1220     {
// 1221       stat = zclGeneral_HdlInSpecificCommands( pInMsg );
        ; Setup parameters for call to function zclGeneral_HdlInSpecificCommands
        LCALL   ??zclGeneral_HdlInSpecificCommands?relay
        SJMP    ??zclGeneral_HdlIncoming_1
// 1222     }
// 1223     else
// 1224     {
// 1225       // We don't support any manufacturer specific command.
// 1226       stat = ZFailure;
??zclGeneral_HdlIncoming_0:
        MOV     R1,#0x1
// 1227     }
// 1228   }
// 1229   else
// 1230   {
// 1231     // Handle all the normal (Read, Write...) commands -- should never get here
// 1232     stat = ZFailure;
// 1233   }
// 1234   return ( stat );
??zclGeneral_HdlIncoming_1:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock12
// 1235 }
// 1236 
// 1237 /*********************************************************************
// 1238  * @fn      zclGeneral_HdlInSpecificCommands
// 1239  *
// 1240  * @brief   Callback from ZCL to process incoming Commands specific
// 1241  *          to this cluster library
// 1242 
// 1243  * @param   pInMsg - pointer to the incoming message
// 1244  *
// 1245  * @return  ZStatus_t
// 1246  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1247 static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
zclGeneral_HdlInSpecificCommands:
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function zclGeneral_HdlInSpecificCommands
// 1248 {
        FUNCALL zclGeneral_HdlInSpecificCommands, zclGeneral_ProcessInIdentity
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
// 1249   ZStatus_t stat;
// 1250   zclGeneral_AppCallbacks_t *pCBs;
// 1251 
// 1252   // make sure endpoint exists
// 1253   pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
        MOV     DPL,R2
        LCALL   ?Subroutine5 & 0xFFFF
??CrossCallReturnLabel_10:
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_12:
        MOV     R4,A
        MOV     DPTR,#zclGenCBs
??zclGeneral_HdlInSpecificCommands_0:
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_14:
        JNZ     ??zclGeneral_HdlInSpecificCommands_1
        MOV     A,R1
??zclGeneral_HdlInSpecificCommands_1:
        JZ      ??zclGeneral_HdlInSpecificCommands_2
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R4
        MOV     DPL,R0
        MOV     DPH,R1
        JNZ     ??zclGeneral_HdlInSpecificCommands_0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 1254   if ( pCBs == NULL )
        MOV     A,R4
        JNZ     ??zclGeneral_HdlInSpecificCommands_3
        MOV     A,R5
??zclGeneral_HdlInSpecificCommands_3:
        JZ      ??zclGeneral_HdlInSpecificCommands_2
// 1255     return ( ZFailure );
// 1256 
// 1257   switch ( pInMsg->msg->clusterId )
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_HdlInSpecificCommands_4
        MOV     A,?V0 + 0
        LCALL   ?UC_SWITCH_SPARSE
`?<Jumptable for zclGeneral_HdlInSpecificComman_0`:
        DATA
        DB        0
        DB        3
        DB        0
        DW        ??zclGeneral_HdlInSpecificCommands_5
        DB        3
        DW        ??zclGeneral_HdlInSpecificCommands_6
        DB        6
        DW        ??zclGeneral_HdlInSpecificCommands_7
        DW        ??zclGeneral_HdlInSpecificCommands_4
        CODE
// 1258   {
// 1259 #ifdef ZCL_BASIC
// 1260     case ZCL_CLUSTER_ID_GEN_BASIC:
// 1261       stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_5:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JNZ     ??zclGeneral_HdlInSpecificCommands_8
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_HdlInSpecificCommands_4
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ?Subroutine2 & 0xFFFF
??CrossCallReturnLabel_4:
        JNZ     ??zclGeneral_HdlInSpecificCommands_9
        MOV     A,DPH
??zclGeneral_HdlInSpecificCommands_9:
        JZ      ??zclGeneral_HdlInSpecificCommands_8
        ; Setup parameters for indirect call
        SJMP    ??zclGeneral_HdlInSpecificCommands_10
??zclGeneral_HdlInSpecificCommands_2:
        SJMP    ??zclGeneral_HdlInSpecificCommands_4
// 1262       break;
// 1263 #endif // ZCL_BASIC
// 1264 
// 1265 #ifdef ZCL_IDENTIFY
// 1266     case ZCL_CLUSTER_ID_GEN_IDENTIFY:
// 1267       stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_6:
        ; Setup parameters for call to function zclGeneral_ProcessInIdentity
        LCALL   ??zclGeneral_ProcessInIdentity?relay
        SJMP    ??zclGeneral_HdlInSpecificCommands_11
// 1268       break;
// 1269 #endif // ZCL_IDENTIFY
// 1270 
// 1271 #ifdef ZCL_GROUPS
// 1272     case ZCL_CLUSTER_ID_GEN_GROUPS:
// 1273       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1274         stat = zclGeneral_ProcessInGroupsServer( pInMsg );
// 1275       else
// 1276         stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
// 1277       break;
// 1278 #endif // ZCL_GROUPS
// 1279 
// 1280 #ifdef ZCL_SCENES
// 1281     case ZCL_CLUSTER_ID_GEN_SCENES:
// 1282       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1283         stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
// 1284       else
// 1285         stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
// 1286       break;
// 1287 #endif // ZCL_SCENES
// 1288 
// 1289 #ifdef ZCL_ON_OFF
// 1290     case ZCL_CLUSTER_ID_GEN_ON_OFF:
// 1291       stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_7:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JNZ     ??zclGeneral_HdlInSpecificCommands_8
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        CLR     C
        SUBB    A,#0x3
        JNC     ??zclGeneral_HdlInSpecificCommands_4
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine2 & 0xFFFF
??CrossCallReturnLabel_5:
        JNZ     ??zclGeneral_HdlInSpecificCommands_12
        MOV     A,DPH
??zclGeneral_HdlInSpecificCommands_12:
        JZ      ??zclGeneral_HdlInSpecificCommands_8
        ; Setup parameters for indirect call
        MOV     A,R2
        MOV     R1,A
??zclGeneral_HdlInSpecificCommands_10:
        LCALL   ?CALL_IND
??zclGeneral_HdlInSpecificCommands_8:
        MOV     R1,#0x0
        SJMP    ??zclGeneral_HdlInSpecificCommands_11
// 1292       break;
// 1293 #endif // ZCL_ON_OFF
// 1294 
// 1295 #ifdef ZCL_LEVEL_CTRL
// 1296     case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
// 1297       stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
// 1298       break;
// 1299 #endif // ZCL_LEVEL_CTRL
// 1300 
// 1301 #ifdef ZCL_ALARMS
// 1302     case ZCL_CLUSTER_ID_GEN_ALARMS:
// 1303       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1304         stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
// 1305       else
// 1306         stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
// 1307       break;
// 1308 #endif // ZCL_ALARMS
// 1309 
// 1310 #ifdef ZCL_LOCATION
// 1311     case ZCL_CLUSTER_ID_GEN_LOCATION:
// 1312       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1313         stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
// 1314       else
// 1315         stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
// 1316       break;
// 1317 #endif // ZCL_LOCATION
// 1318 
// 1319     case ZCL_CLUSTER_ID_GEN_POWER_CFG:
// 1320     case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
// 1321     case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
// 1322     case ZCL_CLUSTER_ID_GEN_TIME:
// 1323     default:
// 1324       stat = ZFailure;
??zclGeneral_HdlInSpecificCommands_4:
        MOV     R1,#0x1
// 1325       break;
// 1326   }
// 1327 
// 1328   return ( stat );
??zclGeneral_HdlInSpecificCommands_11:
        LJMP    ??Subroutine11_0 & 0xFFFF
        CFI EndBlock cfiBlock13
// 1329 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine2:
        CFI Block cfiCond14 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_4
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond15 Using cfiCommon0
        CFI (cfiCond15) NoFunction
        CFI (cfiCond15) Conditional ??CrossCallReturnLabel_5
        CFI (cfiCond15) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond15) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond15) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond15) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond15) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond15) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond15) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond15) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond15) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond15) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond15) CFA_SP SP+0
        CFI (cfiCond15) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiPicker16 Using cfiCommon1
        CFI (cfiPicker16) NoFunction
        CFI (cfiPicker16) Picker
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_18:
        MOV     A,DPL
        RET
        CFI EndBlock cfiCond14
        CFI EndBlock cfiCond15
        CFI EndBlock cfiPicker16
// 1330 
// 1331 #ifdef ZCL_BASIC
// 1332 /*********************************************************************
// 1333  * @fn      zclGeneral_ProcessInBasic
// 1334  *
// 1335  * @brief   Process in the received Basic Command.
// 1336  *
// 1337  * @param   pInMsg - pointer to the incoming message
// 1338  *
// 1339  * @return  ZStatus_t
// 1340  */
// 1341 static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
// 1342                                             zclGeneral_AppCallbacks_t *pCBs )
// 1343 {
// 1344   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1345   {
// 1346     if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
// 1347       return ( ZFailure );   // Error ignore the command
// 1348 
// 1349     if ( pCBs->pfnBasicReset )
// 1350       pCBs->pfnBasicReset();
// 1351   }
// 1352   // no Client command
// 1353 
// 1354   return ( ZSuccess );
// 1355 }
// 1356 #endif // ZCL_BASIC
// 1357 
// 1358 #ifdef ZCL_IDENTIFY
// 1359 /*********************************************************************
// 1360  * @fn      zclGeneral_ProcessInIdentity
// 1361  *
// 1362  * @brief   Process in the received Identity Command.
// 1363  *
// 1364  * @param   pInMsg - pointer to the incoming message
// 1365  *
// 1366  * @return  ZStatus_t
// 1367  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1368 static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
zclGeneral_ProcessInIdentity:
        CFI Block cfiBlock17 Using cfiCommon0
        CFI Function zclGeneral_ProcessInIdentity
// 1369                                                zclGeneral_AppCallbacks_t *pCBs )
// 1370 {
        FUNCALL zclGeneral_ProcessInIdentity, zclFindAttrRec
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclGeneral_ProcessInIdentity, zclReadAttrData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclGeneral_ProcessInIdentity, zclGeneral_SendIdentifyQueryResponse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 14
        MOV     A,#-0xe
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
// 1371   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,?V0 + 0
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JZ      $+5
        LJMP    ??zclGeneral_ProcessInIdentity_0 & 0xFFFF
// 1372   {
// 1373     if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY )
        MOV     A,R2
        CLR     C
        SUBB    A,#0x2
        JC      ??zclGeneral_ProcessInIdentity_1
// 1374       return ( ZFailure );   // Error ignore the command
??zclGeneral_ProcessInIdentity_2:
        MOV     R1,#0x1
        LJMP    ??zclGeneral_ProcessInIdentity_3 & 0xFFFF
// 1375 
// 1376     if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
??zclGeneral_ProcessInIdentity_1:
        MOV     A,R2
        JNZ     ??zclGeneral_ProcessInIdentity_4
// 1377     {
// 1378       if ( pCBs->pfnIdentify )
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ?Subroutine4 & 0xFFFF
// 1379       {
// 1380         zclIdentify_t cmd;
// 1381 
// 1382         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 1383         cmd.identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
// 1384 
// 1385         pCBs->pfnIdentify( &cmd );
// 1386       }
// 1387     }
??CrossCallReturnLabel_8:
        JNZ     ??zclGeneral_ProcessInIdentity_5
        MOV     A,R5
??zclGeneral_ProcessInIdentity_5:
        LJMP    ??zclGeneral_ProcessInIdentity_6 & 0xFFFF
// 1388     else
// 1389     {
// 1390       zclAttrRec_t attrRec;
// 1391       uint16 identifyTime = 0;
??zclGeneral_ProcessInIdentity_4:
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
// 1392 
// 1393       // Retrieve Identify Time
// 1394       if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, ATTRID_IDENTIFY_TIME, &attrRec ) )
        MOV     DPL,?V0 + 0
        LCALL   ?Subroutine5 & 0xFFFF
??CrossCallReturnLabel_11:
        ; Setup parameters for call to function zclFindAttrRec
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 28)
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        LCALL   ?Subroutine3 & 0xFFFF
??CrossCallReturnLabel_6:
        LCALL   ??zclFindAttrRec?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
        MOV     A,R1
        JZ      ??zclGeneral_ProcessInIdentity_7
// 1395         zclReadAttrData( (uint8 *)&identifyTime, &attrRec );
        ; Setup parameters for call to function zclReadAttrData
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??zclReadAttrData?relay
// 1396 
// 1397       // Is device identifying itself?
// 1398       if ( identifyTime > 0 )
??zclGeneral_ProcessInIdentity_7:
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_ProcessInIdentity_8
        INC     DPTR
        MOVX    A,@DPTR
??zclGeneral_ProcessInIdentity_8:
        JZ      ??zclGeneral_ProcessInIdentity_9
// 1399       {
// 1400         zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1401                                               identifyTime, true, pInMsg->hdr.transSeqNum );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        ; Setup parameters for call to function zclGeneral_SendIdentifyQueryResponse
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 27)
        MOV     ?V0 + 0,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R6
        ADD     A,#0x6
        MOV     R2,A
        MOV     A,R7
        ADDC    A,#0x0
        LCALL   ?Subroutine3 & 0xFFFF
// 1402       }
??CrossCallReturnLabel_7:
        LCALL   ??zclGeneral_SendIdentifyQueryResponse?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
// 1403 
// 1404       return ( ZCL_STATUS_CMD_HAS_RSP );
??zclGeneral_ProcessInIdentity_9:
        MOV     R1,#-0x1
        SJMP    ??zclGeneral_ProcessInIdentity_3
// 1405     }
// 1406   }
// 1407   else // Client Command
// 1408   {
// 1409     if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
??zclGeneral_ProcessInIdentity_0:
        MOV     A,R2
        JZ      $+5
        LJMP    ??zclGeneral_ProcessInIdentity_2 & 0xFFFF
// 1410       return ( ZFailure );   // Error ignore the command
// 1411 
// 1412     if ( pCBs->pfnIdentifyQueryRsp )
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine4 & 0xFFFF
??CrossCallReturnLabel_9:
        JNZ     ??zclGeneral_ProcessInIdentity_6
        MOV     A,R5
??zclGeneral_ProcessInIdentity_6:
        JZ      ??zclGeneral_ProcessInIdentity_10
// 1413     {
// 1414       zclIdentifyQueryRsp_t rsp;
// 1415 
// 1416       rsp.srcAddr = &(pInMsg->msg->srcAddr);
        MOV     DPL,?V0 + 0
        MOV     DPH,R3
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1417       rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
        MOV     DPL,?V0 + 0
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_17:
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R2
        MOV     R0,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1418 
// 1419       pCBs->pfnIdentifyQueryRsp( &rsp );
        ; Setup parameters for indirect call
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ?CALL_IND
// 1420     }
// 1421   }
// 1422 
// 1423   return ( ZSuccess );
??zclGeneral_ProcessInIdentity_10:
        MOV     R1,#0x0
??zclGeneral_ProcessInIdentity_3:
        MOV     A,#0xe
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        LJMP    ?Subroutine9 & 0xFFFF
        CFI EndBlock cfiBlock17
// 1424 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine8:
        CFI Block cfiCond18 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_18, ??CrossCallReturnLabel_4
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond19 Using cfiCommon0
        CFI (cfiCond19) NoFunction
        CFI (cfiCond19) Conditional ??CrossCallReturnLabel_18, ??CrossCallReturnLabel_5
        CFI (cfiCond19) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond19) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond19) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond19) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond19) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond19) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond19) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond19) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond19) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond19) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond19) CFA_SP SP+0
        CFI (cfiCond19) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond20 Using cfiCommon0
        CFI (cfiCond20) NoFunction
        CFI (cfiCond20) Conditional ??CrossCallReturnLabel_17
        CFI (cfiCond20) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond20) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond20) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond20) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond20) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond20) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond20) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond20) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond20) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond20) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond20) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond20) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond20) CFA_SP SP+0
        CFI (cfiCond20) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker21 Using cfiCommon1
        CFI (cfiPicker21) NoFunction
        CFI (cfiPicker21) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        RET
        CFI EndBlock cfiCond18
        CFI EndBlock cfiCond19
        CFI EndBlock cfiCond20
        CFI EndBlock cfiPicker21

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine5:
        CFI Block cfiCond22 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_10
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond23 Using cfiCommon0
        CFI (cfiCond23) NoFunction
        CFI (cfiCond23) Conditional ??CrossCallReturnLabel_11
        CFI (cfiCond23) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond23) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond23) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond23) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond23) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond23) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond23) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond23) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond23) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond23) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond23) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond23) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond23) CFA_SP SP+0
        CFI (cfiCond23) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker24 Using cfiCommon1
        CFI (cfiPicker24) NoFunction
        CFI (cfiPicker24) Picker
        MOV     DPH,R3
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_16:
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
        RET
        CFI EndBlock cfiCond22
        CFI EndBlock cfiCond23
        CFI EndBlock cfiPicker24

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine7:
        CFI Block cfiCond25 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_14
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond26 Using cfiCommon0
        CFI (cfiCond26) NoFunction
        CFI (cfiCond26) Conditional ??CrossCallReturnLabel_16, ??CrossCallReturnLabel_10
        CFI (cfiCond26) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond26) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond26) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond26) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond26) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond26) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond26) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond26) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond26) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond26) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond26) CFA_SP SP+0
        CFI (cfiCond26) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond27 Using cfiCommon0
        CFI (cfiCond27) NoFunction
        CFI (cfiCond27) Conditional ??CrossCallReturnLabel_16, ??CrossCallReturnLabel_11
        CFI (cfiCond27) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond27) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond27) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond27) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond27) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond27) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond27) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond27) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond27) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond27) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond27) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond27) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond27) CFA_SP SP+0
        CFI (cfiCond27) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiCond28 Using cfiCommon0
        CFI (cfiCond28) NoFunction
        CFI (cfiCond28) Conditional ??CrossCallReturnLabel_15, ??CrossCallReturnLabel_8
        CFI (cfiCond28) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond28) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond28) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond28) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond28) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond28) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond28) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond28) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond28) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond28) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond28) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond28) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond28) CFA_SP SP+0
        CFI (cfiCond28) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiCond29 Using cfiCommon0
        CFI (cfiCond29) NoFunction
        CFI (cfiCond29) Conditional ??CrossCallReturnLabel_15, ??CrossCallReturnLabel_9
        CFI (cfiCond29) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond29) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond29) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond29) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond29) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond29) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond29) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond29) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond29) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond29) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond29) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond29) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond29) CFA_SP SP+0
        CFI (cfiCond29) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker30 Using cfiCommon1
        CFI (cfiPicker30) NoFunction
        CFI (cfiPicker30) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        RET
        CFI EndBlock cfiCond25
        CFI EndBlock cfiCond26
        CFI EndBlock cfiCond27
        CFI EndBlock cfiCond28
        CFI EndBlock cfiCond29
        CFI EndBlock cfiPicker30

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine4:
        CFI Block cfiCond31 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_8
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 26)
        CFI Block cfiCond32 Using cfiCommon0
        CFI (cfiCond32) NoFunction
        CFI (cfiCond32) Conditional ??CrossCallReturnLabel_9
        CFI (cfiCond32) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond32) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond32) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond32) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond32) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond32) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond32) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond32) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond32) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond32) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond32) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond32) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond32) CFA_SP SP+0
        CFI (cfiCond32) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker33 Using cfiCommon1
        CFI (cfiPicker33) NoFunction
        CFI (cfiPicker33) Picker
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_15:
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
        MOV     A,R4
        RET
        CFI EndBlock cfiCond31
        CFI EndBlock cfiCond32
        CFI EndBlock cfiPicker33

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine3:
        CFI Block cfiCond34 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_6
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 28)
        CFI Block cfiCond35 Using cfiCommon0
        CFI (cfiCond35) NoFunction
        CFI (cfiCond35) Conditional ??CrossCallReturnLabel_7
        CFI (cfiCond35) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond35) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond35) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond35) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond35) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond35) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond35) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond35) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond35) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond35) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond35) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond35) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond35) CFA_SP SP+0
        CFI (cfiCond35) CFA_XSP16 add(XSP16, 28)
        CFI Block cfiPicker36 Using cfiCommon1
        CFI (cfiPicker36) NoFunction
        CFI (cfiPicker36) Picker
        MOV     R3,A
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_13:
        MOV     R1,A
        RET
        CFI EndBlock cfiCond34
        CFI EndBlock cfiCond35
        CFI EndBlock cfiPicker36

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine6:
        CFI Block cfiCond37 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_12
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond38 Using cfiCommon0
        CFI (cfiCond38) NoFunction
        CFI (cfiCond38) Conditional ??CrossCallReturnLabel_13, ??CrossCallReturnLabel_6
        CFI (cfiCond38) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond38) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond38) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond38) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond38) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond38) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond38) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond38) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond38) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond38) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond38) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond38) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond38) CFA_SP SP+0
        CFI (cfiCond38) CFA_XSP16 add(XSP16, 28)
        CFI Block cfiCond39 Using cfiCommon0
        CFI (cfiCond39) NoFunction
        CFI (cfiCond39) Conditional ??CrossCallReturnLabel_13, ??CrossCallReturnLabel_7
        CFI (cfiCond39) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond39) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond39) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond39) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond39) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond39) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond39) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond39) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond39) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond39) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond39) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond39) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond39) CFA_SP SP+0
        CFI (cfiCond39) CFA_XSP16 add(XSP16, 28)
        CFI Block cfiPicker40 Using cfiCommon1
        CFI (cfiPicker40) NoFunction
        CFI (cfiPicker40) Picker
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        RET
        CFI EndBlock cfiCond37
        CFI EndBlock cfiCond38
        CFI EndBlock cfiCond39
        CFI EndBlock cfiPicker40

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_RegisterCmdCallbacks?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_RegisterCmdCallbacks

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_SendIdentify?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_SendIdentify

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_SendIdentifyQueryResponse?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_SendIdentifyQueryResponse

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_HdlIncoming?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_HdlIncoming

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_HdlInSpecificCommands?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_HdlInSpecificCommands

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_ProcessInIdentity?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_ProcessInIdentity

        END
// 1425 #endif // ZCL_IDENTIFY
// 1426 
// 1427 #ifdef ZCL_GROUPS
// 1428 
// 1429 /*********************************************************************
// 1430  * @fn      zclGeneral_AddGroup
// 1431  *
// 1432  * @brief   Add a Group.
// 1433  *
// 1434  * @param   endPoint - application endpoint
// 1435  * @param   group - group to be added
// 1436  * @param   pData - pointer to the group info
// 1437  *
// 1438  * @return  ZStatus_t
// 1439  */
// 1440 static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
// 1441 {
// 1442   zclAttrRec_t attrRec;
// 1443   uint8 nameLen;
// 1444   uint8 nameSupport = FALSE;
// 1445 
// 1446   pData += 2;   // Move past group ID
// 1447   nameLen = *pData++;
// 1448 
// 1449   // Retrieve Name Support attribute
// 1450   if ( zclFindAttrRec( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS, ATTRID_GROUP_NAME_SUPPORT, &attrRec ) )
// 1451      zclReadAttrData( &nameSupport, &attrRec );
// 1452 
// 1453   if ( nameSupport )
// 1454   {
// 1455     if ( nameLen > (APS_GROUP_NAME_LEN-1) )
// 1456        nameLen = (APS_GROUP_NAME_LEN-1);
// 1457     group->name[0] = nameLen;
// 1458     osal_memcpy( &(group->name[1]), pData, nameLen );
// 1459   }
// 1460 
// 1461   return ( aps_AddGroup( endPoint, group ) );
// 1462 }
// 1463 
// 1464 /*********************************************************************
// 1465  * @fn      zclGeneral_ProcessInGroupsServer
// 1466  *
// 1467  * @brief   Process in the received Groups Command.
// 1468  *
// 1469  * @param   pInMsg - pointer to the incoming message
// 1470  *
// 1471  * @return  ZStatus_t
// 1472  */
// 1473 static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
// 1474 {
// 1475   zclAttrRec_t attrRec;
// 1476   aps_Group_t group;
// 1477   aps_Group_t *pGroup;
// 1478   uint8 *pData;
// 1479   uint8 status;
// 1480   uint8 grpCnt;
// 1481   uint8 grpRspCnt = 0;
// 1482   uint16 *grpList;
// 1483   uint16 identifyTime = 0;
// 1484   uint8 i;
// 1485   ZStatus_t stat = ZSuccess;
// 1486 
// 1487   osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
// 1488 
// 1489   pData = pInMsg->pData;
// 1490   group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1491   switch ( pInMsg->hdr.commandID )
// 1492   {
// 1493     case COMMAND_GROUP_ADD:
// 1494       status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
// 1495       if ( status != ZSuccess )
// 1496       {
// 1497         if ( status == ZApsDuplicateEntry )
// 1498           status = ZCL_STATUS_DUPLICATE_EXISTS;
// 1499         else
// 1500           status = ZCL_STATUS_INSUFFICIENT_SPACE;
// 1501       }
// 1502 
// 1503       zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1504                                        status, group.ID, true, pInMsg->hdr.transSeqNum );
// 1505       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1506       break;
// 1507 
// 1508     case COMMAND_GROUP_VIEW:
// 1509       pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
// 1510       if ( pGroup )
// 1511       {
// 1512         status = ZCL_STATUS_SUCCESS;
// 1513       }
// 1514       else
// 1515       {
// 1516         // Group not found
// 1517         status = ZCL_STATUS_NOT_FOUND;
// 1518         pGroup = &group;
// 1519       }
// 1520       zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1521                                         status, pGroup, true, pInMsg->hdr.transSeqNum );
// 1522       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1523       break;
// 1524 
// 1525     case COMMAND_GROUP_GET_MEMBERSHIP:
// 1526       grpCnt = *pData++;
// 1527         
// 1528       // Allocate space for the group list
// 1529       grpList = osal_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
// 1530       if ( grpList != NULL )
// 1531       {
// 1532         if ( grpCnt == 0 )
// 1533         {
// 1534           // Find out all the groups of which the endpoint is a member.
// 1535           grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
// 1536         }
// 1537         else
// 1538         {
// 1539           // Find out the groups (in the list) of which the endpoint is a member.
// 1540           for ( i = 0; i < grpCnt; i++ )
// 1541           {
// 1542             group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1543             pData += 2;
// 1544 
// 1545             if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
// 1546               grpList[grpRspCnt++] = group.ID;
// 1547           }
// 1548         }
// 1549       
// 1550         if ( grpCnt == 0 ||  grpRspCnt != 0 )
// 1551         {
// 1552           zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr, 
// 1553                                                      aps_GroupsRemaingCapacity(), grpRspCnt, 
// 1554                                                      grpList, true, pInMsg->hdr.transSeqNum );
// 1555         }
// 1556 
// 1557         osal_mem_free( grpList );
// 1558       }
// 1559       else
// 1560       {
// 1561         // Couldn't allocate space for the group list -- send a Default Response command back.
// 1562         zclDefaultRspCmd_t defaultRspCmd;
// 1563         
// 1564         defaultRspCmd.commandID = pInMsg->hdr.commandID;
// 1565         defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
// 1566         zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 1567                                pInMsg->msg->clusterId, &defaultRspCmd,
// 1568                                ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
// 1569       }
// 1570 
// 1571       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1572       break;
// 1573 
// 1574     case COMMAND_GROUP_REMOVE:
// 1575       if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
// 1576         status = ZCL_STATUS_SUCCESS;
// 1577       else
// 1578         status = ZCL_STATUS_NOT_FOUND;
// 1579       zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1580                                           status, group.ID, true, pInMsg->hdr.transSeqNum );
// 1581       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1582       break;
// 1583 
// 1584     case COMMAND_GROUP_REMOVE_ALL:
// 1585       aps_RemoveAllGroup( pInMsg->msg->endPoint );
// 1586       break;
// 1587 
// 1588     case COMMAND_GROUP_ADD_IF_IDENTIFYING:
// 1589       // Retrieve Identify Time
// 1590       if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY, ATTRID_IDENTIFY_TIME, &attrRec ) )
// 1591         zclReadAttrData( (uint8 *)&identifyTime, &attrRec );
// 1592 
// 1593       // Is device identifying itself?
// 1594       if ( identifyTime > 0 )
// 1595         zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
// 1596       break;
// 1597 
// 1598     default:
// 1599       stat = ZFailure;
// 1600       break;
// 1601   }
// 1602 
// 1603   return ( stat );
// 1604 }
// 1605 
// 1606 /*********************************************************************
// 1607  * @fn      zclGeneral_ProcessInGroupsClient
// 1608  *
// 1609  * @brief   Process in the received Groups Command.
// 1610  *
// 1611  * @param   pInMsg - pointer to the incoming message
// 1612  *
// 1613  * @return  ZStatus_t
// 1614  */
// 1615 static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
// 1616                                                    zclGeneral_AppCallbacks_t *pCBs )
// 1617 {
// 1618   aps_Group_t group;
// 1619   uint8 *pData = pInMsg->pData;
// 1620   uint16 *grpList;
// 1621   uint8 grpCnt;
// 1622   uint8 nameLen;
// 1623   zclGroupRsp_t rsp;
// 1624   uint8 i;
// 1625   ZStatus_t stat = ZSuccess;
// 1626 
// 1627   osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
// 1628   osal_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
// 1629 
// 1630   switch ( pInMsg->hdr.commandID )
// 1631   {
// 1632     case COMMAND_GROUP_ADD_RSP:
// 1633     case COMMAND_GROUP_VIEW_RSP:
// 1634     case COMMAND_GROUP_REMOVE_RSP:
// 1635       rsp.status = *pData++;
// 1636       group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1637 
// 1638       if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
// 1639       {
// 1640         pData += 2;   // Move past ID
// 1641         nameLen = *pData++;
// 1642         if ( nameLen > (APS_GROUP_NAME_LEN-1) )
// 1643           nameLen = (APS_GROUP_NAME_LEN-1);
// 1644         group.name[0] = nameLen;
// 1645         osal_memcpy( &(group.name[1]), pData, nameLen );
// 1646         rsp.grpName = group.name;
// 1647       }
// 1648 
// 1649       if ( pCBs->pfnGroupRsp )
// 1650       {
// 1651         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 1652         rsp.cmdID = pInMsg->hdr.commandID;
// 1653         rsp.grpCnt = 1;
// 1654         rsp.grpList = &group.ID;
// 1655         rsp.capacity = 0;
// 1656 
// 1657         pCBs->pfnGroupRsp( &rsp );
// 1658       }
// 1659       break;
// 1660 
// 1661     case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
// 1662       rsp.capacity = *pData++;
// 1663       grpCnt = *pData++;
// 1664 
// 1665       if ( grpCnt > 0 )
// 1666       {
// 1667         // Allocate space for the group list
// 1668         grpList = osal_mem_alloc( sizeof( uint16 ) * grpCnt );
// 1669         if ( grpList != NULL )
// 1670         {
// 1671           rsp.grpCnt = grpCnt;
// 1672           for ( i = 0; i < grpCnt; i++ )
// 1673           {
// 1674             grpList[i] = BUILD_UINT16( pData[0], pData[1] );
// 1675             pData += 2;
// 1676           }
// 1677         }
// 1678       }
// 1679 
// 1680       if ( pCBs->pfnGroupRsp )
// 1681       {
// 1682         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 1683         rsp.cmdID = pInMsg->hdr.commandID;
// 1684         rsp.grpList = grpList;
// 1685 
// 1686         pCBs->pfnGroupRsp( &rsp );
// 1687       }
// 1688       
// 1689       if ( grpList != NULL )
// 1690         osal_mem_free( grpList );
// 1691       break;
// 1692 
// 1693     default:
// 1694       stat = ZFailure;
// 1695       break;
// 1696   }
// 1697 
// 1698   return ( stat );
// 1699 }
// 1700 #endif // ZCL_GROUPS
// 1701 
// 1702 #ifdef ZCL_SCENES
// 1703 /*********************************************************************
// 1704  * @fn      zclGeneral_AddScene
// 1705  *
// 1706  * @brief   Add a scene for an endpoint
// 1707  *
// 1708  * @param   endpoint -
// 1709  * @param   scene - new scene item
// 1710  *
// 1711  * @return  ZStatus_t
// 1712  */
// 1713 ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
// 1714 {
// 1715   zclGenSceneItem_t *pNewItem;
// 1716   zclGenSceneItem_t *pLoop;
// 1717 
// 1718   // Fill in the new profile list
// 1719   pNewItem = osal_mem_alloc( sizeof( zclGenSceneItem_t ) );
// 1720   if ( pNewItem == NULL )
// 1721     return ( ZMemError );
// 1722 
// 1723   // Fill in the plugin record.
// 1724   pNewItem->next = (zclGenSceneItem_t *)NULL;
// 1725   pNewItem->endpoint = endpoint;
// 1726   osal_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
// 1727 
// 1728   // Find spot in list
// 1729   if (  zclGenSceneTable == NULL )
// 1730   {
// 1731     zclGenSceneTable = pNewItem;
// 1732   }
// 1733   else
// 1734   {
// 1735     // Look for end of list
// 1736     pLoop = zclGenSceneTable;
// 1737     while ( pLoop->next != NULL )
// 1738       pLoop = pLoop->next;
// 1739 
// 1740     // Put new item at end of list
// 1741     pLoop->next = pNewItem;
// 1742   }
// 1743 
// 1744   // Update NV
// 1745   zclGeneral_ScenesWriteNV();
// 1746 
// 1747   return ( ZSuccess );
// 1748 }
// 1749 
// 1750 /*********************************************************************
// 1751  * @fn      zclGeneral_FindScene
// 1752  *
// 1753  * @brief   Find a scene with endpoint and sceneID
// 1754  *
// 1755  * @param   endpoint -
// 1756  * @param   groupID - what group the scene belongs to
// 1757  * @param   sceneID - ID to look for scene
// 1758  *
// 1759  * @return  a pointer to the scene information, NULL if not found
// 1760  */
// 1761 zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
// 1762 {
// 1763   zclGenSceneItem_t *pLoop;
// 1764 
// 1765   // Look for end of list
// 1766   pLoop = zclGenSceneTable;
// 1767   while ( pLoop )
// 1768   {
// 1769     if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
// 1770         && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
// 1771     {
// 1772       return ( &(pLoop->scene) );
// 1773     }
// 1774     pLoop = pLoop->next;
// 1775   }
// 1776 
// 1777   return ( (zclGeneral_Scene_t *)NULL );
// 1778 }
// 1779 
// 1780 /*********************************************************************
// 1781  * @fn      aps_FindAllScensForGroup
// 1782  *
// 1783  * @brief   Find all the scenes with groupID
// 1784  *
// 1785  * @param   endpoint - endpoint to look for
// 1786  * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
// 1787  *
// 1788  * @return  number of scenes copied to sceneList
// 1789  */
// 1790 uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
// 1791 {
// 1792   zclGenSceneItem_t *pLoop;
// 1793   uint8 cnt = 0;
// 1794 
// 1795   // Look for end of list
// 1796   pLoop = zclGenSceneTable;
// 1797   while ( pLoop )
// 1798   {
// 1799     if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
// 1800       sceneList[cnt++] = pLoop->scene.ID;
// 1801     pLoop = pLoop->next;
// 1802   }
// 1803   return ( cnt );
// 1804 }
// 1805 
// 1806 /*********************************************************************
// 1807  * @fn      zclGeneral_RemoveScene
// 1808  *
// 1809  * @brief   Remove a scene with endpoint and sceneID
// 1810  *
// 1811  * @param   endpoint -
// 1812  * @param   groupID - what group the scene belongs to
// 1813  * @param   sceneID - ID to look for scene
// 1814  *
// 1815  * @return  TRUE if removed, FALSE if not found
// 1816  */
// 1817 uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
// 1818 {
// 1819   zclGenSceneItem_t *pLoop;
// 1820   zclGenSceneItem_t *pPrev;
// 1821 
// 1822   // Look for end of list
// 1823   pLoop = zclGenSceneTable;
// 1824   pPrev = NULL;
// 1825   while ( pLoop )
// 1826   {
// 1827     if ( pLoop->endpoint == endpoint
// 1828         && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
// 1829     {
// 1830       if ( pPrev == NULL )
// 1831         zclGenSceneTable = pLoop->next;
// 1832       else
// 1833         pPrev->next = pLoop->next;
// 1834 
// 1835       // Free the memory
// 1836       osal_mem_free( pLoop );
// 1837 
// 1838       // Update NV
// 1839       zclGeneral_ScenesWriteNV();
// 1840 
// 1841       return ( TRUE );
// 1842     }
// 1843     pPrev = pLoop;
// 1844     pLoop = pLoop->next;
// 1845   }
// 1846 
// 1847   return ( FALSE );
// 1848 }
// 1849 
// 1850 /*********************************************************************
// 1851  * @fn      zclGeneral_RemoveAllScenes
// 1852  *
// 1853  * @brief   Remove all scenes with endpoint and group Id
// 1854  *
// 1855  * @param   endpoint -
// 1856  * @param   groupID - ID to look for group
// 1857  *
// 1858  * @return  none
// 1859  */
// 1860 void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
// 1861 {
// 1862   zclGenSceneItem_t *pLoop;
// 1863   zclGenSceneItem_t *pPrev;
// 1864   zclGenSceneItem_t *pNext;
// 1865 
// 1866   // Look for end of list
// 1867   pLoop = zclGenSceneTable;
// 1868   pPrev = NULL;
// 1869   while ( pLoop )
// 1870   {
// 1871     if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
// 1872     {
// 1873       if ( pPrev == NULL )
// 1874         zclGenSceneTable = pLoop->next;
// 1875       else
// 1876         pPrev->next = pLoop->next;
// 1877       pNext = pLoop->next;
// 1878 
// 1879       // Free the memory
// 1880       osal_mem_free( pLoop );
// 1881       pLoop = pNext;
// 1882     }
// 1883     else
// 1884     {
// 1885       pPrev = pLoop;
// 1886       pLoop = pLoop->next;
// 1887     }
// 1888   }
// 1889 
// 1890   // Update NV
// 1891   zclGeneral_ScenesWriteNV();
// 1892 }
// 1893 
// 1894 /*********************************************************************
// 1895  * @fn      zclGeneral_CountScenes
// 1896  *
// 1897  * @brief   Count the number of scenes for an endpoint
// 1898  *
// 1899  * @param   endpoint -
// 1900  *
// 1901  * @return  number of scenes assigned to an endpoint
// 1902  */
// 1903 uint8 zclGeneral_CountScenes( uint8 endpoint )
// 1904 {
// 1905   zclGenSceneItem_t *pLoop;
// 1906   uint8 cnt = 0;
// 1907 
// 1908   // Look for end of list
// 1909   pLoop = zclGenSceneTable;
// 1910   while ( pLoop )
// 1911   {
// 1912     if ( pLoop->endpoint == endpoint  )
// 1913       cnt++;
// 1914     pLoop = pLoop->next;
// 1915   }
// 1916   return ( cnt );
// 1917 }
// 1918 
// 1919 /*********************************************************************
// 1920  * @fn      zclGeneral_CountAllScenes
// 1921  *
// 1922  * @brief   Count the total number of scenes
// 1923  *
// 1924  * @param   none
// 1925  *
// 1926  * @return  number of scenes
// 1927  */
// 1928 uint8 zclGeneral_CountAllScenes( void )
// 1929 {
// 1930   zclGenSceneItem_t *pLoop;
// 1931   uint8 cnt = 0;
// 1932 
// 1933   // Look for end of list
// 1934   pLoop = zclGenSceneTable;
// 1935   while ( pLoop )
// 1936   {
// 1937     cnt++;
// 1938     pLoop = pLoop->next;
// 1939   }
// 1940   return ( cnt );
// 1941 }
// 1942 
// 1943 /*********************************************************************
// 1944  * @fn      zclGeneral_ProcessInScenesServer
// 1945  *
// 1946  * @brief   Process in the received Scenes Command.
// 1947  *
// 1948  * @param   pInMsg - pointer to the incoming message
// 1949  *
// 1950  * @return  ZStatus_t
// 1951  */
// 1952 static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
// 1953                                                    zclGeneral_AppCallbacks_t *pCBs )
// 1954 {
// 1955   zclAttrRec_t attrRec;
// 1956   zclGeneral_Scene_t scene;
// 1957   zclGeneral_Scene_t *pScene;
// 1958   uint8 *pData = pInMsg->pData;
// 1959   uint8 nameLen;
// 1960   uint8 status;
// 1961   uint8 sceneCnt = 0;
// 1962   uint8 *sceneList = NULL;
// 1963   uint8 sendRsp = FALSE;
// 1964   uint8 nameSupport = FALSE;
// 1965   ZStatus_t stat = ZSuccess;
// 1966 
// 1967   osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
// 1968 
// 1969   scene.groupID = BUILD_UINT16( pData[0], pData[1] );
// 1970   pData += 2;   // Move past group ID
// 1971   scene.ID = *pData++;
// 1972 
// 1973   switch ( pInMsg->hdr.commandID )
// 1974   {
// 1975     case COMMAND_SCENE_ADD:
// 1976       // Parse the rest of the incoming message
// 1977       scene.transTime = BUILD_UINT16( pData[0], pData[1] );
// 1978       pData += 2;
// 1979       nameLen= *pData++; // Name length
// 1980 
// 1981       // Retrieve Name Support attribute
// 1982       if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES, ATTRID_SCENES_NAME_SUPPORT, &attrRec ) )
// 1983         zclReadAttrData( &nameSupport, &attrRec );
// 1984 
// 1985       if ( nameSupport )
// 1986       {
// 1987         if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
// 1988           nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
// 1989         scene.name[0] = nameLen;
// 1990         osal_memcpy( &(scene.name[1]), pData, nameLen );
// 1991       }
// 1992 
// 1993       pData += nameLen; // move pass name
// 1994 
// 1995       scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
// 1996       if ( scene.extLen > 0 )
// 1997       {
// 1998         // Copy the extention field(s)
// 1999         if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
// 2000           scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
// 2001         osal_memcpy( scene.extField, pData, scene.extLen );
// 2002       }
// 2003 
// 2004       if ( scene.groupID == 0x0000 ||
// 2005            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2006       {
// 2007         // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
// 2008         // does and the corresponding Group exits
// 2009         pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2010         if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
// 2011         {
// 2012           status = ZCL_STATUS_SUCCESS;
// 2013           if ( pScene != NULL )
// 2014           {
// 2015             // The Scene already exists so update it
// 2016             pScene->transTime = scene.transTime;
// 2017             osal_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
// 2018 
// 2019             // Use the new extention field(s)
// 2020             osal_memcpy( pScene->extField, scene.extField, scene.extLen );
// 2021             pScene->extLen = scene.extLen;
// 2022 
// 2023             // Update NV
// 2024             zclGeneral_ScenesWriteNV();
// 2025           }
// 2026           else
// 2027           {
// 2028             // The Scene doesn't exist so add it
// 2029             zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
// 2030           }
// 2031         }
// 2032         else
// 2033           status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
// 2034       }
// 2035       else
// 2036         status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2037 
// 2038       zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2039                                        status, scene.groupID, scene.ID,
// 2040                                        true, pInMsg->hdr.transSeqNum );
// 2041       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2042       break;
// 2043 
// 2044     case COMMAND_SCENE_VIEW:
// 2045       pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2046       if ( pScene != NULL )
// 2047       {
// 2048         status = ZCL_STATUS_SUCCESS;
// 2049       }
// 2050       else
// 2051       {
// 2052         // Scene not found
// 2053         if ( scene.groupID != 0x0000 &&
// 2054              aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
// 2055         {
// 2056           status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2057         }
// 2058         else
// 2059           status = ZCL_STATUS_NOT_FOUND;
// 2060         pScene = &scene;
// 2061       }
// 2062       zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2063                                         status, pScene, true, pInMsg->hdr.transSeqNum );
// 2064       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2065       break;
// 2066 
// 2067     case COMMAND_SCENE_REMOVE:
// 2068       if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
// 2069       {
// 2070         status = ZCL_STATUS_SUCCESS;
// 2071       }
// 2072       else
// 2073       {
// 2074         // Scene not found
// 2075         if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
// 2076         {
// 2077           // The Group is not in the Group Table
// 2078           status = ZCL_STATUS_INVALID_FIELD;
// 2079         }
// 2080         else
// 2081           status = ZCL_STATUS_NOT_FOUND;
// 2082       }
// 2083 
// 2084       if ( UNICAST_MSG( pInMsg->msg ) )
// 2085       {
// 2086         // Addressed to this device (not to a group) - send a response back
// 2087         zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2088                                             status, scene.groupID,
// 2089                                             scene.ID, true, pInMsg->hdr.transSeqNum );
// 2090       }
// 2091       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2092       break;
// 2093 
// 2094     case COMMAND_SCENE_REMOVE_ALL:
// 2095       if ( scene.groupID == 0x0000 ||
// 2096            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2097       {
// 2098         zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
// 2099         status = ZCL_STATUS_SUCCESS;
// 2100       }
// 2101       else
// 2102         status = ZCL_STATUS_INVALID_FIELD;
// 2103 
// 2104       if ( UNICAST_MSG( pInMsg->msg ) )
// 2105       {
// 2106         // Addressed to this device (not to a group) - send a response back
// 2107         zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2108                                                status, scene.groupID, true, pInMsg->hdr.transSeqNum );
// 2109       }
// 2110       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2111       break;
// 2112 
// 2113     case COMMAND_SCENE_STORE:
// 2114       if ( scene.groupID == 0x0000 ||
// 2115            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2116       {
// 2117         // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
// 2118         // does and the corresponding Group exits
// 2119         pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2120         if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
// 2121         {
// 2122           uint8 sceneChanged = FALSE;
// 2123 
// 2124           status = ZCL_STATUS_SUCCESS;
// 2125           if ( pScene == NULL )
// 2126           {
// 2127             // Haven't been added yet
// 2128             pScene = &scene;
// 2129           }
// 2130 
// 2131           if ( pCBs->pfnSceneStoreReq )
// 2132           {
// 2133             zclSceneReq_t req;
// 2134 
// 2135             req.srcAddr = &(pInMsg->msg->srcAddr);
// 2136             req.scene = pScene;
// 2137 
// 2138             // Get the latest Scene info
// 2139             if ( pCBs->pfnSceneStoreReq( &req ) )
// 2140               sceneChanged = TRUE;
// 2141           }
// 2142 
// 2143           if ( pScene == &scene )
// 2144           {
// 2145             // The Scene doesn't exist so add it
// 2146             zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
// 2147           }
// 2148           else if ( sceneChanged )
// 2149           {
// 2150             // The Scene already exists so update only NV
// 2151             zclGeneral_ScenesWriteNV();
// 2152           }
// 2153         }
// 2154         else
// 2155           status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
// 2156       }
// 2157       else
// 2158         status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2159 
// 2160       if ( UNICAST_MSG( pInMsg->msg ) )
// 2161       {
// 2162         // Addressed to this device (not to a group) - send a response back
// 2163         zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2164                                            status, scene.groupID, scene.ID,
// 2165                                            true, pInMsg->hdr.transSeqNum );
// 2166       }
// 2167       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2168       break;
// 2169 
// 2170     case COMMAND_SCENE_RECALL:
// 2171       pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2172       if ( pScene && pCBs->pfnSceneRecallReq )
// 2173       {
// 2174         zclSceneReq_t req;
// 2175 
// 2176         req.srcAddr = &(pInMsg->msg->srcAddr);
// 2177         req.scene = pScene;
// 2178 
// 2179         pCBs->pfnSceneRecallReq( &req );
// 2180       }
// 2181       // No response
// 2182       break;
// 2183 
// 2184     case COMMAND_SCENE_GET_MEMBERSHIP:
// 2185       // Find all the Scenes corresponding to the Group ID
// 2186       if ( scene.groupID == 0x0000 ||
// 2187            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2188       {
// 2189         // Allocate space for the scene list
// 2190         sceneList = osal_mem_alloc( ZCL_GEN_MAX_SCENES );
// 2191         if ( sceneList != NULL )
// 2192         {
// 2193           sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint, 
// 2194                                                        scene.groupID, sceneList ); 
// 2195           status = ZCL_STATUS_SUCCESS;
// 2196           if ( UNICAST_MSG( pInMsg->msg ) )
// 2197           {
// 2198             // Addressed only to this device - send a response back
// 2199             sendRsp = TRUE;
// 2200           }
// 2201           else
// 2202           {
// 2203             // Addressed to the Group - ONLY send a response if an entry within the 
// 2204             // Scene Table corresponds to the Group ID
// 2205             if ( sceneCnt != 0 )
// 2206               sendRsp = TRUE;
// 2207           }
// 2208         }
// 2209         else
// 2210         {
// 2211           // Couldn't allocate space for the scene list!
// 2212           status = ZCL_STATUS_INSUFFICIENT_SPACE;
// 2213           sendRsp = TRUE;
// 2214         }
// 2215       }
// 2216       else
// 2217       {
// 2218         // The Group is not in the Group Table - send a response back
// 2219         status = ZCL_STATUS_INVALID_FIELD;
// 2220         sendRsp = TRUE;
// 2221       }
// 2222 
// 2223       if ( sendRsp )
// 2224       {
// 2225         zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2226                                     status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
// 2227                                     scene.groupID, true, pInMsg->hdr.transSeqNum );
// 2228       }
// 2229       
// 2230       if ( sceneList != NULL )
// 2231         osal_mem_free( sceneList );
// 2232       
// 2233       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2234       break;
// 2235 
// 2236     default:
// 2237       stat = ZFailure;
// 2238     break;
// 2239   }
// 2240 
// 2241   return ( stat );
// 2242 }
// 2243 
// 2244 /*********************************************************************
// 2245  * @fn      zclGeneral_ProcessInScenesClient
// 2246  *
// 2247  * @brief   Process in the received Scenes Command.
// 2248  *
// 2249  * @param   pInMsg - pointer to the incoming message
// 2250  *
// 2251  * @return  ZStatus_t
// 2252  */
// 2253 static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
// 2254                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2255 {
// 2256   zclGeneral_Scene_t scene;
// 2257   uint8 *pData = pInMsg->pData;
// 2258   uint8 nameLen;
// 2259   uint8 *sceneList = NULL;
// 2260   zclSceneRsp_t rsp;
// 2261   uint8 i;
// 2262   ZStatus_t stat = ZSuccess;
// 2263 
// 2264   osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
// 2265   osal_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
// 2266 
// 2267   // Get the status field first
// 2268   rsp.status = *pData++;
// 2269 
// 2270   if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
// 2271     rsp.capacity = *pData++;
// 2272 
// 2273   scene.groupID = BUILD_UINT16( pData[0], pData[1] );
// 2274   pData += 2;   // Move past group ID
// 2275 
// 2276   switch ( pInMsg->hdr.commandID )
// 2277   {
// 2278     case COMMAND_SCENE_VIEW_RSP:
// 2279       // Parse the rest of the incoming message
// 2280       scene.ID = *pData++; // Not applicable to Remove All Response command
// 2281       scene.transTime = BUILD_UINT16( pData[0], pData[1] );
// 2282       pData += 2;
// 2283       nameLen = *pData++; // Name length
// 2284       if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
// 2285         nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
// 2286       scene.name[0] = nameLen;
// 2287       osal_memcpy( &(scene.name[1]), pData, nameLen );
// 2288       pData += nameLen; // move pass name
// 2289 
// 2290       //*** Do something with the extension field(s)
// 2291 
// 2292       // Fall through to callback - break is left off intentionally
// 2293 
// 2294     case COMMAND_SCENE_ADD_RSP:
// 2295     case COMMAND_SCENE_REMOVE_RSP:
// 2296     case COMMAND_SCENE_REMOVE_ALL_RSP:
// 2297     case COMMAND_SCENE_STORE_RSP:
// 2298       if ( pCBs->pfnSceneRsp )
// 2299       {
// 2300         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2301         rsp.cmdID = pInMsg->hdr.commandID;
// 2302         rsp.scene = &scene;
// 2303 
// 2304         pCBs->pfnSceneRsp( &rsp );
// 2305       }
// 2306       break;
// 2307 
// 2308     case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
// 2309       if ( rsp.status == ZCL_STATUS_SUCCESS )
// 2310       {
// 2311         uint8 sceneCnt = *pData++;
// 2312         
// 2313         if ( sceneCnt > 0 )
// 2314         {
// 2315           // Allocate space for the scene list
// 2316           sceneList = osal_mem_alloc( sceneCnt );
// 2317           if ( sceneList != NULL )
// 2318           {
// 2319             rsp.sceneCnt = sceneCnt;
// 2320             for ( i = 0; i < sceneCnt; i++ )
// 2321               sceneList[i] = *pData++;
// 2322           }
// 2323         }
// 2324       }
// 2325 
// 2326       if ( pCBs->pfnSceneRsp )
// 2327       {
// 2328         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2329         rsp.cmdID = pInMsg->hdr.commandID;
// 2330         rsp.sceneList = sceneList;
// 2331         rsp.scene = &scene;
// 2332 
// 2333         pCBs->pfnSceneRsp( &rsp);
// 2334       }
// 2335       
// 2336       if ( sceneList != NULL )
// 2337         osal_mem_free( sceneList );
// 2338       break;
// 2339 
// 2340     default:
// 2341       stat = ZFailure;
// 2342       break;
// 2343   }
// 2344 
// 2345   return ( stat );
// 2346 }
// 2347 #endif // ZCL_SCENES
// 2348 
// 2349 #ifdef ZCL_ON_OFF
// 2350 /*********************************************************************
// 2351  * @fn      zclGeneral_ProcessInCmdOnOff
// 2352  *
// 2353  * @brief   Process in the received On/Off Command.
// 2354  *
// 2355  * @param   pInMsg - pointer to the incoming message
// 2356  *
// 2357  * @return  ZStatus_t
// 2358  */
// 2359 static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
// 2360                                             zclGeneral_AppCallbacks_t *pCBs )
// 2361 {
// 2362   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 2363   {
// 2364     if ( pInMsg->hdr.commandID > COMMAND_TOGGLE )
// 2365       return ( ZFailure );   // Error ignore the command
// 2366 
// 2367     if ( pCBs->pfnOnOff )
// 2368       pCBs->pfnOnOff( pInMsg->hdr.commandID );
// 2369   }
// 2370   // no Client command
// 2371 
// 2372   return ( ZSuccess );
// 2373 }
// 2374 #endif // ZCL_ON_OFF
// 2375 
// 2376 #ifdef ZCL_LEVEL_CTRL
// 2377 /*********************************************************************
// 2378  * @fn      zclGeneral_ProcessInLevelControl
// 2379  *
// 2380  * @brief   Process in the received Level Control Command.
// 2381  *
// 2382  * @param   pInMsg - pointer to the incoming message
// 2383  *
// 2384  * @return  ZStatus_t
// 2385  */
// 2386 static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
// 2387                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2388 {
// 2389   uint8 withOnOff = FALSE;
// 2390   ZStatus_t stat = ZSuccess;
// 2391 
// 2392   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 2393   {
// 2394     switch ( pInMsg->hdr.commandID )
// 2395     {
// 2396       case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
// 2397         withOnOff = TRUE;
// 2398         // fall through
// 2399       case COMMAND_LEVEL_MOVE_TO_LEVEL:
// 2400         if ( pCBs->pfnLevelControlMoveToLevel )
// 2401         {
// 2402           zclLCMoveToLevel_t cmd;
// 2403 
// 2404           cmd.level = pInMsg->pData[0];
// 2405           cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
// 2406           cmd.withOnOff = withOnOff;
// 2407 
// 2408           pCBs->pfnLevelControlMoveToLevel( &cmd );
// 2409         }
// 2410         break;
// 2411 
// 2412       case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
// 2413         withOnOff = TRUE;
// 2414         // fall through
// 2415       case COMMAND_LEVEL_MOVE:
// 2416         if ( pCBs->pfnLevelControlMove )
// 2417         {
// 2418           zclLCMove_t cmd;
// 2419 
// 2420           cmd.moveMode = pInMsg->pData[0];
// 2421           cmd.rate = pInMsg->pData[1];
// 2422           cmd.withOnOff = withOnOff;
// 2423 
// 2424           pCBs->pfnLevelControlMove( &cmd );
// 2425         }
// 2426         break;
// 2427 
// 2428       case COMMAND_LEVEL_STEP_WITH_ON_OFF:
// 2429         withOnOff = TRUE;
// 2430         // fall through
// 2431       case COMMAND_LEVEL_STEP:
// 2432         if ( pCBs->pfnLevelControlStep )
// 2433         {
// 2434           zclLCStep_t cmd;
// 2435 
// 2436           cmd.stepMode = pInMsg->pData[0];
// 2437           cmd.amount =  pInMsg->pData[1];
// 2438           cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
// 2439           cmd.withOnOff = withOnOff;
// 2440 
// 2441           pCBs->pfnLevelControlStep( &cmd );
// 2442         }
// 2443         break;
// 2444 
// 2445       case COMMAND_LEVEL_STOP:
// 2446       case COMMAND_LEVEL_STOP_WITH_ON_OFF:
// 2447         // Both Stop commands are identical
// 2448         if ( pCBs->pfnLevelControlStop )
// 2449         {
// 2450           pCBs->pfnLevelControlStop();
// 2451         }
// 2452         break;
// 2453 
// 2454       default:
// 2455         stat = ZFailure;
// 2456         break;
// 2457     }
// 2458   }
// 2459   // no Client command
// 2460 
// 2461   return ( stat );
// 2462 }
// 2463 #endif // ZCL_LEVEL_CTRL
// 2464 
// 2465 #ifdef ZCL_ALARMS
// 2466 /*********************************************************************
// 2467  * @fn      zclGeneral_AddAlarm
// 2468  *
// 2469  * @brief   Add an alarm for a cluster
// 2470  *
// 2471  * @param   endpoint -
// 2472  * @param   alarm - new alarm item
// 2473  *
// 2474  * @return  ZStatus_t
// 2475  */
// 2476 ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
// 2477 {
// 2478   zclGenAlarmItem_t *pNewItem;
// 2479   zclGenAlarmItem_t *pLoop;
// 2480 
// 2481   // Fill in the new profile list
// 2482   pNewItem = osal_mem_alloc( sizeof( zclGenAlarmItem_t ) );
// 2483   if ( pNewItem == NULL )
// 2484     return ( ZMemError );
// 2485 
// 2486   // Fill in the plugin record.
// 2487   pNewItem->next = (zclGenAlarmItem_t *)NULL;
// 2488   pNewItem->endpoint =  endpoint;
// 2489   osal_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
// 2490 
// 2491   // Find spot in list
// 2492   if (  zclGenAlarmTable == NULL )
// 2493   {
// 2494     zclGenAlarmTable = pNewItem;
// 2495   }
// 2496   else
// 2497   {
// 2498     // Look for end of list
// 2499     pLoop = zclGenAlarmTable;
// 2500     while ( pLoop->next != NULL )
// 2501       pLoop = pLoop->next;
// 2502 
// 2503     // Put new item at end of list
// 2504     pLoop->next = pNewItem;
// 2505   }
// 2506 
// 2507   return ( ZSuccess );
// 2508 }
// 2509 
// 2510 /*********************************************************************
// 2511  * @fn      zclGeneral_FindAlarm
// 2512  *
// 2513  * @brief   Find an alarm with alarmCode and clusterID
// 2514  *
// 2515  * @param   endpoint -
// 2516  * @param   groupID - what group the scene belongs to
// 2517  * @param   sceneID - ID to look for scene
// 2518  *
// 2519  * @return  a pointer to the alarm information, NULL if not found
// 2520  */
// 2521 zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
// 2522 {
// 2523   zclGenAlarmItem_t *pLoop;
// 2524 
// 2525   // Look for the alarm
// 2526   pLoop = zclGenAlarmTable;
// 2527   while ( pLoop )
// 2528   {
// 2529     if ( pLoop->endpoint == endpoint &&
// 2530          pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
// 2531     {
// 2532       return ( &(pLoop->alarm) );
// 2533     }
// 2534     pLoop = pLoop->next;
// 2535   }
// 2536 
// 2537   return ( (zclGeneral_Alarm_t *)NULL );
// 2538 }
// 2539 
// 2540 /*********************************************************************
// 2541  * @fn      zclGeneral_FindEarliestAlarm
// 2542  *
// 2543  * @brief   Find an alarm with the earliest timestamp
// 2544  *
// 2545  * @param   endpoint -
// 2546  *
// 2547  * @return  a pointer to the alarm information, NULL if not found
// 2548  */
// 2549 zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
// 2550 {
// 2551   zclGenAlarmItem_t *pLoop;
// 2552   zclGenAlarmItem_t earliestAlarm;
// 2553   zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
// 2554 
// 2555   pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
// 2556 
// 2557   // Look for alarm with earliest time
// 2558   pLoop = zclGenAlarmTable;
// 2559   while ( pLoop )
// 2560   {
// 2561     if ( pLoop->endpoint == endpoint &&
// 2562          pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
// 2563     {
// 2564       pEarliestAlarm = pLoop;
// 2565     }
// 2566     pLoop = pLoop->next;
// 2567   }
// 2568 
// 2569   if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
// 2570     return ( &(pEarliestAlarm->alarm) );
// 2571 
// 2572   // No alarm
// 2573   return ( (zclGeneral_Alarm_t *)NULL );
// 2574 }
// 2575 
// 2576 /*********************************************************************
// 2577  * @fn      zclGeneral_ResetAlarm
// 2578  *
// 2579  * @brief   Remove a scene with endpoint and sceneID
// 2580  *
// 2581  * @param   endpoint -
// 2582  * @param   alarmCode -
// 2583  * @param   clusterID -
// 2584  *
// 2585  * @return  TRUE if removed, FALSE if not found
// 2586  */
// 2587 void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
// 2588 {
// 2589   zclGenAlarmItem_t *pLoop;
// 2590   zclGenAlarmItem_t *pPrev;
// 2591 
// 2592   // Look for end of list
// 2593   pLoop = zclGenAlarmTable;
// 2594   pPrev = NULL;
// 2595   while ( pLoop )
// 2596   {
// 2597     if ( pLoop->endpoint == endpoint &&
// 2598          pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
// 2599     {
// 2600       if ( pPrev == NULL )
// 2601         zclGenAlarmTable = pLoop->next;
// 2602       else
// 2603         pPrev->next = pLoop->next;
// 2604 
// 2605       // Free the memory
// 2606       osal_mem_free( pLoop );
// 2607 
// 2608       // Notify the Application so that if the alarm condition still active then
// 2609       // a new notification will be generated, and a new alarm record will be
// 2610       // added to the alarm log
// 2611       // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
// 2612       return;
// 2613     }
// 2614     pPrev = pLoop;
// 2615     pLoop = pLoop->next;
// 2616   }
// 2617 }
// 2618 
// 2619 /*********************************************************************
// 2620  * @fn      zclGeneral_ResetAllAlarms
// 2621  *
// 2622  * @brief   Remove all alarms with endpoint
// 2623  *
// 2624  * @param   endpoint -
// 2625  * @param   notifyApp -
// 2626  *
// 2627  * @return  none
// 2628  */
// 2629 void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
// 2630 {
// 2631   zclGenAlarmItem_t *pLoop;
// 2632   zclGenAlarmItem_t *pPrev;
// 2633   zclGenAlarmItem_t *pNext;
// 2634 
// 2635   // Look for end of list
// 2636   pLoop = zclGenAlarmTable;
// 2637   pPrev = NULL;
// 2638   while ( pLoop )
// 2639   {
// 2640     if (  pLoop->endpoint == endpoint )
// 2641     {
// 2642       if ( pPrev == NULL )
// 2643         zclGenAlarmTable = pLoop->next;
// 2644       else
// 2645         pPrev->next = pLoop->next;
// 2646 
// 2647       pNext = pLoop->next;
// 2648 
// 2649       // Free the memory
// 2650       osal_mem_free( pLoop );
// 2651 
// 2652       pLoop = pNext;
// 2653     }
// 2654     else
// 2655     {
// 2656       pPrev = pLoop;
// 2657       pLoop = pLoop->next;
// 2658     }
// 2659   }
// 2660 
// 2661   if ( notifyApp )
// 2662   {
// 2663     // Notify the Application so that if any alarm conditions still active then
// 2664     // a new notification will be generated, and a new alarm record will be
// 2665     // added to the alarm log
// 2666     // zclGeneral_NotifyResetAll(); // callback function?
// 2667   }
// 2668 }
// 2669 
// 2670 /*********************************************************************
// 2671  * @fn      zclGeneral_ProcessInAlarmsServer
// 2672  *
// 2673  * @brief   Process in the received Alarms Command.
// 2674  *
// 2675  * @param   pInMsg - pointer to the incoming message
// 2676  *
// 2677  * @return  ZStatus_t
// 2678  */
// 2679 static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
// 2680                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2681 {
// 2682   zclGeneral_Alarm_t *pAlarm;
// 2683   uint8 *pData = pInMsg->pData;
// 2684   ZStatus_t stat = ZSuccess;
// 2685 
// 2686   switch ( pInMsg->hdr.commandID )
// 2687   {
// 2688     case COMMAND_ALARMS_RESET:
// 2689       zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pData[0],
// 2690                              BUILD_UINT16( pData[1], pData[2] ) );
// 2691       break;
// 2692 
// 2693     case COMMAND_ALARMS_RESET_ALL:
// 2694       zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, TRUE );
// 2695       break;
// 2696 
// 2697     case COMMAND_ALARMS_GET:
// 2698       pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
// 2699       if ( pAlarm )
// 2700       {
// 2701         // Send a response back
// 2702         zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2703                                          ZCL_STATUS_SUCCESS, pAlarm->code,
// 2704                                          pAlarm->clusterID, pAlarm->timeStamp,
// 2705                                          true, pInMsg->hdr.transSeqNum );
// 2706         // Remove the entry from the Alarm table
// 2707         zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
// 2708       }
// 2709       else
// 2710       {
// 2711         // Send a response back
// 2712         zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2713                                          ZCL_STATUS_NOT_FOUND, 0, 0, 0,
// 2714                                          true, pInMsg->hdr.transSeqNum );
// 2715       }
// 2716       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2717       break;
// 2718 
// 2719     case COMMAND_ALARMS_RESET_LOG:
// 2720       zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
// 2721       break;
// 2722 
// 2723     default:
// 2724       stat = ZFailure;
// 2725       break;
// 2726   }
// 2727 
// 2728   return ( stat );
// 2729 }
// 2730 
// 2731 /*********************************************************************
// 2732  * @fn      zclGeneral_ProcessInAlarmsClient
// 2733  *
// 2734  * @brief   Process in the received Alarms Command.
// 2735  *
// 2736  * @param   pInMsg - pointer to the incoming message
// 2737  *
// 2738  * @return  ZStatus_t
// 2739  */
// 2740 static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
// 2741                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2742 {
// 2743   uint8 *pData = pInMsg->pData;
// 2744   zclAlarm_t alarm;
// 2745   ZStatus_t stat = ZSuccess;
// 2746 
// 2747   osal_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
// 2748 
// 2749   switch ( pInMsg->hdr.commandID )
// 2750   {
// 2751     case COMMAND_ALARMS_ALARM:
// 2752       if ( pCBs->pfnAlarm )
// 2753       {
// 2754         alarm.srcAddr = &(pInMsg->msg->srcAddr);
// 2755         alarm.cmdID = pInMsg->hdr.commandID;
// 2756         alarm.status = *pData++;
// 2757         alarm.alarmCode = *pData++;
// 2758         alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
// 2759         pData += 2;
// 2760         alarm.timeStamp = osal_build_uint32( pData, 4 );
// 2761 
// 2762         pCBs->pfnAlarm( &alarm );
// 2763       }
// 2764       break;
// 2765 
// 2766     case COMMAND_ALARMS_GET_RSP:
// 2767       if ( pCBs->pfnAlarm )
// 2768       {
// 2769         alarm.srcAddr = &(pInMsg->msg->srcAddr);
// 2770         alarm.cmdID = pInMsg->hdr.commandID;
// 2771         alarm.alarmCode = *pData++;
// 2772         alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
// 2773 
// 2774         pCBs->pfnAlarm( &alarm );
// 2775       }
// 2776       break;
// 2777 
// 2778     default:
// 2779       stat = ZFailure;
// 2780       break;
// 2781   }
// 2782 
// 2783   return ( stat );
// 2784 }
// 2785 #endif // ZCL_ALARMS
// 2786 
// 2787 #ifdef ZCL_LOCATION
// 2788 /*********************************************************************
// 2789  * @fn      zclGeneral_ProcessInLocationServer
// 2790  *
// 2791  * @brief   Process in the received Location Command.
// 2792  *
// 2793  * @param   pInMsg - pointer to the incoming message
// 2794  *
// 2795  * @return  ZStatus_t
// 2796  */
// 2797 static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
// 2798                                                      zclGeneral_AppCallbacks_t *pCBs )
// 2799 {
// 2800   uint8 *pData = pInMsg->pData;
// 2801   zclLocation_t cmd;
// 2802   ZStatus_t stat = ZSuccess;
// 2803 
// 2804   osal_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
// 2805 
// 2806   switch ( pInMsg->hdr.commandID )
// 2807   {
// 2808     case COMMAND_LOCATION_SET_ABSOLUTE:
// 2809       cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
// 2810       pData += 2;
// 2811       cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
// 2812       pData += 2;
// 2813       cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
// 2814       pData += 2;
// 2815       cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
// 2816       pData += 2;
// 2817       cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 2818 
// 2819       if ( pCBs->pfnLocation )
// 2820       {
// 2821         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 2822         cmd.cmdID = pInMsg->hdr.commandID;
// 2823 
// 2824         // Update the absolute location info
// 2825         pCBs->pfnLocation( &cmd );
// 2826       }
// 2827       break;
// 2828 
// 2829     case COMMAND_LOCATION_SET_DEV_CFG:
// 2830       cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
// 2831       pData += 2;
// 2832       cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 2833       pData += 2;
// 2834       cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
// 2835       pData += 2;
// 2836       cmd.un.devCfg.numMeasurements = *pData++;
// 2837       cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
// 2838 
// 2839       if ( pCBs->pfnLocation )
// 2840       {
// 2841         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 2842         cmd.cmdID = pInMsg->hdr.commandID;
// 2843 
// 2844         // Update the device configuration info
// 2845         pCBs->pfnLocation( &cmd );
// 2846       }
// 2847       break;
// 2848 
// 2849     case COMMAND_LOCATION_GET_DEV_CFG:
// 2850       cmd.un.ieeeAddr = pData;
// 2851 
// 2852       if ( pCBs->pfnLocation )
// 2853       {
// 2854         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 2855         cmd.cmdID = pInMsg->hdr.commandID;
// 2856         cmd.seqNum = pInMsg->hdr.transSeqNum;
// 2857 
// 2858         // Retreive the Device Configuration
// 2859         pCBs->pfnLocation( &cmd );
// 2860       }
// 2861       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2862       break;
// 2863 
// 2864     case COMMAND_LOCATION_GET_DATA:
// 2865       cmd.un.loc.bitmap.locByte = *pData++;
// 2866       cmd.un.loc.numResponses = *pData++;
// 2867 
// 2868       if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
// 2869         osal_cpyExtAddr( cmd.un.loc.targetAddr, pData );
// 2870 
// 2871       if ( pCBs->pfnLocation )
// 2872       {
// 2873         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 2874         cmd.cmdID = pInMsg->hdr.commandID;
// 2875         cmd.seqNum = pInMsg->hdr.transSeqNum;
// 2876 
// 2877         // Retreive the Location Data
// 2878         pCBs->pfnLocation( &cmd );
// 2879       }
// 2880       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2881       break;
// 2882 
// 2883     default:
// 2884       stat = ZFailure;
// 2885       break;
// 2886   }
// 2887 
// 2888   return ( stat );
// 2889 }
// 2890 
// 2891 /*********************************************************************
// 2892  * @fn      zclGeneral_ProcessInLocationDataRsp
// 2893  *
// 2894  * @brief   Process in the received Location Command.
// 2895  *
// 2896  * @param   pInMsg - pointer to the incoming message
// 2897  *
// 2898  * @return  ZStatus_t
// 2899  */
// 2900 static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
// 2901                                                  zclGeneral_AppCallbacks_t *pCBs )
// 2902 {
// 2903   uint8 *pData = pInMsg->pData;
// 2904   zclLocationRsp_t rsp;
// 2905 
// 2906   osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
// 2907 
// 2908   if ( pCBs->pfnLocationRsp )
// 2909   {
// 2910     if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
// 2911       rsp.un.loc.status = *pData++;
// 2912 
// 2913     if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
// 2914          rsp.un.loc.status == ZCL_STATUS_SUCCESS )
// 2915     {
// 2916       rsp.un.loc.data.type = *pData++;
// 2917       rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
// 2918       pData += 2;
// 2919       rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
// 2920       pData += 2;
// 2921 
// 2922       if ( locationType2D( rsp.un.loc.data.type ) == 0 )
// 2923       {
// 2924         rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
// 2925         pData += 2;
// 2926       }
// 2927 
// 2928       if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 2929       {
// 2930         rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
// 2931         pData += 2;
// 2932         rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 2933         pData += 2;
// 2934       }
// 2935 
// 2936       if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
// 2937       {
// 2938         if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 2939           rsp.un.loc.data.calcLoc.locationMethod = *pData++;
// 2940 
// 2941         rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
// 2942         rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
// 2943       }
// 2944     }
// 2945 
// 2946     rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2947     rsp.cmdID = pInMsg->hdr.commandID;
// 2948 
// 2949     // Notify the Application
// 2950     pCBs->pfnLocationRsp( &rsp );
// 2951   }
// 2952 }
// 2953 
// 2954 /*********************************************************************
// 2955  * @fn      zclGeneral_ProcessInLocationClient
// 2956  *
// 2957  * @brief   Process in the received Location Command.
// 2958  *
// 2959  * @param   pInMsg - pointer to the incoming message
// 2960  *
// 2961  * @return  ZStatus_t
// 2962  */
// 2963 static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
// 2964                                                      zclGeneral_AppCallbacks_t *pCBs )
// 2965 {
// 2966   uint8 *pData = pInMsg->pData;
// 2967   zclLocationRsp_t rsp;
// 2968   ZStatus_t stat = ZSuccess;
// 2969 
// 2970   osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
// 2971 
// 2972   switch ( pInMsg->hdr.commandID )
// 2973   {
// 2974     case COMMAND_LOCATION_DEV_CFG_RSP:
// 2975       if ( pCBs->pfnLocationRsp )
// 2976       {
// 2977         rsp.un.devCfg.status = *pData++;
// 2978         if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
// 2979         {
// 2980           rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
// 2981           pData += 2;
// 2982           rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 2983           pData += 2;
// 2984           rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
// 2985           pData += 2;
// 2986           rsp.un.devCfg.data.numMeasurements = *pData++;
// 2987           rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
// 2988 
// 2989           rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2990           rsp.cmdID = pInMsg->hdr.commandID;
// 2991 
// 2992           // Notify the Application
// 2993           pCBs->pfnLocationRsp( &rsp );
// 2994         }
// 2995       }
// 2996       break;
// 2997 
// 2998     case COMMAND_LOCATION_DATA_RSP:
// 2999     case COMMAND_LOCATION_DATA_NOTIF:
// 3000     case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
// 3001       zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
// 3002       break;
// 3003 
// 3004     case COMMAND_LOCATION_RSSI_PING:
// 3005       if ( pCBs->pfnLocationRsp )
// 3006       {
// 3007         rsp.un.locationType = *pData;
// 3008 
// 3009         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 3010         rsp.cmdID = pInMsg->hdr.commandID;
// 3011 
// 3012         // Notify the Application
// 3013         pCBs->pfnLocationRsp( &rsp );
// 3014       }
// 3015       break;
// 3016 
// 3017     default:
// 3018       stat = ZFailure;
// 3019       break;
// 3020   }
// 3021 
// 3022   return ( stat );
// 3023 }
// 3024 #endif // ZCL_LOCATION
// 3025 
// 3026 #ifdef ZCL_SCENES
// 3027 /*********************************************************************
// 3028  * @fn      zclGeneral_ScenesInitNV
// 3029  *
// 3030  * @brief   Initialize the NV Scene Table Items
// 3031  *
// 3032  * @param   none
// 3033  *
// 3034  * @return  number of scenes
// 3035  */
// 3036 static uint8 zclGeneral_ScenesInitNV( void )
// 3037 {
// 3038   uint8  status;
// 3039   uint16 size;
// 3040 
// 3041   size = (uint16)((sizeof ( nvGenScenesHdr_t ))
// 3042                   + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
// 3043 
// 3044   status = osal_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
// 3045 
// 3046   if ( status != ZSUCCESS )
// 3047   {
// 3048     zclGeneral_ScenesSetDefaultNV();
// 3049   }
// 3050 
// 3051   return status;
// 3052 }
// 3053 
// 3054 /*********************************************************************
// 3055  * @fn          zclGeneral_ScenesSetDefaultNV
// 3056  *
// 3057  * @brief       Write the defaults to NV
// 3058  *
// 3059  * @param       none
// 3060  *
// 3061  * @return      none
// 3062  */
// 3063 static void zclGeneral_ScenesSetDefaultNV( void )
// 3064 {
// 3065   nvGenScenesHdr_t hdr;
// 3066 
// 3067   // Initialize the header
// 3068   hdr.numRecs = 0;
// 3069 
// 3070   // Save off the header
// 3071   osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
// 3072 }
// 3073 
// 3074 /*********************************************************************
// 3075  * @fn          zclGeneral_ScenesWriteNV
// 3076  *
// 3077  * @brief       Save the Scene Table in NV
// 3078  *
// 3079  * @param       none
// 3080  *
// 3081  * @return      none
// 3082  */
// 3083 static void zclGeneral_ScenesWriteNV( void )
// 3084 {
// 3085   nvGenScenesHdr_t hdr;
// 3086   zclGenSceneItem_t *pLoop;
// 3087   zclGenSceneNVItem_t item;
// 3088 
// 3089   hdr.numRecs = 0;
// 3090 
// 3091   // Look for end of list
// 3092   pLoop = zclGenSceneTable;
// 3093   while ( pLoop )
// 3094   {
// 3095     // Build the record
// 3096     item.endpoint = pLoop->endpoint;
// 3097     osal_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
// 3098 
// 3099     // Save the record to NV
// 3100     osal_nv_write( ZCD_NV_SCENE_TABLE,
// 3101             (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
// 3102                     sizeof ( zclGenSceneNVItem_t ), &item );
// 3103 
// 3104     hdr.numRecs++;
// 3105 
// 3106     pLoop = pLoop->next;
// 3107   }
// 3108 
// 3109   // Save off the header
// 3110   osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
// 3111 }
// 3112 
// 3113 /*********************************************************************
// 3114  * @fn          zclGeneral_ScenesRestoreFromNV
// 3115  *
// 3116  * @brief       Restore the Scene table from NV
// 3117  *
// 3118  * @param       none
// 3119  *
// 3120  * @return      Number of entries restored
// 3121  */
// 3122 static uint16 zclGeneral_ScenesRestoreFromNV( void )
// 3123 {
// 3124   uint16 x;
// 3125   nvGenScenesHdr_t hdr;
// 3126 
// 3127   zclGenSceneNVItem_t item;
// 3128   uint16 numAdded = 0;
// 3129 
// 3130   if ( osal_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
// 3131   {
// 3132     // Read in the device list
// 3133     for ( x = 0; x < hdr.numRecs; x++ )
// 3134     {
// 3135       if ( osal_nv_read( ZCD_NV_SCENE_TABLE,
// 3136                 (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
// 3137                                   sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
// 3138       {
// 3139         // Add the scene
// 3140         if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
// 3141         {
// 3142           numAdded++;
// 3143         }
// 3144       }
// 3145     }
// 3146   }
// 3147 
// 3148   return ( numAdded );
// 3149 }
// 3150 #endif // ZCL_SCENES
// 3151 
// 3152 /***************************************************************************
// 3153 ****************************************************************************/
// 
// 1 013 bytes in segment BANKED_CODE
//    36 bytes in segment BANK_RELAYS
//     3 bytes in segment XDATA_Z
// 
// 1 049 bytes of CODE  memory
//     3 bytes of XDATA memory
//
//Errors: none
//Warnings: none
