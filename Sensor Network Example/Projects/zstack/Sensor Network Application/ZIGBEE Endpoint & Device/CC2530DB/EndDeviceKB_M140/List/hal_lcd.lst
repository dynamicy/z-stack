###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                02/Sep/2013  23:10:24 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Components\hal\target\CC2530KB\hal_lcd.c   #
#    Command line       =  -f "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.c #
#                          fg" (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS)   #
#                          -f "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig. #
#                          cfg" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0             #
#                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800          #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440)   #
#                          -f "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg #
#                          " (-DZCL_READ -DZCL_WRITE -DZCL_BASIC              #
#                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH    #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING) -DZCL_MESSAGE                       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Components\hal\target\CC2530KB\hal_lcd.c"  #
#                          -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D         #
#                          MT_APP_FUNC -D MT_SYS_FUNC -D MT_ZDO_FUNC -D       #
#                          LCD_SUPPORTED=DEBUG -D xPOWER_SAVING -D            #
#                          End_Device -D M140 -D xPA2591 -lC                  #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceKB_M140\List\" -lA        #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceKB_M140\List\"            #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceKB_M140\Obj\" -e          #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\GitHub\z-stack\Sensor  #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Endpoint & Device\CC2530DB\"    #
#                          -I "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\SOURCE\" -I                     #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\SOURCE\" -I                  #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I       #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I  #
#                          "D:\GitHub\z-stack\Sensor Network                  #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCL #
#                          UDE\" -I "D:\GitHub\z-stack\Sensor Network         #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\MODU #
#                          LE\" -I "D:\GitHub\z-stack\Sensor Network          #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARG #
#                          ET\CC2530KB\" -I "D:\GitHub\z-stack\Sensor         #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU #
#                          \CCSOC\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INC #
#                          LUDE\" -I "D:\GitHub\z-stack\Sensor Network        #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF #
#                          \" -I "D:\GitHub\z-stack\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NW #
#                          K\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SE #
#                          C\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SA #
#                          PI\" -I "D:\GitHub\z-stack\Sensor Network          #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SY #
#                          S\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZC #
#                          L\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZD #
#                          O\" -I "D:\GitHub\z-stack\Sensor Network           #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W #
#                          \" -I "D:\GitHub\z-stack\Sensor Network            #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\"   #
#                          -I "D:\GitHub\z-stack\Sensor Network               #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SADDR\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES #
#                          \SDATA\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCL #
#                          UDE\" -I "D:\GitHub\z-stack\Sensor Network         #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH #
#                          _LEVEL\" -I "D:\GitHub\z-stack\Sensor Network      #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\" -I "D:\GitHub\z-stack\Sensor         #
#                          Network Example\Projects\zstack\Sensor Network     #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_ #
#                          LEVEL\srf04\SINGLE_CHIP\" -I "C:\Program Files     #
#                          (x86)\IAR Systems\Embedded Workbench               #
#                          5.3\8051\INC\" -I "C:\Program Files (x86)\IAR      #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceKB_M140\List\hal_lcd.lst  #
#    Object file        =  D:\GitHub\z-stack\Sensor Network                   #
#                          Example\Projects\zstack\Sensor Network             #
#                          Application\ZIGBEE Endpoint &                      #
#                          Device\CC2530DB\EndDeviceKB_M140\Obj\hal_lcd.r51   #
#                                                                             #
#                                                                             #
###############################################################################

D:\GitHub\z-stack\Sensor Network Example\Components\hal\target\CC2530KB\hal_lcd.c
      1          /**************************************************************************************************
      2            Filename:       hal_lcd.c
      3            Revised:        $Date: 2009-11-09 20:03:17 -0800 (Mon, 09 Nov 2009) $
      4            Revision:       $Revision: 21106 $
      5          
      6            Description:    This file contains the interface to the HAL LCD Service.
      7          
      8          
      9            Copyright 2007 - 2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41           *                                           INCLUDES
     42           **************************************************************************************************/
     43          #include "hal_types.h"
     44          #include "hal_lcd.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf5
   \   unsigned char volatile __sfr P2SEL
   \                     P2SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     45          #include "hal_keypad.h"
     46          #include "OSAL.h"
     47          #include "OnBoard.h"
     48          #include "hal_timer.h"
     49          #include <string.h>
     50          
     51          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
     52            #include "DebugTrace.h"
     53          #endif
     54          
     55          /*******************************************************************************
     56           *                                          CONSTANTS
     57           ******************************************************************************/
     58          /* LCD lines */
     59          #define LCD_LINE_COUNT       2
     60          #define LCD_LINE_LENGTH      16
     61          #define LCD_MAX_BUF          25
     62          
     63          /* LCD Control */
     64          #define HAL_LCD_EN_PORT      P2_0
     65          #define HAL_LCD_EN_PIN       BV(0)
     66          #define HAL_LCD_EN_DDR	     P2DIR
     67          #define HAL_LCD_EN_SEL	     P2SEL
     68          #define HAL_LCD_RS_PORT      P0_6
     69          #define HAL_LCD_RS_PIN       BV(6)
     70          #define HAL_LCD_RS_DDR	     P0DIR
     71          #define HAL_LCD_RS_SEL	     P0SEL
     72          #define HAL_LCD_DATA_PORT    P1
     73          #define HAL_LCD_DATA_DDR     P1DIR
     74          #define HAL_LCD_DATA_SEL     P1SEL
     75          
     76          /* LED Control */
     77          #define HAL_TURN_OFF_LED3()       st( LED3_SBIT = LED3_POLARITY (0); )
     78          #define HAL_TURN_OFF_LED4()       HAL_TURN_OFF_LED1()
     79          #define HAL_TURN_ON_LED1()        st( LED1_SBIT = LED1_POLARITY (1); )
     80          
     81          /* LCD Setting */
     82          #define HAL_LCD_EN_SET()               st(HAL_LCD_EN_PORT = 1;)
     83          #define HAL_LCD_EN_CLR()               st(HAL_LCD_EN_PORT = 0;)
     84          #define HAL_LCD_RS_SET()               st(HAL_LCD_RS_PORT = 1;)
     85          #define HAL_LCD_RS_CLR()               st(HAL_LCD_RS_PORT = 0;)
     86          #define HAL_LCD_DATA(val)              st(P1 = val;)
     87          
     88          /* Setting IO for output */
     89          #define HAL_LCD_EN_OUTPUT()		st(P2SEL &= ~BV(0); P2DIR |= BV(0);)
     90          #define HAL_LCD_RS_OUTPUT()		st(P0SEL &= ~BV(6); P0DIR |= BV(6);)
     91          #define HAL_LCD_DATA_OUTPUT()		st(P1SEL &= 0x00; P1DIR |= 0xFF;)
     92          
     93          /* Setting IO_DIR input, output */
     94          #define HAL_LCD_RS_DIR_INPUT()		st(P0DIR &= ~BV(6);)
     95          #define HAL_LCD_RS_DIR_OUTPUT()		st(P0DIR |= BV(6);)
     96          
     97          /**************Defines for HW LCD*****************/
     98          /* Function Set */
     99          #define DOT_5X10_OFF                    0x00
    100          #define DOT_5X10_ON                     0x04
    101          #define DUAL_LINE_OFF                   0x00
    102          #define DUAL_LINE_ON                    0x08
    103          #define BUS_8BIT_OFF                    0x00
    104          #define BUS_8BIT_ON                     0x10
    105          #define FUNCTION_SET(options)           lcdCommand(0x20 | (options))
    106          
    107          /* Display clear */
    108          #define DISPLAY_CLEAR()                 lcdCommand(0x01)
    109          
    110          /* Set display control */
    111          #define DISPLAY_CTRL_ON                 0x04
    112          #define DISPLAY_CTRL_OFF                0x00
    113          #define DISPLAY_CTRL_BLINK_ON           0x01
    114          #define DISPLAY_CTRL_BLINK_OFF          0x00
    115          #define DISPLAY_CTRL_CURSOR_ON          0x02
    116          #define DISPLAY_CTRL_CURSOR_OFF         0x00
    117          #define SET_DISPLAY_CTRL(options)       lcdCommand(0x08 | (options))
    118          
    119          /* Set enter mode */
    120          #define INCREMENT_ON                    0x02
    121          #define INCREMENT_OFF                   0x00
    122          #define DISPLAY_SHIFT_ON                0x01
    123          #define DISPLAY_SHIFT_OFF               0x00
    124          #define SET_ENTER_MODE(options)         lcdCommand(0x04 | (options))
    125          
    126          /* Set display control */
    127          #define SHITF_DISPLAY_ON                0x04
    128          #define SHITF_DISPLAY_OFF               0x00
    129          #define SHITF_RIGHT_ON                  0x02
    130          #define SHITF_RIGHT_OFF                 0x00
    131          #define SET_CURSOR_SHIFT(options)       lcdCommand(0x10 | (options))
    132          
    133          /* Set Display Start Line */
    134          #define LINE1                           0x00
    135          #define LINE2                           0x40
    136          #define SET_DISPLAY_LINE(line)          lcdCommand(0x80 | (line))
    137          
    138          /* Set DD/ CGRAM address */
    139          #define SET_DDRAM_ADDR(charIndex)       lcdCommand(0x80 | (charIndex))
    140          #define SET_GCRAM_CHAR(specIndex)       lcdCommand(0x40 | (specIndex))
    141          
    142          /* Set ICONRAM address */
    143          #define CONTRAST_CTRL_REGISTER          0x10
    144          #define SET_ICONRAM_ADDR(addr)          lcdCommand(0x40 | (addr))
    145          
    146          /*******************************************************************************
    147           *                                           MACROS
    148           ******************************************************************************/
    149          
    150          #define HAL_IO_SET(port, pin, val)        HAL_IO_SET_PREP(port, pin, val)
    151          #define HAL_IO_SET_PREP(port, pin, val)   st( P##port##_##pin## = val; )
    152          
    153          #define HAL_CONFIG_IO_OUTPUT(port, pin, val)      HAL_CONFIG_IO_OUTPUT_PREP(port, pin, val)
    154          #define HAL_CONFIG_IO_OUTPUT_PREP(port, pin, val) st( P##port##SEL &= ~BV(pin); \
    155                                                                P##port##_##pin## = val; \
    156                                                                P##port##DIR |= BV(pin); )
    157          
    158          #define HAL_CONFIG_IO_PERIPHERAL(port, pin)      HAL_CONFIG_IO_PERIPHERAL_PREP(port, pin)
    159          #define HAL_CONFIG_IO_PERIPHERAL_PREP(port, pin) st( P##port##SEL |= BV(pin); )
    160          
    161          /**************************************************************************************************
    162           *                                       GLOBAL VARIABLES
    163           **************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    164          static uint8 *Lcd_Line1;
   \                     Lcd_Line1:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    165          uint8 pLedData;
   \                     pLedData:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    166          
    167          /*******************************************************************************
    168           *                                       FUNCTIONS - API
    169           ******************************************************************************/
    170          #if (HAL_LCD == TRUE)
    171          void HalLcd_HW_WaitUs(uint16 i);
    172          void HalLcd_HW_Clear(void);
    173          void HalLcd_HW_ClearAllSpecChars(void);
    174          void HalLcd_HW_SetContrast(uint8 value);
    175          void HalLcd_HW_WriteLine(uint8 line, const char *pText);
    176          
    177          static void initLcd(void);
    178          static void lcdCommand(uint8 command);
    179          static void lcdData(uint8 ch);
    180          static void lcdUpdateChar(uint8 line, uint8 col, char ch);
    181          #endif //LCD
    182          
    183          /*******************************************************************************
    184           * @fn      HalLcdInit
    185           *
    186           * @brief   Initilize LCD Service
    187           *
    188           * @param   init - pointer to void that contains the initialized value
    189           *
    190           * @return  None
    191           ******************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    192          void HalLcdInit(void)
   \                     HalLcdInit:
    193          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    194            Lcd_Line1 = NULL;
   \   000004   90....       MOV     DPTR,#Lcd_Line1
   \   000007   E4           CLR     A
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   F0           MOVX    @DPTR,A
    195          #if (HAL_LCD == TRUE)
    196            initLcd();
   \   00000B                ; Setup parameters for call to function initLcd
   \   00000B   12....       LCALL   ??initLcd?relay
    197          #endif
    198          }
   \   00000E   80..         SJMP    ??Subroutine25_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine25_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    199          
    200          /*************************************************************************************************
    201           *                    LCD EMULATION FUNCTIONS
    202           *
    203           * Some evaluation boards are equipped with Liquid Crystal Displays
    204           * (LCD) which may be used to display diagnostic information. These
    205           * functions provide LCD emulation, sending the diagnostic strings
    206           * to Z-Tool via the RS232 serial port. These functions are enabled
    207           * when the "LCD_SUPPORTED" compiler flag is placed in the makefile.
    208           *
    209           * Most applications update both lines (1 and 2) of the LCD whenever
    210           * text is posted to the device. This emulator assumes that line 1 is
    211           * updated first (saved locally) and the formatting and send operation
    212           * is triggered by receipt of line 2. Nothing will be transmitted if
    213           * only line 1 is updated.
    214           *
    215           *************************************************************************************************/
    216          
    217          /*******************************************************************************
    218           * @fn      HalLcdWriteString
    219           *
    220           * @brief   Write a string to the LCD
    221           *
    222           * @param   str    - pointer to the string that will be displayed
    223           *          option - display options
    224           *
    225           * @return  None
    226           ******************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    227          void HalLcdWriteString ( char *str, uint8 option)
   \                     HalLcdWriteString:
    228          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 14,R2
   \   000007   8B..         MOV     ?V0 + 15,R3
   \   000009   89..         MOV     ?V0 + 3,R1
    229          #if (HAL_LCD == TRUE)
    230          
    231            uint8 strLen = 0;
    232            uint8 totalLen = 0;
    233            uint8 *buf;
    234            uint8 tmpLen;
    235          
    236            if ( Lcd_Line1 == NULL )
   \   00000B   90....       MOV     DPTR,#Lcd_Line1
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   7002         JNZ     ??HalLcdWriteString_0
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \                     ??HalLcdWriteString_0:
   \   000013   700F         JNZ     ??HalLcdWriteString_1
    237            {
    238              Lcd_Line1 = osal_mem_alloc( HAL_LCD_MAX_CHARS+1 );
   \   000015                ; Setup parameters for call to function osal_mem_alloc
   \   000015   7A11         MOV     R2,#0x11
   \   000017   7B00         MOV     R3,#0x0
   \   000019   12....       LCALL   ??osal_mem_alloc?relay
   \   00001C   90....       MOV     DPTR,#Lcd_Line1
   \   00001F   EA           MOV     A,R2
   \   000020   F0           MOVX    @DPTR,A
   \   000021   A3           INC     DPTR
   \   000022   EB           MOV     A,R3
   \   000023   F0           MOVX    @DPTR,A
    239            }
    240          
    241            strLen = (uint8)osal_strlen( (char*)str );
   \                     ??HalLcdWriteString_1:
   \   000024                ; Setup parameters for call to function osal_strlen
   \   000024   AA..         MOV     R2,?V0 + 14
   \   000026   AB..         MOV     R3,?V0 + 15
   \   000028   12....       LCALL   ??osal_strlen?relay
   \   00002B   EA           MOV     A,R2
   \   00002C   F5..         MOV     ?V0 + 4,A
    242          
    243            /* Check boundries */
    244            if ( strLen > HAL_LCD_MAX_CHARS )
   \   00002E   C3           CLR     C
   \   00002F   9411         SUBB    A,#0x11
   \   000031   4003         JC      ??HalLcdWriteString_2
    245              strLen = HAL_LCD_MAX_CHARS;
   \   000033   75..10       MOV     ?V0 + 4,#0x10
    246          
    247            if ( option == HAL_LCD_LINE_1 )
   \                     ??HalLcdWriteString_2:
   \   000036   85..82       MOV     DPL,?V0 + 4
   \   000039   8582..       MOV     ?V0 + 12,DPL
   \   00003C   85....       MOV     ?V0 + 0,?V0 + 14
   \   00003F   85....       MOV     ?V0 + 1,?V0 + 15
   \   000042   75..00       MOV     ?V0 + 2,#0x0
   \   000045   AE82         MOV     R6,DPL
   \   000047   7401         MOV     A,#0x1
   \   000049   65..         XRL     A,?V0 + 3
   \   00004B   702B         JNZ     ??HalLcdWriteString_3
    248            {
    249              /* Line 1 gets saved for later */
    250              osal_memcpy( Lcd_Line1, str, strLen );
   \   00004D                ; Setup parameters for call to function osal_memcpy
   \   00004D   78..         MOV     R0,#?V0 + 0
   \   00004F   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000052   EE           MOV     A,R6
   \   000053   FC           MOV     R4,A
   \   000054   7D00         MOV     R5,#0x0
   \   000056   90....       MOV     DPTR,#Lcd_Line1
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   FA           MOV     R2,A
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   FB           MOV     R3,A
   \   00005E   12....       LCALL   ??Subroutine27_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
    251              Lcd_Line1[strLen] = '\0';
   \   000064   90....       MOV     DPTR,#Lcd_Line1
   \   000067   E0           MOVX    A,@DPTR
   \   000068   25..         ADD     A,?V0 + 12
   \   00006A   FA           MOV     R2,A
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   3400         ADDC    A,#0x0
   \   00006F   8A82         MOV     DPL,R2
   \   000071   F583         MOV     DPH,A
   \   000073   E4           CLR     A
   \   000074   F0           MOVX    @DPTR,A
   \   000075   02....       LJMP    ??HalLcdWriteString_4 & 0xFFFF
    252            }
    253            else
    254            {
    255              /* Line 2 triggers action */
    256              tmpLen = (uint8)osal_strlen( (char*)Lcd_Line1 );
   \                     ??HalLcdWriteString_3:
   \   000078                ; Setup parameters for call to function osal_strlen
   \   000078   90....       MOV     DPTR,#Lcd_Line1
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   FA           MOV     R2,A
   \   00007D   A3           INC     DPTR
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   FB           MOV     R3,A
   \   000080   12....       LCALL   ??osal_strlen?relay
   \   000083   EA           MOV     A,R2
   \   000084   F5..         MOV     ?V0 + 6,A
    257              totalLen =  tmpLen + 1 + strLen + 1;
    258              buf = osal_mem_alloc( totalLen );
   \   000086                ; Setup parameters for call to function osal_mem_alloc
   \   000086   EE           MOV     A,R6
   \   000087   25..         ADD     A,?V0 + 6
   \   000089   2402         ADD     A,#0x2
   \   00008B   FA           MOV     R2,A
   \   00008C   7B00         MOV     R3,#0x0
   \   00008E   12....       LCALL   ??osal_mem_alloc?relay
   \   000091   8A..         MOV     ?V0 + 4,R2
   \   000093   8B..         MOV     ?V0 + 5,R3
    259              if ( buf != NULL )
   \   000095   EA           MOV     A,R2
   \   000096   7001         JNZ     ??HalLcdWriteString_5
   \   000098   EB           MOV     A,R3
   \                     ??HalLcdWriteString_5:
   \   000099   6060         JZ      ??HalLcdWriteString_4
    260              {
    261                /* Concatenate strings */
    262                osal_memcpy( buf, Lcd_Line1, tmpLen );
   \   00009B                ; Setup parameters for call to function osal_memcpy
   \   00009B   90....       MOV     DPTR,#Lcd_Line1
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   F5..         MOV     ?V0 + 8,A
   \   0000A1   A3           INC     DPTR
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   F5..         MOV     ?V0 + 9,A
   \   0000A5   75..00       MOV     ?V0 + 10,#0x0
   \   0000A8   78..         MOV     R0,#?V0 + 8
   \   0000AA   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000AD   AC..         MOV     R4,?V0 + 6
   \   0000AF   7D00         MOV     R5,#0x0
   \   0000B1   12....       LCALL   ??Subroutine27_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   0000B4   12....       LCALL   ?DEALLOC_XSTACK8
    263                buf[tmpLen++] = ' ';
   \   0000B7   85....       MOV     ?V0 + 8,?V0 + 6
   \   0000BA   E5..         MOV     A,?V0 + 4
   \   0000BC   25..         ADD     A,?V0 + 8
   \   0000BE   F582         MOV     DPL,A
   \   0000C0   E5..         MOV     A,?V0 + 5
   \   0000C2   12....       LCALL   ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   0000C5   05..         INC     ?V0 + 6
    264                osal_memcpy( &buf[tmpLen], str, strLen );
   \   0000C7                ; Setup parameters for call to function osal_memcpy
   \   0000C7   78..         MOV     R0,#?V0 + 0
   \   0000C9   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000CC   EE           MOV     A,R6
   \   0000CD   FC           MOV     R4,A
   \   0000CE   7D00         MOV     R5,#0x0
   \   0000D0   E5..         MOV     A,?V0 + 4
   \   0000D2   25..         ADD     A,?V0 + 6
   \   0000D4   FA           MOV     R2,A
   \   0000D5   E5..         MOV     A,?V0 + 5
   \   0000D7   3400         ADDC    A,#0x0
   \   0000D9   FB           MOV     R3,A
   \   0000DA   12....       LCALL   ??Subroutine27_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0000DD   12....       LCALL   ?DEALLOC_XSTACK8
    265                buf[tmpLen+strLen] = '\0';
   \   0000E0   EE           MOV     A,R6
   \   0000E1   25..         ADD     A,?V0 + 6
   \   0000E3   F8           MOV     R0,A
   \   0000E4   E4           CLR     A
   \   0000E5   3400         ADDC    A,#0x0
   \   0000E7   F9           MOV     R1,A
   \   0000E8   E5..         MOV     A,?V0 + 4
   \   0000EA   28           ADD     A,R0
   \   0000EB   F582         MOV     DPL,A
   \   0000ED   E5..         MOV     A,?V0 + 5
   \   0000EF   39           ADDC    A,R1
   \   0000F0   F583         MOV     DPH,A
   \   0000F2   E4           CLR     A
   \   0000F3   F0           MOVX    @DPTR,A
    266          
    267          /*****************¥h°£HalLcdWriteString±quart¿é¥X******************************/      
    268          //      /* Send it out */
    269          //#if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    270          //
    271          //#if defined(SERIAL_DEBUG_SUPPORTED)
    272          //      debug_str( (uint8*)buf );
    273          //#endif //LCD_SUPPORTED
    274          //
    275          //#endif //ZTOOL_P1
    276          /******************************************************************************/
    277                
    278                /* Free mem */
    279                osal_mem_free( buf );
   \   0000F4                ; Setup parameters for call to function osal_mem_free
   \   0000F4   AA..         MOV     R2,?V0 + 4
   \   0000F6   AB..         MOV     R3,?V0 + 5
   \   0000F8   12....       LCALL   ??osal_mem_free?relay
    280              }
    281            }
    282            /* Display the string */
    283            HalLcd_HW_WriteLine (option, str);
   \                     ??HalLcdWriteString_4:
   \   0000FB                ; Setup parameters for call to function HalLcd_HW_WriteLine
   \   0000FB   AA..         MOV     R2,?V0 + 14
   \   0000FD   AB..         MOV     R3,?V0 + 15
   \   0000FF   A9..         MOV     R1,?V0 + 3
   \   000101   12....       LCALL   ??HalLcd_HW_WriteLine?relay
    284          #endif //HAL_LCD
    285          }
   \   000104   7F10         MOV     R7,#0x10
   \   000106   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine26_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   7420         MOV     A,#0x20
   \   000006   F0           MOVX    @DPTR,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine27_0:
   \   000000   12....       LCALL   ??osal_memcpy?relay
   \   000003   7403         MOV     A,#0x3
   \   000005   22           RET
    286          
    287          /**************************************************************************************************
    288           * @fn      HalLcdWriteValue
    289           *
    290           * @brief   Write a value to the LCD
    291           *
    292           * @param   value  - value that will be displayed
    293           *          radix  - 8, 10, 16
    294           *          option - display options
    295           *
    296           * @return  None
    297           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    298          void HalLcdWriteValue ( uint32 value, const uint8 radix, uint8 option)
   \                     HalLcdWriteValue:
    299          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 25
   \   000005   74E7         MOV     A,#-0x19
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7427         MOV     A,#0x27
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FE           MOV     R6,A
    300          #if (HAL_LCD == TRUE)
    301            uint8 buf[LCD_MAX_BUF];
    302          
    303            _ltoa( value, &buf[0], radix );
   \   000011                ; Setup parameters for call to function _ltoa
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   8582..       MOV     ?V0 + 4,DPL
   \   00001A   8583..       MOV     ?V0 + 5,DPH
   \   00001D   78..         MOV     R0,#?V0 + 4
   \   00001F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000022   12....       LCALL   ??Subroutine29_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000025   12....       LCALL   ?DEALLOC_XSTACK8
    304            HalLcdWriteString( (char*)buf, option );
   \   000028                ; Setup parameters for call to function HalLcdWriteString
   \   000028   EE           MOV     A,R6
   \   000029   F9           MOV     R1,A
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   AA82         MOV     R2,DPL
   \   000032   AB83         MOV     R3,DPH
   \   000034   12....       LCALL   ??HalLcdWriteString?relay
    305          #endif
    306          }
   \   000037   7419         MOV     A,#0x19
   \   000039   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003C                REQUIRE ?Subroutine21
   \   00003C                ; // Fall through to label ?Subroutine21

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine29_0:
   \   000000   12....       LCALL   ??_ltoa?relay
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET
    307          
    308          /**************************************************************************************************
    309           * @fn      HalLcdWriteScreen
    310           *
    311           * @brief   Write a value to the LCD
    312           *
    313           * @param   line1  - string that will be displayed on line 1
    314           *          line2  - string that will be displayed on line 2
    315           *
    316           * @return  None
    317           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    318          void HalLcdWriteScreen( char *line1, char *line2 )
   \                     HalLcdWriteScreen:
    319          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
    320          #if (HAL_LCD == TRUE)
    321            HalLcdWriteString( line1, 1 );
   \   000009                ; Setup parameters for call to function HalLcdWriteString
   \   000009   7901         MOV     R1,#0x1
   \   00000B   12....       LCALL   ??HalLcdWriteString?relay
    322            HalLcdWriteString( line2, 2 );
   \   00000E                ; Setup parameters for call to function HalLcdWriteString
   \   00000E   7902         MOV     R1,#0x2
   \   000010   EE           MOV     A,R6
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??HalLcdWriteString?relay
    323          #endif
    324          }
   \   000017   02....       LJMP    ?Subroutine23 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    325          
    326          /**************************************************************************************************
    327           * @fn      HalLcdWriteStringValue
    328           *
    329           * @brief   Write a string followed by a value to the LCD
    330           *
    331           * @param   title  - Title that will be displayed before the value
    332           *          value  - value
    333           *          format - redix
    334           *          line   - line number
    335           *
    336           * @return  None
    337           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    338          void HalLcdWriteStringValue( char *title, uint16 value, uint8 format, uint8 line )
   \                     HalLcdWriteStringValue:
    339          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 25
   \   000005   74E7         MOV     A,#-0x19
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 6,R4
   \   000010   8D..         MOV     ?V0 + 7,R5
   \   000012   89..         MOV     ?V0 + 4,R1
   \   000014   742B         MOV     A,#0x2b
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F5..         MOV     ?V0 + 3,A
    340          #if (HAL_LCD == TRUE)
    341            uint8 tmpLen;
    342            uint8 buf[LCD_MAX_BUF];
    343            uint32 err;
    344          
    345            tmpLen = (uint8)osal_strlen( (char*)title );
   \   00001C                ; Setup parameters for call to function osal_strlen
   \   00001C   12....       LCALL   ?Subroutine4 & 0xFFFF
    346            osal_memcpy( buf, title, tmpLen );
   \                     ??CrossCallReturnLabel_2:
   \   00001F                ; Setup parameters for call to function osal_memcpy
   \   00001F   8E..         MOV     ?V0 + 0,R6
   \   000021   8F..         MOV     ?V0 + 1,R7
   \   000023   75..00       MOV     ?V0 + 2,#0x0
   \   000026   78..         MOV     R0,#?V0 + 0
   \   000028   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00002B   EA           MOV     A,R2
   \   00002C   FC           MOV     R4,A
   \   00002D   7D00         MOV     R5,#0x0
   \   00002F   7403         MOV     A,#0x3
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000037   12....       LCALL   ?DEALLOC_XSTACK8
    347            buf[tmpLen] = ' ';
   \   00003A   85..82       MOV     DPL,?XSP + 0
   \   00003D   85..83       MOV     DPH,?XSP + 1
   \   000040   E582         MOV     A,DPL
   \   000042   25..         ADD     A,?V0 + 8
   \   000044   12....       LCALL   ?Subroutine0 & 0xFFFF
    348            err = (uint32)(value);
    349            _ltoa( err, &buf[tmpLen+1], format );
   \                     ??CrossCallReturnLabel_29:
   \   000047                ; Setup parameters for call to function _ltoa
   \   000047   A3           INC     DPTR
   \   000048   8582..       MOV     ?V0 + 0,DPL
   \   00004B   8583..       MOV     ?V0 + 1,DPH
   \   00004E   78..         MOV     R0,#?V0 + 0
   \   000050   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000053   A9..         MOV     R1,?V0 + 4
   \   000055   AA..         MOV     R2,?V0 + 6
   \   000057   AB..         MOV     R3,?V0 + 7
   \   000059   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   00005C   12....       LCALL   ?DEALLOC_XSTACK8
    350            HalLcdWriteString( (char*)buf, line );		
   \   00005F                ; Setup parameters for call to function HalLcdWriteString
   \   00005F   A9..         MOV     R1,?V0 + 3
   \   000061                REQUIRE ?Subroutine24
   \   000061                ; // Fall through to label ?Subroutine24
    351          #endif
    352          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   AA82         MOV     R2,DPL
   \   000008   AB83         MOV     R3,DPH
   \   00000A   12....       LCALL   ??HalLcdWriteString?relay
   \   00000D   7419         MOV     A,#0x19
   \   00000F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000012   7F0A         MOV     R7,#0xa
   \   000014   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   F582         MOV     DPL,A
   \   000002   E583         MOV     A,DPH
   \   000004                REQUIRE ??Subroutine26_0
   \   000004                ; // Fall through to label ??Subroutine26_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ??osal_strlen?relay
   \   000003   EA           MOV     A,R2
   \   000004   F5..         MOV     ?V0 + 8,A
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004                REQUIRE ??Subroutine27_0
   \   000004                ; // Fall through to label ??Subroutine27_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine28_0:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004                REQUIRE ??Subroutine29_0
   \   000004                ; // Fall through to label ??Subroutine29_0
    353          
    354          /**************************************************************************************************
    355           * @fn      HalLcdWriteStringValue
    356           *
    357           * @brief   Write a string followed by a value to the LCD
    358           *
    359           * @param   title   - Title that will be displayed before the value
    360           *          value1  - value #1
    361           *          format1 - redix of value #1
    362           *          value2  - value #2
    363           *          format2 - redix of value #2
    364           *          line    - line number
    365           *
    366           * @return  None
    367           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    368          void HalLcdWriteStringValueValue( char *title, uint16 value1, uint8 format1,
   \                     HalLcdWriteStringValueValue:
    369                                            uint16 value2, uint8 format2, uint8 line )
    370          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 25
   \   000005   74E7         MOV     A,#-0x19
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
   \   000012   89..         MOV     ?V0 + 7,R1
   \   000014   742B         MOV     A,#0x2b
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FE           MOV     R6,A
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   FF           MOV     R7,A
   \   00001E   742D         MOV     A,#0x2d
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 3,A
   \   000026   742E         MOV     A,#0x2e
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F5..         MOV     ?V0 + 2,A
    371          
    372          #if (HAL_LCD == TRUE)
    373          
    374            uint8 tmpLen;
    375            uint8 buf[LCD_MAX_BUF];
    376            uint32 err;
    377          
    378            tmpLen = (uint8)osal_strlen( (char*)title );
   \   00002E                ; Setup parameters for call to function osal_strlen
   \   00002E   12....       LCALL   ?Subroutine4 & 0xFFFF
    379            if ( tmpLen )
   \                     ??CrossCallReturnLabel_3:
   \   000031   6028         JZ      ??HalLcdWriteStringValueValue_0
    380            {
    381              osal_memcpy( buf, title, tmpLen );
   \   000033                ; Setup parameters for call to function osal_memcpy
   \   000033   75..00       MOV     ?V0 + 6,#0x0
   \   000036   78..         MOV     R0,#?V0 + 4
   \   000038   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00003B   EA           MOV     A,R2
   \   00003C   F5..         MOV     ?V0 + 4,A
   \   00003E   FC           MOV     R4,A
   \   00003F   7D00         MOV     R5,#0x0
   \   000041   7403         MOV     A,#0x3
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000049   12....       LCALL   ?DEALLOC_XSTACK8
    382              buf[tmpLen++] = ' ';
   \   00004C   85..82       MOV     DPL,?XSP + 0
   \   00004F   85..83       MOV     DPH,?XSP + 1
   \   000052   E582         MOV     A,DPL
   \   000054   25..         ADD     A,?V0 + 4
   \   000056   12....       LCALL   ?Subroutine0 & 0xFFFF
    383            }
   \                     ??CrossCallReturnLabel_30:
   \   000059   05..         INC     ?V0 + 8
    384          
    385            err = (uint32)(value1);
    386            _ltoa( err, &buf[tmpLen], format1 );
   \                     ??HalLcdWriteStringValueValue_0:
   \   00005B                ; Setup parameters for call to function _ltoa
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   E582         MOV     A,DPL
   \   000063   25..         ADD     A,?V0 + 8
   \   000065   F5..         MOV     ?V0 + 4,A
   \   000067   E583         MOV     A,DPH
   \   000069   3400         ADDC    A,#0x0
   \   00006B   F5..         MOV     ?V0 + 5,A
   \   00006D   78..         MOV     R0,#?V0 + 4
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000072   A9..         MOV     R1,?V0 + 7
   \   000074   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
    387            tmpLen = (uint8)osal_strlen( (char*)buf );
   \   00007A                ; Setup parameters for call to function osal_strlen
   \   00007A   85..82       MOV     DPL,?XSP + 0
   \   00007D   85..83       MOV     DPH,?XSP + 1
   \   000080   AA82         MOV     R2,DPL
   \   000082   AB83         MOV     R3,DPH
   \   000084   12....       LCALL   ?Subroutine4 & 0xFFFF
    388          
    389            buf[tmpLen++] = ',';
   \                     ??CrossCallReturnLabel_4:
   \   000087   F5..         MOV     ?V0 + 0,A
   \   000089   85..82       MOV     DPL,?XSP + 0
   \   00008C   85..83       MOV     DPH,?XSP + 1
   \   00008F   E582         MOV     A,DPL
   \   000091   25..         ADD     A,?V0 + 0
   \   000093   F582         MOV     DPL,A
   \   000095   E583         MOV     A,DPH
   \   000097   3400         ADDC    A,#0x0
   \   000099   F583         MOV     DPH,A
   \   00009B   742C         MOV     A,#0x2c
   \   00009D   F0           MOVX    @DPTR,A
   \   00009E   05..         INC     ?V0 + 8
    390            buf[tmpLen++] = ' ';
   \   0000A0   85....       MOV     ?V0 + 0,?V0 + 8
   \   0000A3   85..82       MOV     DPL,?XSP + 0
   \   0000A6   85..83       MOV     DPH,?XSP + 1
   \   0000A9   E582         MOV     A,DPL
   \   0000AB   25..         ADD     A,?V0 + 0
   \   0000AD   12....       LCALL   ?Subroutine0 & 0xFFFF
    391            err = (uint32)(value2);
    392            _ltoa( err, &buf[tmpLen], format2 );
   \                     ??CrossCallReturnLabel_31:
   \   0000B0                ; Setup parameters for call to function _ltoa
   \   0000B0   7401         MOV     A,#0x1
   \   0000B2   25..         ADD     A,?V0 + 8
   \   0000B4   F8           MOV     R0,A
   \   0000B5   85..82       MOV     DPL,?XSP + 0
   \   0000B8   85..83       MOV     DPH,?XSP + 1
   \   0000BB   E582         MOV     A,DPL
   \   0000BD   28           ADD     A,R0
   \   0000BE   F5..         MOV     ?V0 + 0,A
   \   0000C0   E583         MOV     A,DPH
   \   0000C2   3400         ADDC    A,#0x0
   \   0000C4   F5..         MOV     ?V0 + 1,A
   \   0000C6   78..         MOV     R0,#?V0 + 0
   \   0000C8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CB   A9..         MOV     R1,?V0 + 3
   \   0000CD   8E..         MOV     ?V0 + 0,R6
   \   0000CF   8F..         MOV     ?V0 + 1,R7
   \   0000D1   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   0000D4   12....       LCALL   ?DEALLOC_XSTACK8
    393          
    394            HalLcdWriteString( (char *)buf, line );		
   \   0000D7                ; Setup parameters for call to function HalLcdWriteString
   \   0000D7   A9..         MOV     R1,?V0 + 2
   \   0000D9   02....       LJMP    ?Subroutine24 & 0xFFFF
    395          
    396          #endif
    397          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   AA..         MOV     R2,?V0 + 0
   \   000002   AB..         MOV     R3,?V0 + 1
   \   000004                REQUIRE ??Subroutine28_0
   \   000004                ; // Fall through to label ??Subroutine28_0
    398          
    399          /**************************************************************************************************
    400           * @fn      HalLcdDisplayPercentBar
    401           *
    402           * @brief   Display percentage bar on the LCD
    403           *
    404           * @param   title   -
    405           *          value   -
    406           *
    407           * @return  None
    408           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    409          void HalLcdDisplayPercentBar( char *title, uint8 value )
   \                     HalLcdDisplayPercentBar:
    410          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    411          #if (HAL_LCD == TRUE)
    412          
    413            uint8 percent;
    414            uint8 leftOver;
    415            uint8 buf[17];
    416            uint32 err;
    417            uint8 x;
    418          
    419            /* Write the title: */
    420            HalLcdWriteString( title, HAL_LCD_LINE_1 );
   \   00000C                ; Setup parameters for call to function HalLcdWriteString
   \   00000C   7901         MOV     R1,#0x1
   \   00000E   12....       LCALL   ??HalLcdWriteString?relay
    421          
    422            if ( value > 100 )
   \   000011   EE           MOV     A,R6
   \   000012   C3           CLR     C
   \   000013   9465         SUBB    A,#0x65
   \   000015   4002         JC      ??HalLcdDisplayPercentBar_0
    423              value = 100;
   \   000017   7E64         MOV     R6,#0x64
    424          
    425            /* convert to blocks */
    426            percent = (uint8)(value / 10);
   \                     ??HalLcdDisplayPercentBar_0:
   \   000019   75F00A       MOV     B,#0xa
   \   00001C   EE           MOV     A,R6
   \   00001D   84           DIV     AB
   \   00001E   FF           MOV     R7,A
    427            leftOver = (uint8)(value % 10);
   \   00001F   EE           MOV     A,R6
   \   000020   75F00A       MOV     B,#0xa
   \   000023   84           DIV     AB
   \   000024   E5F0         MOV     A,B
   \   000026   F5..         MOV     ?V0 + 0,A
    428          
    429            /* Make window */
    430            osal_memcpy( buf, "[          ]  ", 15 );
   \   000028                ; Setup parameters for call to function osal_memcpy
   \   000028   75....       MOV     ?V0 + 4,#(`?<Constant "[          ]  ">` & 0xff)
   \   00002B   75....       MOV     ?V0 + 5,#((`?<Constant "[          ]  ">` >> 8) & 0xff)
   \   00002E   75..00       MOV     ?V0 + 6,#0x0
   \   000031   78..         MOV     R0,#?V0 + 4
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000036   7C0F         MOV     R4,#0xf
   \   000038   7D00         MOV     R5,#0x0
   \   00003A   7403         MOV     A,#0x3
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000042   12....       LCALL   ?DEALLOC_XSTACK8
    431          
    432            for ( x = 0; x < percent; x ++ )
   \   000045   7A00         MOV     R2,#0x0
   \   000047   8004         SJMP    ??HalLcdDisplayPercentBar_1
    433            {
    434              buf[1+x] = '>';
   \                     ??HalLcdDisplayPercentBar_2:
   \   000049   743E         MOV     A,#0x3e
   \   00004B   F0           MOVX    @DPTR,A
    435            }
   \   00004C   0A           INC     R2
   \                     ??HalLcdDisplayPercentBar_1:
   \   00004D   8A..         MOV     ?V0 + 2,R2
   \   00004F   85..82       MOV     DPL,?XSP + 0
   \   000052   85..83       MOV     DPH,?XSP + 1
   \   000055   E582         MOV     A,DPL
   \   000057   25..         ADD     A,?V0 + 2
   \   000059   F582         MOV     DPL,A
   \   00005B   E583         MOV     A,DPH
   \   00005D   3400         ADDC    A,#0x0
   \   00005F   F583         MOV     DPH,A
   \   000061   A3           INC     DPTR
   \   000062   EA           MOV     A,R2
   \   000063   C3           CLR     C
   \   000064   9F           SUBB    A,R7
   \   000065   40E2         JC      ??HalLcdDisplayPercentBar_2
    436          
    437            if ( leftOver >= 5 )
   \   000067   E5..         MOV     A,?V0 + 0
   \   000069   C3           CLR     C
   \   00006A   9405         SUBB    A,#0x5
   \   00006C   4003         JC      ??HalLcdDisplayPercentBar_3
    438              buf[1+x] = '+';
   \   00006E   742B         MOV     A,#0x2b
   \   000070   F0           MOVX    @DPTR,A
    439          
    440            err = (uint32)value;
    441            _ltoa( err, (uint8*)&buf[13], 10 );
   \                     ??HalLcdDisplayPercentBar_3:
   \   000071                ; Setup parameters for call to function _ltoa
   \   000071   740D         MOV     A,#0xd
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   8582..       MOV     ?V0 + 0,DPL
   \   000079   8583..       MOV     ?V0 + 1,DPH
   \   00007C   78..         MOV     R0,#?V0 + 0
   \   00007E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000081   790A         MOV     R1,#0xa
   \   000083   EE           MOV     A,R6
   \   000084   FA           MOV     R2,A
   \   000085   7B00         MOV     R3,#0x0
   \   000087   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00008A   12....       LCALL   ?DEALLOC_XSTACK8
    442          
    443            HalLcdWriteString( (char*)buf, HAL_LCD_LINE_2 );
   \   00008D                ; Setup parameters for call to function HalLcdWriteString
   \   00008D   7902         MOV     R1,#0x2
   \   00008F   85..82       MOV     DPL,?XSP + 0
   \   000092   85..83       MOV     DPH,?XSP + 1
   \   000095   AA82         MOV     R2,DPL
   \   000097   AB83         MOV     R3,DPH
   \   000099   12....       LCALL   ??HalLcdWriteString?relay
    444          
    445          #endif
    446          
    447          }
   \   00009C   7411         MOV     A,#0x11
   \   00009E   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A1   7F07         MOV     R7,#0x7
   \   0000A3   02....       LJMP    ?BANKED_LEAVE_XDATA
    448          
    449          
    450          #if (HAL_LCD == TRUE)
    451          /**************************************************************************************************
    452           *                                    HARDWARE LCD
    453           **************************************************************************************************/
    454          
    455          /*******************************************************************************
    456           * @fn      initLcd
    457           *
    458           * @brief   Initilize HW LCD Driver.
    459           *
    460           * @param   None
    461           *
    462           * @return  None
    463           ******************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    464          void initLcd(void)
   \                     initLcd:
    465          {   
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    466            
    467              // LCD Setting output
    468              HAL_LCD_EN_OUTPUT();
   \   000004   53F5FE       ANL     0xf5,#0xfe
   \   000007   43FF01       ORL     0xff,#0x1
    469              HAL_LCD_RS_OUTPUT();	
   \   00000A   53F3BF       ANL     0xf3,#0xbf
   \   00000D   43FD40       ORL     0xfd,#0x40
    470              HAL_LCD_DATA_OUTPUT();
   \   000010   E5F4         MOV     A,0xf4
   \   000012   75F400       MOV     0xf4,#0x0
   \   000015   E5FE         MOV     A,0xfe
   \   000017   75FEFF       MOV     0xfe,#-0x1
    471              
    472              // Perform the initialization sequence
    473              HAL_LCD_RS_DIR_OUTPUT();  
   \   00001A   43FD40       ORL     0xfd,#0x40
    474              HAL_LCD_EN_CLR();
   \   00001D   C2A0         CLR     0xa0.0
    475              halMcuWaitMs(30);
   \   00001F                ; Setup parameters for call to function halMcuWaitMs
   \   00001F   7A1E         MOV     R2,#0x1e
   \   000021   12....       LCALL   ?Subroutine7 & 0xFFFF
    476          
    477              FUNCTION_SET(BUS_8BIT_ON);
    478              halMcuWaitMs(2);
    479              FUNCTION_SET(BUS_8BIT_ON);
   \                     ??CrossCallReturnLabel_5:
   \   000024                ; Setup parameters for call to function lcdCommand
   \   000024   7930         MOV     R1,#0x30
   \   000026   12....       LCALL   ??lcdCommand?relay
    480              halMcuWaitMs(2);
   \   000029                ; Setup parameters for call to function halMcuWaitMs
   \   000029   7A02         MOV     R2,#0x2
   \   00002B   12....       LCALL   ?Subroutine7 & 0xFFFF
    481              FUNCTION_SET(BUS_8BIT_ON);
    482              halMcuWaitMs(2);
    483              FUNCTION_SET(BUS_8BIT_ON | DUAL_LINE_ON);
   \                     ??CrossCallReturnLabel_6:
   \   00002E                ; Setup parameters for call to function lcdCommand
   \   00002E   12....       LCALL   ?Subroutine8 & 0xFFFF
    484              halMcuWaitMs(2);
    485              FUNCTION_SET(BUS_8BIT_ON | DUAL_LINE_ON);
   \                     ??CrossCallReturnLabel_43:
   \   000031                ; Setup parameters for call to function lcdCommand
   \   000031   12....       LCALL   ?Subroutine8 & 0xFFFF
    486              halMcuWaitMs(2);
    487              SET_CURSOR_SHIFT(SHITF_DISPLAY_OFF);
   \                     ??CrossCallReturnLabel_44:
   \   000034                ; Setup parameters for call to function lcdCommand
   \   000034   7910         MOV     R1,#0x10
   \   000036   12....       LCALL   ??lcdCommand?relay
    488              SET_ENTER_MODE(INCREMENT_ON);
   \   000039                ; Setup parameters for call to function lcdCommand
   \   000039   7906         MOV     R1,#0x6
   \   00003B   12....       LCALL   ??lcdCommand?relay
    489              DISPLAY_CLEAR();
   \   00003E                ; Setup parameters for call to function lcdCommand
   \   00003E   7901         MOV     R1,#0x1
   \   000040   12....       LCALL   ??Subroutine30_0 & 0xFFFF
    490              halMcuWaitMs(2);
    491              // Clear the display
    492              HalLcd_HW_Clear();
   \                     ??CrossCallReturnLabel_45:
   \   000043                ; Setup parameters for call to function HalLcd_HW_Clear
   \   000043   12....       LCALL   ??HalLcd_HW_Clear?relay
    493              SET_DISPLAY_CTRL(DISPLAY_CTRL_ON | DISPLAY_CTRL_BLINK_OFF | DISPLAY_CTRL_CURSOR_OFF);
   \   000046                ; Setup parameters for call to function lcdCommand
   \   000046   790C         MOV     R1,#0xc
   \   000048   12....       LCALL   ??lcdCommand?relay
    494          }
   \   00004B   02....       LJMP    ??Subroutine25_0 & 0xFFFF
   \   00004E                REQUIRE _A_P2
   \   00004E                REQUIRE P0SEL
   \   00004E                REQUIRE P1SEL
   \   00004E                REQUIRE P2SEL
   \   00004E                REQUIRE P0DIR
   \   00004E                REQUIRE P1DIR
   \   00004E                REQUIRE P2DIR

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7938         MOV     R1,#0x38
   \   000002                REQUIRE ??Subroutine30_0
   \   000002                ; // Fall through to label ??Subroutine30_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine30_0:
   \   000000   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   12....       LCALL   ??halMcuWaitMs?relay
   \   000005                ; Setup parameters for call to function lcdCommand
   \   000005                ; Setup parameters for call to function lcdCommand
   \   000005   7930         MOV     R1,#0x30
   \   000007   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ??lcdCommand?relay
   \   000003                ; Setup parameters for call to function halMcuWaitMs
   \   000003                ; Setup parameters for call to function halMcuWaitMs
   \   000003                ; Setup parameters for call to function halMcuWaitMs
   \   000003                ; Setup parameters for call to function halMcuWaitMs
   \   000003                ; Setup parameters for call to function halMcuWaitMs
   \   000003   7A02         MOV     R2,#0x2
   \   000005   7B00         MOV     R3,#0x0
   \   000007   12....       LCALL   ??halMcuWaitMs?relay
   \   00000A   22           RET
    495          
    496          /*******************************************************************************
    497           * @fn      HalLcd_HW_Control
    498           *
    499           * @brief   Write 1 command to the LCD
    500           *
    501           * @param   uint8 cmd - command to be written to the LCD
    502           *
    503           * @return  None
    504           ******************************************************************************/
    505          //-------------------------------------------------------------------
    506          // @fn          lcdCommand
    507          // @brief       Send command to display
    508          // @param       uint8 command
    509          // @return      none
    510          //-------------------------------------------------------------------

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000003                REQUIRE ??Subroutine25_0
   \   000003                ; // Fall through to label ??Subroutine25_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    511          static void lcdCommand(uint8 command)
   \                     lcdCommand:
    512          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    513              HAL_LCD_RS_DIR_OUTPUT();
   \   000004   43FD40       ORL     0xfd,#0x40
    514              HAL_LCD_RS_CLR();
   \   000007   C286         CLR     0x80.6
    515              HAL_LCD_DATA(command);
   \   000009   02....       LJMP    ?Subroutine20 & 0xFFFF
   \   00000C                REQUIRE _A_P0
   \   00000C                REQUIRE _A_P1
   \   00000C                REQUIRE _A_P2
   \   00000C                REQUIRE P0DIR
    516              HAL_LCD_EN_SET();
    517              halMcuWaitUs(2);
    518              HAL_LCD_EN_CLR();
    519              halMcuWaitUs(80);
    520              HAL_LCD_DATA(pLedData);
    521          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   8990         MOV     0x90,R1
   \   000002   D2A0         SETB    0xa0.0
   \   000004                ; Setup parameters for call to function halMcuWaitUs
   \   000004                ; Setup parameters for call to function halMcuWaitUs
   \   000004   7A02         MOV     R2,#0x2
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??halMcuWaitUs?relay
   \   00000B   C2A0         CLR     0xa0.0
   \   00000D                ; Setup parameters for call to function halMcuWaitUs
   \   00000D                ; Setup parameters for call to function halMcuWaitUs
   \   00000D   7A50         MOV     R2,#0x50
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ??halMcuWaitUs?relay
   \   000014   90....       MOV     DPTR,#pLedData
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F590         MOV     0x90,A
   \   00001A   22           RET
    522          
    523          /*******************************************************************************
    524           * @fn      HalLcd_HW_Write
    525           *
    526           * @brief   Write 1 byte to the LCD
    527           *
    528           * @param   uint8 data - data to be written to the LCD
    529           *
    530           * @return  None
    531           ******************************************************************************/
    532          //-------------------------------------------------------------------
    533          // @fn          lcdData
    534          // @brief       Write character to display
    535          // @param       uint8 ch - character to display
    536          // @return      none
    537          //-------------------------------------------------------------------

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    538          static void lcdData(uint8 ch)
   \                     lcdData:
    539          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    540              HAL_LCD_RS_DIR_OUTPUT(); 
   \   000004   43FD40       ORL     0xfd,#0x40
    541              HAL_LCD_RS_SET();
   \   000007   D286         SETB    0x80.6
    542              HAL_LCD_DATA(ch);
   \   000009   02....       LJMP    ?Subroutine20 & 0xFFFF
   \   00000C                REQUIRE _A_P0
   \   00000C                REQUIRE _A_P1
   \   00000C                REQUIRE _A_P2
   \   00000C                REQUIRE P0DIR
    543              HAL_LCD_EN_SET();
    544              halMcuWaitUs(2);
    545              HAL_LCD_EN_CLR();
    546              halMcuWaitUs(80);
    547              HAL_LCD_DATA(pLedData);
    548          }
    549          
    550          /**************************************************************************************************
    551           * @fn          HalLcd_HW_SetContrast
    552           *
    553           * @brief       Set display contrast
    554           *
    555           * @param       uint8 value - contrast value
    556           *
    557           * @return      none
    558           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    559          void HalLcd_HW_SetContrast(uint8 value)
   \                     HalLcd_HW_SetContrast:
    560          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    561            SET_ICONRAM_ADDR(CONTRAST_CTRL_REGISTER);
   \   000007                ; Setup parameters for call to function lcdCommand
   \   000007   7950         MOV     R1,#0x50
   \   000009   12....       LCALL   ??Subroutine32_0 & 0xFFFF
    562            lcdData(value);
    563          }
   \                     ??CrossCallReturnLabel_53:
   \   00000C   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine32_0:
   \   000000   12....       LCALL   ??lcdCommand?relay
   \   000003                ; Setup parameters for call to function lcdData
   \   000003                ; Setup parameters for call to function lcdData
   \   000003                ; Setup parameters for call to function lcdData
   \   000003   EE           MOV     A,R6
   \   000004   F9           MOV     R1,A
   \   000005   12....       LCALL   ??lcdData?relay
   \   000008   7F01         MOV     R7,#0x1
   \   00000A   22           RET
    564          
    565          /*******************************************************************************
    566           * @fn      HalLcd_HW_Clear
    567           *
    568           * @brief   Clear the HW LCD
    569           *
    570           * @param   None
    571           *
    572           * @return  None
    573           ******************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    574          void HalLcd_HW_Clear(void)
   \                     HalLcd_HW_Clear:
    575          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    576              uint8 n;
    577              SET_DISPLAY_LINE(LINE1);
   \   000005                ; Setup parameters for call to function lcdCommand
   \   000005   7980         MOV     R1,#-0x80
   \   000007   12....       LCALL   ??lcdCommand?relay
    578              for (n = 0; n < LCD_LINE_LENGTH; n++)
   \   00000A   7E10         MOV     R6,#0x10
    579              {
    580                  lcdData(' ');
   \                     ??HalLcd_HW_Clear_0:
   \   00000C                ; Setup parameters for call to function lcdData
   \   00000C   12....       LCALL   ?Subroutine15 & 0xFFFF
    581              }
   \                     ??CrossCallReturnLabel_48:
   \   00000F   70FB         JNZ     ??HalLcd_HW_Clear_0
    582              SET_DISPLAY_LINE(LINE2);
   \   000011                ; Setup parameters for call to function lcdCommand
   \   000011   79C0         MOV     R1,#-0x40
   \   000013   12....       LCALL   ??lcdCommand?relay
    583              for (n = 0; n < LCD_LINE_LENGTH; n++)
   \   000016   7E10         MOV     R6,#0x10
    584              {
    585                  lcdData(' ');
   \                     ??HalLcd_HW_Clear_1:
   \   000018                ; Setup parameters for call to function lcdData
   \   000018   12....       LCALL   ?Subroutine15 & 0xFFFF
    586              }
   \                     ??CrossCallReturnLabel_49:
   \   00001B   70FB         JNZ     ??HalLcd_HW_Clear_1
    587          }
   \   00001D   80..         SJMP    ?Subroutine23

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   7920         MOV     R1,#0x20
   \   000002                REQUIRE ??Subroutine31_0
   \   000002                ; // Fall through to label ??Subroutine31_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine31_0:
   \   000000   12....       LCALL   ??lcdData?relay
   \   000003   1E           DEC     R6
   \   000004   EE           MOV     A,R6
   \   000005   22           RET
    588          /*******************************************************************************
    589           * @fn      HalLcd_ClearLine
    590           *
    591           * @brief   Clear one line on display
    592           *
    593           * @param   uint8 line - display line
    594           *
    595           * @return  None
    596           ******************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    597          void HalLcd_ClearLine(uint8 line)
   \                     HalLcd_ClearLine:
    598          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    599             uint8 n;
    600              if (line == HAL_LCD_LINE_2)
   \   000005   7402         MOV     A,#0x2
   \   000007   69           XRL     A,R1
   \   000008   7004         JNZ     ??HalLcd_ClearLine_0
    601              {
    602                  SET_DISPLAY_LINE(LINE2);
   \   00000A                ; Setup parameters for call to function lcdCommand
   \   00000A   79C0         MOV     R1,#-0x40
   \   00000C   8002         SJMP    ??HalLcd_ClearLine_1
    603              }
    604              else
    605              {
    606                  SET_DISPLAY_LINE(LINE1);
   \                     ??HalLcd_ClearLine_0:
   \   00000E                ; Setup parameters for call to function lcdCommand
   \   00000E   7980         MOV     R1,#-0x80
   \                     ??HalLcd_ClearLine_1:
   \   000010   12....       LCALL   ??lcdCommand?relay
    607              }
    608              for (n = 0; n < LCD_LINE_LENGTH; n++)
   \   000013   7E10         MOV     R6,#0x10
    609              {
    610                  lcdData(' ');
   \                     ??HalLcd_ClearLine_2:
   \   000015                ; Setup parameters for call to function lcdData
   \   000015   12....       LCALL   ?Subroutine15 & 0xFFFF
    611              }
   \                     ??CrossCallReturnLabel_50:
   \   000018   70FB         JNZ     ??HalLcd_ClearLine_2
    612          }
   \   00001A                REQUIRE ?Subroutine23
   \   00001A                ; // Fall through to label ?Subroutine23
    613          
    614          
    615          /**************************************************************************************************
    616           * @fn      HalLcd_HW_ClearAllSpecChars
    617           *
    618           * @brief   Clear all special chars
    619           *
    620           * @param   None
    621           *
    622           * @return  None
    623           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    624          void HalLcd_HW_ClearAllSpecChars(void)
   \                     HalLcd_HW_ClearAllSpecChars:
    625          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    626            uint8 n = 0;
    627          
    628            SET_GCRAM_CHAR(0);
   \   000005                ; Setup parameters for call to function lcdCommand
   \   000005   7940         MOV     R1,#0x40
   \   000007   12....       LCALL   ??lcdCommand?relay
    629            for (n = 0; n < (8 * 8); n++)
   \   00000A   7E40         MOV     R6,#0x40
    630            {
    631              lcdData(0x00);
   \                     ??HalLcd_HW_ClearAllSpecChars_0:
   \   00000C                ; Setup parameters for call to function lcdData
   \   00000C   7900         MOV     R1,#0x0
   \   00000E   12....       LCALL   ??Subroutine31_0 & 0xFFFF
    632            }
   \                     ??CrossCallReturnLabel_51:
   \   000011   70F9         JNZ     ??HalLcd_HW_ClearAllSpecChars_0
    633          }
   \   000013   80..         SJMP    ?Subroutine23
    634          
    635          /*******************************************************************************
    636           * @fn      HalLcd_HW_WriteChar
    637           *
    638           * @brief   Write one char to the display
    639           *
    640           * @param   uint8 line - line number that the char will be displayed
    641           *          uint8 col - colum where the char will be displayed
    642           *
    643           * @return  None
    644           ******************************************************************************/
    645          /************************************************************
    646           * @fn      HalLcd_HW_WriteChar
    647          ************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    648          static void lcdUpdateChar( uint8 line, uint8 col, char ch )
   \                     lcdUpdateChar:
    649          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EB           MOV     A,R3
   \   000006   FE           MOV     R6,A
    650              if (line == HAL_LCD_LINE_2)
   \   000007   7402         MOV     A,#0x2
   \   000009   69           XRL     A,R1
   \   00000A   7007         JNZ     ??lcdUpdateChar_0
    651              {
    652                  SET_DISPLAY_LINE(LINE2 + col);
   \   00000C                ; Setup parameters for call to function lcdCommand
   \   00000C   7440         MOV     A,#0x40
   \   00000E   2A           ADD     A,R2
   \   00000F   4480         ORL     A,#0x80
   \   000011   8003         SJMP    ??lcdUpdateChar_1
    653              }
    654              else
    655              {
    656                  SET_DISPLAY_LINE(LINE1 + col);
   \                     ??lcdUpdateChar_0:
   \   000013                ; Setup parameters for call to function lcdCommand
   \   000013   7480         MOV     A,#-0x80
   \   000015   4A           ORL     A,R2
    657              }
   \                     ??lcdUpdateChar_1:
   \   000016                REQUIRE ?Subroutine22
   \   000016                ; // Fall through to label ?Subroutine22
    658              lcdData(ch);
    659          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000003   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   F9           MOV     R1,A
   \   000001                REQUIRE ??Subroutine32_0
   \   000001                ; // Fall through to label ??Subroutine32_0
    660          /*********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    661          void HalLcdWriteChar( uint8 line, uint8 col, char ch )
   \                     HalLcdWriteChar:
    662          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EB           MOV     A,R3
   \   000006   FE           MOV     R6,A
    663              if (line == HAL_LCD_LINE_2)
   \   000007   7402         MOV     A,#0x2
   \   000009   69           XRL     A,R1
   \   00000A   7007         JNZ     ??HalLcdWriteChar_0
    664              {
    665                  SET_DISPLAY_LINE(LINE2 + col);
   \   00000C                ; Setup parameters for call to function lcdCommand
   \   00000C   7440         MOV     A,#0x40
   \   00000E   2A           ADD     A,R2
   \   00000F   4480         ORL     A,#0x80
   \   000011   8003         SJMP    ??HalLcdWriteChar_1
    666              }
    667              else
    668              {
    669                  SET_DISPLAY_LINE(LINE1 + col);
   \                     ??HalLcdWriteChar_0:
   \   000013                ; Setup parameters for call to function lcdCommand
   \   000013   7480         MOV     A,#-0x80
   \   000015   4A           ORL     A,R2
    670              }
   \                     ??HalLcdWriteChar_1:
   \   000016   80..         SJMP    ?Subroutine22
    671              lcdData(ch);
    672          }
    673          
    674          /**************************************************************************************************
    675           * @fn          halLcdWriteLine
    676           *
    677           * @brief       Write one line on display
    678           *
    679           * @param       uint8 line - display line
    680           *              char *pText - text buffer to write
    681           *
    682           * @return      none
    683           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    684          void HalLcd_HW_WriteLine(uint8 line, const char *pText)
   \                     HalLcd_HW_WriteLine:
    685          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 1,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    686            uint8 count;
    687            uint8 totalLength = (uint8)osal_strlen( (char *)pText );
   \   00000B                ; Setup parameters for call to function osal_strlen
   \   00000B   12....       LCALL   ??osal_strlen?relay
   \   00000E   EA           MOV     A,R2
   \   00000F   F5..         MOV     ?V0 + 2,A
    688          
    689            /* Write the content first */
    690            for (count=0; count<totalLength; count++)
   \   000011   75..00       MOV     ?V0 + 0,#0x0
   \   000014   8018         SJMP    ??HalLcd_HW_WriteLine_0
    691            {
    692              lcdUpdateChar(line, count, (*(pText++)));
   \                     ??HalLcd_HW_WriteLine_1:
   \   000016                ; Setup parameters for call to function lcdUpdateChar
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FB           MOV     R3,A
   \   00001C   AA..         MOV     R2,?V0 + 0
   \   00001E   A9..         MOV     R1,?V0 + 1
   \   000020   12....       LCALL   ??lcdUpdateChar?relay
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   A3           INC     DPTR
   \   000028   AE82         MOV     R6,DPL
   \   00002A   AF83         MOV     R7,DPH
    693            }
   \   00002C   05..         INC     ?V0 + 0
   \                     ??HalLcd_HW_WriteLine_0:
   \   00002E   E5..         MOV     A,?V0 + 0
   \   000030   C3           CLR     C
   \   000031   95..         SUBB    A,?V0 + 2
   \   000033   40E1         JC      ??HalLcd_HW_WriteLine_1
    694          
    695            /* Write blank spaces to rest of the line */
    696            for(count=totalLength; count<LCD_LINE_LENGTH;count++)
   \   000035   85....       MOV     ?V0 + 0,?V0 + 2
   \   000038   800B         SJMP    ??HalLcd_HW_WriteLine_2
    697            {
    698              lcdUpdateChar(line, count, ' ');
   \                     ??HalLcd_HW_WriteLine_3:
   \   00003A                ; Setup parameters for call to function lcdUpdateChar
   \   00003A   7B20         MOV     R3,#0x20
   \   00003C   AA..         MOV     R2,?V0 + 0
   \   00003E   A9..         MOV     R1,?V0 + 1
   \   000040   12....       LCALL   ??lcdUpdateChar?relay
    699            }
   \   000043   05..         INC     ?V0 + 0
   \                     ??HalLcd_HW_WriteLine_2:
   \   000045   E5..         MOV     A,?V0 + 0
   \   000047   C3           CLR     C
   \   000048   9410         SUBB    A,#0x10
   \   00004A   40EE         JC      ??HalLcd_HW_WriteLine_3
    700          }
   \   00004C   7F03         MOV     R7,#0x3
   \   00004E   02....       LJMP    ?BANKED_LEAVE_XDATA
    701          
    702          /*******************************************************************************
    703           * @fn      HalLcd_HW_WaitUs
    704           *
    705           * @brief   wait for x us. @ 32MHz MCU clock it takes 32 "nop"s for 1 us delay.
    706           *
    707           * @param   x us. range[0-65536]
    708           *
    709           * @return  None
    710           ******************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    711          void HalLcd_HW_WaitUs(uint16 microSecs)
   \                     HalLcd_HW_WaitUs:
    712          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   8020         SJMP    ??HalLcd_HW_WaitUs_0
    713            while(microSecs--)
    714            {
    715              /* 32 NOPs == 1 usecs */
    716              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
   \                     ??HalLcd_HW_WaitUs_1:
   \   000002   00           nop
   \   000003   00           nop
   \   000004   00           nop
   \   000005   00           nop
   \   000006   00           nop
    717              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
   \   000007   00           nop
   \   000008   00           nop
   \   000009   00           nop
   \   00000A   00           nop
   \   00000B   00           nop
    718              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
   \   00000C   00           nop
   \   00000D   00           nop
   \   00000E   00           nop
   \   00000F   00           nop
   \   000010   00           nop
    719              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
   \   000011   00           nop
   \   000012   00           nop
   \   000013   00           nop
   \   000014   00           nop
   \   000015   00           nop
    720              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
   \   000016   00           nop
   \   000017   00           nop
   \   000018   00           nop
   \   000019   00           nop
   \   00001A   00           nop
    721              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
   \   00001B   00           nop
   \   00001C   00           nop
   \   00001D   00           nop
   \   00001E   00           nop
   \   00001F   00           nop
    722              asm("nop"); asm("nop");
   \   000020   00           nop
   \   000021   00           nop
    723            }
   \                     ??HalLcd_HW_WaitUs_0:
   \   000022   EA           MOV     A,R2
   \   000023   F8           MOV     R0,A
   \   000024   EB           MOV     A,R3
   \   000025   F9           MOV     R1,A
   \   000026   74FF         MOV     A,#-0x1
   \   000028   28           ADD     A,R0
   \   000029   1A           DEC     R2
   \   00002A   74FF         MOV     A,#-0x1
   \   00002C   39           ADDC    A,R1
   \   00002D   FB           MOV     R3,A
   \   00002E   E8           MOV     A,R0
   \   00002F   7001         JNZ     ??HalLcd_HW_WaitUs_2
   \   000031   E9           MOV     A,R1
   \                     ??HalLcd_HW_WaitUs_2:
   \   000032   70CE         JNZ     ??HalLcd_HW_WaitUs_1
    724          }
   \   000034   02....       LJMP    ?BRET
    725          
    726          /*******************************************************************************
    727          * @fn          convInt32ToText
    728          * @brief       Converts 32 bit int to text
    729          * @param       int32 value
    730          * @return      char* - pointer to text buffer which is a file scope allocated array
    731           ******************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    732          char *convInt32ToText(int32 value)
   \                     convInt32ToText:
    733          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 4,R2
   \   000007   8B..         MOV     ?V0 + 5,R3
   \   000009   8C..         MOV     ?V0 + 6,R4
   \   00000B   8D..         MOV     ?V0 + 7,R5
    734              static char pValueToTextBuffer[12];
    735              char *pLast;
    736              char *pFirst;
    737              char last;
    738              uint8 negative;
    739          
    740              pLast = pValueToTextBuffer;
   \   00000D   7A..         MOV     R2,#(??pValueToTextBuffer & 0xff)
   \   00000F   7B..         MOV     R3,#((??pValueToTextBuffer >> 8) & 0xff)
    741          
    742              // Record the sign of the value
    743              negative = (value < 0);
   \   000011   90....       MOV     DPTR,#__Constant_0
   \   000014   78..         MOV     R0,#?V0 + 0
   \   000016   12....       LCALL   ?L_MOV_X
   \   000019   78..         MOV     R0,#?V0 + 0
   \   00001B   79..         MOV     R1,#?V0 + 4
   \   00001D   12....       LCALL   ?SL_GT
   \   000020   5009         JNC     ??convInt32ToText_0
   \   000022   7C01         MOV     R4,#0x1
   \   000024   78..         MOV     R0,#?V0 + 4
   \   000026   12....       LCALL   ?L_NEG
   \   000029   8002         SJMP    ??convInt32ToText_1
   \                     ??convInt32ToText_0:
   \   00002B   7C00         MOV     R4,#0x0
    744              value = ABS(value);
    745          
    746              // Print the value in the reverse order
    747              do
    748              {
    749                  *(pLast++) = '0' + (uint8)(value % 10);
   \                     ??convInt32ToText_1:
   \   00002D   85....       MOV     ?V0 + 8,?V0 + 4
   \   000030   85....       MOV     ?V0 + 9,?V0 + 5
   \   000033   85....       MOV     ?V0 + 10,?V0 + 6
   \   000036   85....       MOV     ?V0 + 11,?V0 + 7
   \   000039   90....       MOV     DPTR,#__Constant_a
   \   00003C   78..         MOV     R0,#?V0 + 0
   \   00003E   12....       LCALL   ?L_MOV_X
   \   000041   78..         MOV     R0,#?V0 + 8
   \   000043   79..         MOV     R1,#?V0 + 0
   \   000045   12....       LCALL   ?L_DIV_MOD
   \   000048   E5..         MOV     A,?V0 + 0
   \   00004A   2430         ADD     A,#0x30
   \   00004C   8A82         MOV     DPL,R2
   \   00004E   8B83         MOV     DPH,R3
   \   000050   F0           MOVX    @DPTR,A
   \   000051   A3           INC     DPTR
   \   000052   AA82         MOV     R2,DPL
   \   000054   AB83         MOV     R3,DPH
    750                  value /= 10;
   \   000056   90....       MOV     DPTR,#__Constant_a
   \   000059   78..         MOV     R0,#?V0 + 0
   \   00005B   12....       LCALL   ?L_MOV_X
   \   00005E   78..         MOV     R0,#?V0 + 4
   \   000060   79..         MOV     R1,#?V0 + 0
   \   000062   12....       LCALL   ?L_DIV_MOD
    751              }
    752              while (value);
   \   000065   90....       MOV     DPTR,#__Constant_0
   \   000068   78..         MOV     R0,#?V0 + 4
   \   00006A   12....       LCALL   ?L_EQ_X
   \   00006D   70BE         JNZ     ??convInt32ToText_1
    753          
    754              // Add the '-' when the number is negative, and terminate the string
    755              if (negative)
   \   00006F   EC           MOV     A,R4
   \   000070   600B         JZ      ??convInt32ToText_2
    756              {
    757                  *(pLast++) = '-';
   \   000072   742D         MOV     A,#0x2d
   \   000074   8A82         MOV     DPL,R2
   \   000076   8B83         MOV     DPH,R3
   \   000078   F0           MOVX    @DPTR,A
   \   000079   A3           INC     DPTR
   \   00007A   0A           INC     R2
   \   00007B   AB83         MOV     R3,DPH
    758              }
    759              *(pLast--) = 0x00;
   \                     ??convInt32ToText_2:
   \   00007D   E4           CLR     A
   \   00007E   12....       LCALL   ?Subroutine3 & 0xFFFF
    760          
    761              // Now reverse the string
    762              pFirst = pValueToTextBuffer;
   \                     ??CrossCallReturnLabel_0:
   \   000081   78..         MOV     R0,#(??pValueToTextBuffer & 0xff)
   \   000083   79..         MOV     R1,#((??pValueToTextBuffer >> 8) & 0xff)
   \   000085   8019         SJMP    ??convInt32ToText_3
    763              while (pLast > pFirst)
    764              {
    765                  last =  *pLast;
   \                     ??convInt32ToText_4:
   \   000087   8A82         MOV     DPL,R2
   \   000089   8B83         MOV     DPH,R3
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   FC           MOV     R4,A
    766                  *(pLast--) =  *pFirst;
   \   00008D   8882         MOV     DPL,R0
   \   00008F   8983         MOV     DPH,R1
   \   000091   E0           MOVX    A,@DPTR
   \   000092   12....       LCALL   ?Subroutine3 & 0xFFFF
    767                  *(pFirst++) = last;
   \                     ??CrossCallReturnLabel_1:
   \   000095   EC           MOV     A,R4
   \   000096   8882         MOV     DPL,R0
   \   000098   8983         MOV     DPH,R1
   \   00009A   F0           MOVX    @DPTR,A
   \   00009B   A3           INC     DPTR
   \   00009C   A882         MOV     R0,DPL
   \   00009E   A983         MOV     R1,DPH
    768              }
   \                     ??convInt32ToText_3:
   \   0000A0   C3           CLR     C
   \   0000A1   E8           MOV     A,R0
   \   0000A2   9A           SUBB    A,R2
   \   0000A3   E9           MOV     A,R1
   \   0000A4   9B           SUBB    A,R3
   \   0000A5   40E0         JC      ??convInt32ToText_4
    769              return pValueToTextBuffer;
   \   0000A7   7A..         MOV     R2,#(??pValueToTextBuffer & 0xff)
   \   0000A9   7B..         MOV     R3,#((??pValueToTextBuffer >> 8) & 0xff)
   \   0000AB   7F0C         MOV     R7,#0xc
   \   0000AD   02....       LJMP    ?BANKED_LEAVE_XDATA
    770          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   EA           MOV     A,R2
   \   000006   24FF         ADD     A,#-0x1
   \   000008   1A           DEC     R2
   \   000009   EB           MOV     A,R3
   \   00000A   34FF         ADDC    A,#-0x1
   \   00000C   FB           MOV     R3,A
   \   00000D   22           RET

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??pValueToTextBuffer:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z
    771          

   \                                 In  segment XDATA_ROM_C, align 1
    772          static const char hex[] = 
   \                     hex:
   \   000000   30313233     DB 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70
   \            34353637
   \            38394142
   \            43444546
    773          {
    774              '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
    775          };
    776          /*******************************************************************************
    777          * @fn          halLcdDisplayUint8
    778          * @brief       Write a 8 bit value on the specified line on the LCD
    779          * @param       uint8 value - value to display
    780          *              uint8 radix - must be HAL_LCD_RADIX_DEC
    781          *              uint8 line - line on display
    782          * @return      none
    783           ******************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    784          void halLcdDisplayUint8(uint8 line, uint8 col, uint8 radix, uint8 value)
   \                     halLcdDisplayUint8:
    785          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   8A..         MOV     ?V0 + 1,R2
   \   000009   8C..         MOV     ?V0 + 4,R4
    786              if (radix == HAL_LCD_RADIX_DEC)
   \   00000B   EB           MOV     A,R3
   \   00000C   703A         JNZ     ??halLcdDisplayUint8_0
    787              {
    788                  uint8 n = 0;
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
    789                  char *pValue = convInt32ToText((uint32)value);
   \   000011                ; Setup parameters for call to function convInt32ToText
   \   000011   EC           MOV     A,R4
   \   000012   FA           MOV     R2,A
   \   000013   7B00         MOV     R3,#0x0
   \   000015   7C00         MOV     R4,#0x0
   \   000017   7D00         MOV     R5,#0x0
   \   000019   12....       LCALL   ??convInt32ToText?relay
   \   00001C   8A..         MOV     ?V0 + 4,R2
   \   00001E   8B..         MOV     ?V0 + 5,R3
   \   000020   AE..         MOV     R6,?V0 + 4
   \   000022   AF..         MOV     R7,?V0 + 5
   \   000024   800C         SJMP    ??halLcdDisplayUint8_1
    790                  while (*pValue)
    791                  {
    792                      HalLcdWriteChar(line, col + n++, *(pValue++));
   \                     ??halLcdDisplayUint8_2:
   \   000026                ; Setup parameters for call to function HalLcdWriteChar
   \   000026   12....       LCALL   ?Subroutine14 & 0xFFFF
    793                  }
   \                     ??CrossCallReturnLabel_18:
   \   000029   8E82         MOV     DPL,R6
   \   00002B   8F83         MOV     DPH,R7
   \   00002D   A3           INC     DPTR
   \   00002E   AE82         MOV     R6,DPL
   \   000030   AF83         MOV     R7,DPH
   \                     ??halLcdDisplayUint8_1:
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   FB           MOV     R3,A
   \   000038   70EC         JNZ     ??halLcdDisplayUint8_2
    794                  while (n < 3)
   \                     ??halLcdDisplayUint8_3:
   \   00003A   E5..         MOV     A,?V0 + 0
   \   00003C   C3           CLR     C
   \   00003D   9403         SUBB    A,#0x3
   \   00003F   501D         JNC     ??CrossCallReturnLabel_25
    795                  {
    796                      HalLcdWriteChar(line, col + n++, ' ');
   \   000041                ; Setup parameters for call to function HalLcdWriteChar
   \   000041   7B20         MOV     R3,#0x20
   \   000043   12....       LCALL   ?Subroutine14 & 0xFFFF
    797                  }
    798              }
   \                     ??CrossCallReturnLabel_19:
   \   000046   80F2         SJMP    ??halLcdDisplayUint8_3
    799              else if (radix == HAL_LCD_RADIX_HEX)
   \                     ??halLcdDisplayUint8_0:
   \   000048   7401         MOV     A,#0x1
   \   00004A   6B           XRL     A,R3
   \   00004B   7011         JNZ     ??CrossCallReturnLabel_25
    800              {
    801                  HalLcdWriteChar(line, col, hex[(value &0xF0) >> 4]);
   \   00004D                ; Setup parameters for call to function HalLcdWriteChar
   \   00004D   EC           MOV     A,R4
   \   00004E   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000051   12....       LCALL   ??HalLcdWriteChar?relay
    802                  HalLcdWriteChar(line, col + 1, hex[(value &0x0F)]);
   \   000054                ; Setup parameters for call to function HalLcdWriteChar
   \   000054   740F         MOV     A,#0xf
   \   000056   55..         ANL     A,?V0 + 4
   \   000058   12....       LCALL   ?Subroutine10 & 0xFFFF
    803              }
   \                     ??CrossCallReturnLabel_9:
   \   00005B   12....       LCALL   ?Subroutine19 & 0xFFFF
    804          }
   \                     ??CrossCallReturnLabel_25:
   \   00005E   02....       LJMP    ?Subroutine21 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000005   05..         INC     ?V0 + 0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   25..         ADD     A,?V0 + 1
   \   000002   FA           MOV     R2,A
   \   000003   A9..         MOV     R1,?V0 + 2
   \   000005   12....       LCALL   ??HalLcdWriteChar?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000003   7401         MOV     A,#0x1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   C4           SWAP    A
   \   000001   540F         ANL     A,#0xf
   \   000003   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   24..         ADD     A,#(hex & 0xff)
   \   000002   F582         MOV     DPL,A
   \   000004   E4           CLR     A
   \   000005   34..         ADDC    A,#((hex >> 8) & 0xff)
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FB           MOV     R3,A
   \   00000B   22           RET
    805          
    806          /*******************************************************************************
    807           @fn          halLcdDisplayUint16
    808           @brief       Write a 16 bit value on the specified line on the LCD
    809           @param       uint16 value - value to display
    810                        uint8 radix - must be HAL_LCD_RADIX_DEC
    811                        uint8 line - line on display
    812           @return      none
    813            *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    814          void halLcdDisplayUint16(uint8 line, uint8 col, uint8 radix, uint16 value)
   \                     halLcdDisplayUint16:
    815          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 3,R1
   \   000007   8A..         MOV     ?V0 + 2,R2
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
    816              if (radix == HAL_LCD_RADIX_DEC)
   \   00000D   EB           MOV     A,R3
   \   00000E   703A         JNZ     ??halLcdDisplayUint16_0
    817              {
    818                  uint8 n = 0;
   \   000010   75..00       MOV     ?V0 + 4,#0x0
    819                  char *pValue = convInt32ToText((uint32)value);
   \   000013                ; Setup parameters for call to function convInt32ToText
   \   000013   AA..         MOV     R2,?V0 + 0
   \   000015   AB..         MOV     R3,?V0 + 1
   \   000017   7C00         MOV     R4,#0x0
   \   000019   7D00         MOV     R5,#0x0
   \   00001B   12....       LCALL   ??convInt32ToText?relay
   \   00001E   8A..         MOV     ?V0 + 0,R2
   \   000020   8B..         MOV     ?V0 + 1,R3
   \   000022   AE..         MOV     R6,?V0 + 0
   \   000024   AF..         MOV     R7,?V0 + 1
   \   000026   800C         SJMP    ??halLcdDisplayUint16_1
    820                  while (*pValue)
    821                  {
    822                      lcdUpdateChar(line, col + n++, *(pValue++));
   \                     ??halLcdDisplayUint16_2:
   \   000028                ; Setup parameters for call to function lcdUpdateChar
   \   000028   12....       LCALL   ?Subroutine12 & 0xFFFF
    823                  }
   \                     ??CrossCallReturnLabel_13:
   \   00002B   8E82         MOV     DPL,R6
   \   00002D   8F83         MOV     DPH,R7
   \   00002F   A3           INC     DPTR
   \   000030   AE82         MOV     R6,DPL
   \   000032   AF83         MOV     R7,DPH
   \                     ??halLcdDisplayUint16_1:
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FB           MOV     R3,A
   \   00003A   70EC         JNZ     ??halLcdDisplayUint16_2
    824                  while (n < 5)
   \                     ??halLcdDisplayUint16_3:
   \   00003C   E5..         MOV     A,?V0 + 4
   \   00003E   C3           CLR     C
   \   00003F   9405         SUBB    A,#0x5
   \   000041   503F         JNC     ??CrossCallReturnLabel_17
    825                  {
    826                      lcdUpdateChar(line, col + n++, ' ');
   \   000043                ; Setup parameters for call to function lcdUpdateChar
   \   000043   7B20         MOV     R3,#0x20
   \   000045   12....       LCALL   ?Subroutine12 & 0xFFFF
    827                  }
    828              }
   \                     ??CrossCallReturnLabel_14:
   \   000048   80F2         SJMP    ??halLcdDisplayUint16_3
    829              else if (radix == HAL_LCD_RADIX_HEX)
   \                     ??halLcdDisplayUint16_0:
   \   00004A   7401         MOV     A,#0x1
   \   00004C   6B           XRL     A,R3
   \   00004D   7033         JNZ     ??CrossCallReturnLabel_17
    830              {
    831                  lcdUpdateChar(line, col, hex[(value &0xF000) >> 12]);
   \   00004F                ; Setup parameters for call to function lcdUpdateChar
   \   00004F   8C..         MOV     ?V0 + 4,R4
   \   000051   8D..         MOV     ?V0 + 5,R5
   \   000053   740C         MOV     A,#0xc
   \   000055   78..         MOV     R0,#?V0 + 4
   \   000057   12....       LCALL   ?US_SHR
   \   00005A   E5..         MOV     A,?V0 + 4
   \   00005C   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   00005F   12....       LCALL   ??lcdUpdateChar?relay
    832                  lcdUpdateChar(line, col + 1, hex[(value &0x0F00) >> 8]);
   \   000062                ; Setup parameters for call to function lcdUpdateChar
   \   000062   740F         MOV     A,#0xf
   \   000064   55..         ANL     A,?V0 + 1
   \   000066   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000069   12....       LCALL   ?Subroutine13 & 0xFFFF
    833                  lcdUpdateChar(line, col + 2, hex[(value &0x00F0) >> 4]);
   \                     ??CrossCallReturnLabel_15:
   \   00006C                ; Setup parameters for call to function lcdUpdateChar
   \   00006C   E5..         MOV     A,?V0 + 0
   \   00006E   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000071   7402         MOV     A,#0x2
   \   000073   12....       LCALL   ?Subroutine13 & 0xFFFF
    834                  lcdUpdateChar(line, col + 3, hex[(value &0x000F)]);
   \                     ??CrossCallReturnLabel_16:
   \   000076                ; Setup parameters for call to function lcdUpdateChar
   \   000076   740F         MOV     A,#0xf
   \   000078   55..         ANL     A,?V0 + 0
   \   00007A   12....       LCALL   ?Subroutine11 & 0xFFFF
    835              }
   \                     ??CrossCallReturnLabel_12:
   \   00007D   7403         MOV     A,#0x3
   \   00007F   12....       LCALL   ?Subroutine13 & 0xFFFF
    836          }
   \                     ??CrossCallReturnLabel_17:
   \   000082   02....       LJMP    ?Subroutine21 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   25..         ADD     A,?V0 + 2
   \   000002   FA           MOV     R2,A
   \   000003   A9..         MOV     R1,?V0 + 3
   \   000005   12....       LCALL   ??lcdUpdateChar?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E5..         MOV     A,?V0 + 4
   \   000002   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000005   05..         INC     ?V0 + 4
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000003   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteString?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteString

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteValue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteScreen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteScreen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteStringValue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteStringValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteStringValueValue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteStringValueValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdDisplayPercentBar?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdDisplayPercentBar

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??initLcd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    initLcd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??lcdCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    lcdCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??lcdData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    lcdData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcd_HW_SetContrast?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_SetContrast

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcd_HW_Clear?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_Clear

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcd_ClearLine?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_ClearLine

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcd_HW_ClearAllSpecChars?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_ClearAllSpecChars

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??lcdUpdateChar?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    lcdUpdateChar

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteChar?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteChar

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcd_HW_WriteLine?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_WriteLine

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcd_HW_WaitUs?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_WaitUs

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??convInt32ToText?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    convInt32ToText

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halLcdDisplayUint8?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halLcdDisplayUint8

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halLcdDisplayUint16?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halLcdDisplayUint16

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "[          ]  ">`:
   \   000000   5B202020     DB "[          ]  "
   \            20202020
   \            2020205D
   \            202000  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_a:
   \   000000   0A000000     DD 10
    837          #endif
    838          /**************************************************************************************************
    839          **************************************************************************************************/
    840          
    841          
    842          

   Maximum stack usage in bytes:

     Function                    ISTACK PSTACK XSTACK
     --------                    ------ ------ ------
     HalLcdDisplayPercentBar         1      0     35
       -> HalLcdWriteString          0      0     64
       -> osal_memcpy                0      0     70
       -> _ltoa                      0      0     68
       -> HalLcdWriteString          0      0     64
     HalLcdInit                      2      0      0
       -> initLcd                    4      0      0
     HalLcdWriteChar                 0      0     23
       -> lcdCommand                 0      0     18
       -> lcdCommand                 0      0     18
       -> lcdData                    0      0     18
     HalLcdWriteScreen               0      0      9
       -> HalLcdWriteString          0      0     18
       -> HalLcdWriteString          0      0     18
     HalLcdWriteString               1      0     70
       -> osal_mem_alloc             0      0     48
       -> osal_strlen                0      0     48
       -> osal_memcpy                0      0     54
       -> osal_strlen                0      0     48
       -> osal_mem_alloc             0      0     48
       -> osal_memcpy                0      0     54
       -> osal_memcpy                0      0     54
       -> osal_mem_free              0      0     48
       -> HalLcd_HW_WriteLine        0      0     48
     HalLcdWriteStringValue          1      0     47
       -> osal_strlen                0      0     86
       -> osal_memcpy                0      0     92
       -> _ltoa                      0      0     90
       -> HalLcdWriteString          0      0     86
     HalLcdWriteStringValueValue     1      0     50
       -> osal_strlen                0      0     86
       -> osal_memcpy                0      0     92
       -> _ltoa                      0      0     90
       -> osal_strlen                0      0     86
       -> _ltoa                      0      0     90
       -> HalLcdWriteString          0      0     86
     HalLcdWriteValue                0      0     42
       -> _ltoa                      0      0     82
       -> HalLcdWriteString          0      0     78
     HalLcd_ClearLine                0      0      9
       -> lcdCommand                 0      0     18
       -> lcdCommand                 0      0     18
       -> lcdData                    0      0     18
     HalLcd_HW_Clear                 0      0      9
       -> lcdCommand                 0      0     18
       -> lcdData                    0      0     18
       -> lcdCommand                 0      0     18
       -> lcdData                    0      0     18
     HalLcd_HW_ClearAllSpecChars     0      0      9
       -> lcdCommand                 0      0     18
       -> lcdData                    0      0     18
     HalLcd_HW_SetContrast           0      0      9
       -> lcdCommand                 0      0     18
       -> lcdData                    0      0     18
     HalLcd_HW_WaitUs                0      0      0
     HalLcd_HW_WriteLine             0      0     35
       -> osal_strlen                0      0     22
       -> lcdUpdateChar              0      0     22
       -> lcdUpdateChar              0      0     22
     convInt32ToText                 1      0     34
     halLcdDisplayUint16             0      0     14
       -> convInt32ToText            0      0     28
       -> lcdUpdateChar              0      0     28
       -> lcdUpdateChar              0      0     28
       -> lcdUpdateChar              0      0     28
       -> lcdUpdateChar              0      0     28
       -> lcdUpdateChar              0      0     28
       -> lcdUpdateChar              0      0     28
     halLcdDisplayUint8              0      0     14
       -> convInt32ToText            0      0     28
       -> HalLcdWriteChar            0      0     28
       -> HalLcdWriteChar            0      0     28
       -> HalLcdWriteChar            0      0     28
       -> HalLcdWriteChar            0      0     28
     initLcd                         2      0      0
       -> halMcuWaitMs               4      0      0
       -> lcdCommand                 4      0      0
       -> halMcuWaitMs               4      0      0
       -> lcdCommand                 4      0      0
       -> halMcuWaitMs               4      0      0
       -> lcdCommand                 4      0      0
       -> halMcuWaitMs               4      0      0
       -> lcdCommand                 4      0      0
       -> halMcuWaitMs               4      0      0
       -> lcdCommand                 4      0      0
       -> halMcuWaitMs               4      0      0
       -> lcdCommand                 4      0      0
       -> lcdCommand                 4      0      0
       -> lcdCommand                 4      0      0
       -> halMcuWaitMs               4      0      0
       -> HalLcd_HW_Clear            4      0      0
       -> lcdCommand                 4      0      0
     lcdCommand                      2      0      9
       -> halMcuWaitUs               4      0      0
       -> halMcuWaitUs               4      0      0
     lcdData                         2      0      9
       -> halMcuWaitUs               4      0      0
       -> halMcuWaitUs               4      0      0
     lcdUpdateChar                   0      0     23
       -> lcdCommand                 0      0     18
       -> lcdCommand                 0      0     18
       -> lcdData                    0      0     18


   Segment part sizes:

     Function/Label                      Bytes
     --------------                      -----
     _A_P0                                  1
     _A_P1                                  1
     _A_P2                                  1
     P0SEL                                  1
     P1SEL                                  1
     P2SEL                                  1
     P0DIR                                  1
     P1DIR                                  1
     P2DIR                                  1
     Lcd_Line1                              2
     pLedData                               1
     HalLcdInit                            16
     ??Subroutine25_0                       7
     HalLcdWriteString                    265
     ??Subroutine26_0                       8
     ??Subroutine27_0                       6
     HalLcdWriteValue                      60
     ?Subroutine21                          5
     ??Subroutine29_0                       6
     HalLcdWriteScreen                     26
     ?Subroutine23                          5
     HalLcdWriteStringValue                97
     ?Subroutine24                         23
     ?Subroutine0                           4
     ?Subroutine4                           7
     ?Subroutine1                           4
     ??Subroutine28_0                       4
     HalLcdWriteStringValueValue          220
     ?Subroutine2                           4
     HalLcdDisplayPercentBar              166
     initLcd                               78
     ?Subroutine8                           2
     ??Subroutine30_0                       4
     ?Subroutine7                          11
     ?Subroutine16                         11
     ?Subroutine20                          3
     lcdCommand                            12
     ?Subroutine5                          27
     lcdData                               12
     HalLcd_HW_SetContrast                 15
     ??Subroutine32_0                      11
     HalLcd_HW_Clear                       31
     ?Subroutine15                          2
     ??Subroutine31_0                       6
     HalLcd_ClearLine                      26
     HalLcd_HW_ClearAllSpecChars           21
     lcdUpdateChar                         22
     ?Subroutine22                          6
     ?Subroutine6                           1
     HalLcdWriteChar                       24
     HalLcd_HW_WriteLine                   81
     HalLcd_HW_WaitUs                      55
     convInt32ToText                      176
     ?Subroutine3                          14
     pValueToTextBuffer                    12
     hex                                   16
     halLcdDisplayUint8                    97
     ?Subroutine14                          8
     ?Subroutine19                          9
     ?Subroutine10                          6
     ?Subroutine9                           7
     ?Subroutine18                         12
     halLcdDisplayUint16                  133
     ?Subroutine13                          4
     ?Subroutine17                          9
     ?Subroutine12                          8
     ?Subroutine11                          4
     ??HalLcdInit?relay                     6
     ??HalLcdWriteString?relay              6
     ??HalLcdWriteValue?relay               6
     ??HalLcdWriteScreen?relay              6
     ??HalLcdWriteStringValue?relay         6
     ??HalLcdWriteStringValueValue?relay    6
     ??HalLcdDisplayPercentBar?relay        6
     ??initLcd?relay                        6
     ??lcdCommand?relay                     6
     ??lcdData?relay                        6
     ??HalLcd_HW_SetContrast?relay          6
     ??HalLcd_HW_Clear?relay                6
     ??HalLcd_ClearLine?relay               6
     ??HalLcd_HW_ClearAllSpecChars?relay    6
     ??lcdUpdateChar?relay                  6
     ??HalLcdWriteChar?relay                6
     ??HalLcd_HW_WriteLine?relay            6
     ??HalLcd_HW_WaitUs?relay               6
     ??convInt32ToText?relay                6
     ??halLcdDisplayUint8?relay             6
     ??halLcdDisplayUint16?relay            6
     ?<Constant "[          ]  ">          15
     __Constant_0                           4
     __Constant_a                           4

 
 1 881 bytes in segment BANKED_CODE
   126 bytes in segment BANK_RELAYS
     9 bytes in segment SFR_AN
    39 bytes in segment XDATA_ROM_C
    15 bytes in segment XDATA_Z
 
 2 007 bytes of CODE  memory
    31 bytes of CONST memory (+ 8 bytes shared)
     0 bytes of DATA  memory (+ 9 bytes shared)
    15 bytes of XDATA memory

Errors: none
Warnings: none
